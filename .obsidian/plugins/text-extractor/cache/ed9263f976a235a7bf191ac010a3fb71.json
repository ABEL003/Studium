{"path":"3.Semester/Datenmanagement/Strukturieren in XML/XML11.pdf","text":"XML 1.1 Grundlagen XML11 Elmar Fuchs, Heiko Schröder 5. Ausgabe, Januar 2015 ISBN: 978-3-86249-407-1 Hochschule Aalen - Technik und Wirtschaft Webcode - Übungsdateien E68F-7137-17C6 In Kooperation mit dem HERDT-Verlag stellen wir Ihnen eine PDF inkl. Zusatzmedien für Ihre persönliche Weiterbildung zur Verfügung. In Verbindung mit dem Programm HERDT-Campus ALL YOU CAN READ stehen diese PDFs für Forschung und Lehre nur Mitarbeiterinnen und Mitarbeitern sowie Studierenden der oben genannten Hochschule zur Verfügung. Eine Nutzung oder Weitergabe für andere Zwecke ist ausdrücklich verboten und unterliegt dem Urheberrecht. Jeglicher Verstoß kann zivil- und strafrechtliche Konsequenzen nach sich ziehen. Hochschulversion I XML 1.1 - Grundlagen 2 © HERDT-Verlag 1 Informationen zu diesem Buch .................. 4 1.1 Voraussetzungen und Ziele ................................ 4 1.2 Aufbau und Konventionen ................................ 5 2 Einführung in XML ...................................... 8 2.1 Auszeichnungssprachen ..................................... 8 2.2 XML ..................................................................... 8 2.3 Die Verwendung von XML ............................... 11 3 Aufbau eines XML-Dokuments ................ 14 3.1 Die grundlegende XML-Syntax ........................ 14 3.2 Prolog als Definition eines XML-Dokuments ...... 16 3.3 Anlegen von XML-Elementen .......................... 18 3.4 Attribute eines Elements .................................. 21 3.5 Kommentare hinzufügen ................................. 22 3.6 Wohlgeformtheit eines XML-Dokuments ........ 23 3.7 Ein XML-Dokument erstellen ........................... 23 3.8 XML-Editor Editix .............................................. 25 3.9 Schnellübersicht ................................................ 26 3.10 Übungen ........................................................... 27 4 Elemente der DTD ..................................... 28 4.1 Dokumenttyp-Definition .................................. 28 4.2 Definition einer internen DTD ......................... 29 4.3 Deklarieren der Elementtypen ......................... 30 4.4 Angabe der Elemente ....................................... 30 4.5 Externe Teilmenge der DTD ............................. 34 4.6 Gültiges Dokument........................................... 37 4.7 Schnellübersicht ................................................ 38 4.8 Übungen ........................................................... 39 5 DTD – Attribute von Elementen ............... 40 5.1 Attributlisten-Definition................................... 40 5.2 Attributtypen .................................................... 45 5.3 Referenz auf Entitäten ..................................... 47 5.4 Datentyp Notation ......................................... 51 5.5 Schnellübersicht ................................................ 54 5.6 Übung ............................................................... 55 6 Namensräume ........................................... 56 6.1 Grundlagen zu Namensräumen ....................... 56 6.2 Deklaration von Namensräumen ..................... 57 6.3 Externe DTD und eigener Namensraum .......... 60 6.4 Übungen ........................................................... 62 7 XML Schema .............................................. 64 7.1 Der Unterschied zwischen Schema und DTD ...... 64 7.2 Grundlagen zu XML Schema ............................. 66 7.3 Schema-Grundgerüst ......................................... 68 7.4 Einfache Typen .................................................. 70 7.5 Datentypen ........................................................ 76 8 Komplexe Elemente in Schema ............... 82 8.1 Was ist ein komplexes Element? ....................... 82 8.2 Definition eines komplexen Elements .............. 82 8.3 Indikatoren ........................................................ 86 8.4 Schema erweitern ............................................. 90 8.5 Schema 1.1 ......................................................... 91 8.6 Übungen ............................................................ 95 9 Formatierungssprachen ........................... 96 9.1 Übersicht der Sprachen ..................................... 96 9.2 Grundlagen von XSL .......................................... 96 9.3 Einbinden von CSS ............................................. 98 9.4 Übung .............................................................. 101 10 XPath ....................................................... 102 10.1 XPath-Grundlagen .......................................... 102 10.2 XML-Prinzipien ................................................ 104 10.3 XPath 2.0 ......................................................... 109 10.4 Übung .............................................................. 112 11 XSL und XSLT ........................................... 114 11.1 Einführung in XSL ........................................... 114 11.2 Einbinden einer XSL-Datei .............................. 116 11.3 Templates ........................................................ 116 11.4 Selektion mit Filter in XPath ........................... 119 11.5 Inhalte der Elemente ausgeben ...................... 120 11.6 Reihenfolge der Template-Aufrufe ................ 122 11.7 Übungen .......................................................... 124 12 XSLT-Elemente ........................................ 126 12.1 Schleifen und Fallunterscheidungen .............. 126 12.2 Schleifenbildung ............................................. 126 12.3 Elemente sortieren .......................................... 129 12.4 Einfache Fallunterscheidung ........................... 130 12.5 Komplexe Fallunterscheidung ........................ 132 12.6 Übungen .......................................................... 135 Hochschulversion Inhalt I © HERDT-Verlag 3 13 Links in XML............................................. 136 13.1 Einführung in XLink ........................................ 136 13.2 XLink ................................................................ 136 13.3 Einfache Links .................................................. 138 13.4 Erweiterte und multidirektionale Links .......... 140 13.5 XBase ............................................................... 144 14 XQuery...................................................... 146 14.1 XQuery-Grundlagen ........................................ 146 14.2 XPath basierte XQuery-Abfragen ................... 148 14.3 Abfragen mit FLWOR-Ausdrücken .................. 150 14.4 Gestaltung der Ausgabe der Auswertungsergebnisse .................................. 152 14.5 Auswertung verbundener Dokumente ........... 153 14.6 Übungen .......................................................... 155 15 DOM und SAX .......................................... 156 15.1 DOM ................................................................ 156 15.2 Erzeugen eines XML-DOM .............................. 157 15.3 Ansprechen der Knotenelemente ................... 158 15.4 SAX .................................................................. 168 15.5 XML-Datenblöcke in HTML5 ........................... 169 15.6 Übungen ......................................................... 172 16 XHTML 1.1 ................................................ 174 16.1 Überblick zu XHTML ....................................... 174 16.2 XHTML-Dokument deklarieren....................... 175 16.3 Elemente in XHTML ........................................ 177 16.4 Attribute und Werte in XHTML ...................... 178 16.5 JavaScript und Stylesheets in XHTML ............. 179 16.6 W3C MarkUp Validation Service ..................... 180 16.7 Übung.............................................................. 181 17 SVG........................................................... 182 17.1 SVG-Grundlagen ............................................. 182 17.2 Erzeugung von SVG-Grafiken ......................... 182 17.3 Einbindung von SVG in HTML5....................... 185 Stichwortverzeichnis ................................... 186 Hochschulversion 1 XML 1.1 - Grundlagen 4 © HERDT-Verlag 1 Informationen zu diesem Buch In diesem Kapitel erfahren Sie  an wen sich dieses Buch richtet  welche Vorkenntnisse Sie benötigen  welche Software Sie für die Arbeit mit diesem Buch benötigen  wie dieses Buch aufgebaut ist und welche Konventionen verwendet werden 1.1 Voraussetzungen und Ziele Zielgruppe Zielgruppe dieses Buches sind alle, die Daten per XML verwalten, austauschen und verarbeiten möchten. Empfohlene Vorkenntnisse Für die generelle Thematik XML sind die genannten Vorkenntnisse nicht zwingend erforderlich, erleichtern aber das Verständnis. Einige Kapitel setzen jedoch entsprechende Kenntnisse voraus.  Kenntnisse in HTML  Kenntnisse in CSS (Kapitel 9)  Kenntnisse in JavaScript (Kapitel 15) Lernziele In diesem Buch lernen Sie, wie die XML-Daten angegeben werden müssen, welche Möglichkeiten Ihnen zur Verfügung stehen, die Struktur der Daten zu verifizieren und wie Sie die verschiedenen XML-Elemente anhand von Vorgaben selektieren können. Außerdem erlernen Sie, wie Sie mithilfe von JavaScript XML-Daten auswerten und formatiert im Browser anzeigen. Hinweise zur Software Die hier aufgeführten Programme waren zum Zeitpunkt der Bucherstellung aktuell. Es ist möglich, dass es im Laufe der Zeit Änderungen gibt, die wir nicht berücksichtigen können – beispielsweise im Hinblick auf kostenlos angebotene Software. Sofern nicht anders vermerkt, wird im Folgenden davon ausgegangen, dass Sie die unten genannten Browser oder neuere Versionen verwenden. Name Version Erhältlich unter der Internetadresse: Internet Explorer 11 http://windows.microsoft.com/de-de/internet-explorer/download-ie Mozilla Firefox 33 http://www.mozilla-europe.org/de/firefox/ Opera 25 http://de.opera.com/ Apple Safari 7 http://www.apple.com/de/safari/ Google Chrome 38 http://www.google.com/chrome/ Hochschulversion Informationen zu diesem Buch 1 © HERDT-Verlag 5 Verwendete Software Betriebssystem Programm Windows, Unix/Linux, Mac OS X Free XML Editor Editix (http://www.freexmleditorsite.com/) Windows Altova XMLSpy 2015 Professional Edition (http://www.altova.com/) In diesem Buch werden XML-Tools für das Betriebssystem Windows benutzt. Für das Betriebssystem Linux gibt es ähnliche Programme. Eine Auflistung von weiteren XML-Tools für Linux, Windows, Solaris bzw. Macintosh finden Sie unter anderem auf der englischsprachigen Webseite http://www.garshol.priv.no/download/xmltools/. XML Editor EditiX Die Software XML Editor EditiX (https://www.editix.com) kann 30 Tage kostenlos getestet werden. Da diese Software auf Java basiert, kann sie unter den Betriebssystemen Windows, Unix/Linux und Mac OS X eingesetzt werden. Die umfangreiche Software unterstützt Sie beim Erstellen eines XML-Dokuments. Sie erlaubt Ihnen über eine grafische Oberfläche die komfortable Bearbeitung einer XML-Datei und bietet neben der Ansicht des Quell- texts auch die übersichtliche Baumansicht der Struktur des XML-Dokuments. Alternativ findet man einige Tools im Web, z. B. unter https://appuals.com/the-5-best-free-xml-editors/. Dort wird u. a. der Notepad++ empfohlen. Auch den Editor Textpad, der für Java verwendet wird, kann man für XML-Dateien nutzen. (Stand: April 2020) Altova XMLSpy Altova bietet ein ganzes Paket von Programmen für die Arbeit im Zusammenhang mit XML Dokumenten an. Das Programm XMLSpy gibt es als Professional und als Enterprise Edition. Bereits die Professional Edition unterstützt alle im Buch behandelten Themen. Für Testzwecke wird eine voll funktionsfähige 30-Tage- Testversion angeboten (www.altova.com). Besonderheit der Browser Google Chrome und Opera Aus Sicherheitsgründen laden Chrome und Opera aus lokalen XML-Dateien keine XSL-Dateien, sodass die im Buch erwähnten Beispiele ab Kapitel 10 lokal nicht ausgeführt werden können. Stattdessen wird nur eine leere Seite angezeigt. Wenn die Dateien auf einen Webserver übertragen und von dort aufgerufen werden, dann werden die XML-Dateien korrekt wiedergegeben. Um auch lokal die Ergebnisse zu erhalten, müssen Sie die Browser mit der zusätzlichen Option --allow- file-access-from-files starten. Damit erhalten Sie die Möglichkeit, die Daten aus XML-Dateien auch lokal per XPath und XSL zu formatieren. 1.2 Aufbau und Konventionen Aufbau und inhaltliche Konventionen des Buchs  Am Anfang jedes Kapitels finden Sie die Lernziele.  Die einzelnen Kapitel enthalten Übungen, mit deren Hilfe Sie die erlernten Kapitelinhalte wiederholen können.  In Kapitel 2 - 8 lernen Sie die Grundlagen sowie die Strukturdefinition von XML-Dokumenten mittels DTD und XML-Schema kennen.  Die Kapitel 9 - 14 zeigen die Darstellung von XML-Dokumenten und die Selektion einzelner Dokumentbestandteile. Es werden die Themen Einsatz von CSS, XSL, XSLT, XPath, XLink und XQuery behandelt.  Das Kapitel 15 beschäftigt sich mit dem programmatischen Zugriff auf XML-Dokumente.  Die Kapitel 16 und 17 stellen mit XHTML und SVG zwei Anwendungen von XML vor. Hochschulversion 1 XML 1.1 - Grundlagen 6 © HERDT-Verlag Typografische Konventionen Damit Sie bestimmte Elemente auf einen Blick erkennen und zuordnen können, werden diese im Text durch eine besondere Schreibweise hervorgehoben. So werden beispielsweise wichtige Begriffe fett hervor- gehoben. Kursivschrift kennzeichnet Datei-und Ordnernamen, Hyperlinks und Bezeichnungen für Menüs bzw. Menüpunkte, sowie Programmelemente wie Register oder Schalt- flächen. Courier New kennzeichnet Programmtext, Programmnamen, Funktionsnamen, Variablen- namen, Datentypen, Operatoren etc. Courier New Kursiv kennzeichnet Zeichenfolgen, die vom Anwendungsprogramm ausgegeben oder ins Programm eingegeben werden. [ ] Bei Darstellungen der Syntax einer Programmiersprache kennzeichnen eckige Klammern optionale Angaben. / Bei Darstellungen der Syntax einer Programmiersprache werden alternative Elemente durch einen Schrägstrich voneinander getrennt.  Zu lange Programmzeilen oder Internetadressen (die eigentlich nicht getrennt werden dürfen) werden auf der nächsten Zeile fortgesetzt. Was bedeuten die Symbole im Buch? Hilfreiche Zusatzinformation Warnhinweis Praxistipp Download-Adresse Downloaddateien Nutzen Sie unsere maßgeschneiderten, im Internet frei verfügbaren Medien:  Rufen Sie im Browser die Internetadresse www.herdt.com auf. 1 Wählen Sie Codes. 2 Geben Sie den folgenden Matchcode ein: XML11 Hochschulversion Informationen zu diesem Buch 1 © HERDT-Verlag 7 Hochschulversion 2 XML 1.1 - Grundlagen 8 © HERDT-Verlag 2 Einführung in XML In diesem Kapitel erfahren Sie etwas zur Geschichte der Auszeichnungssprachen den Zusammenhang zwischen SGML, HTML und XML welche Vorteile XML gegenüber HTML besitzt 2.1 Auszeichnungssprachen Auszeichnungssprachen sind dafür konzipiert, neben den Textdaten, die den Inhalt eines Dokuments darstel- len, auch spezielle Informationen hinzuzufügen. Auszeichnungssprachen gibt es schon sehr lange. Früher be- nutzten beispielsweise die Druckereien ihre eigene Sprache, um Anmerkungen an Textpassagen zu setzen. Somit wusste der Drucker, der das Dokument vom Autor erhielt, worauf er bei bestimmten Stellen im Text achten sollte. Mit Verbreitung der Computer wurde es möglich, Texte digital zu verarbeiten. Es entstand eine Vielzahl von Programmen, einige davon als Speziallösung für große Verlage und Druckereien. Eines davon ist das Satz- programm TEX von Donald E. Knuth, das bereits Mitte der 70er-Jahre entwickelt wurde. TEX ist eine Software zur Formatierung von Dokumenten, mit der nahezu alle Aufgaben einer Druckerei gelöst werden können, u. a. das Setzen komplexer Formeln und Tabellen. Der Umfang der Beschreibungssprache TEX ist festgelegt, wobei besonderer Wert auf das einfache Erstellen von technisch-wissenschaftlichen Dokumenten gelegt wurde. 1985 entstand die Meta-Auszeichnungssprache SGML (Standard Generalized Markup Language) für die In- haltsstruktur von Dokumenten, die in der Norm ISO 8879 als Standard festgelegt wurde. Diese Sprache be- inhaltet eine Vielzahl von Befehlen, deren Dokumentation mit 500 Seiten sehr umfangreich ist. Außerdem wurde die Document Type Definition, kurz DTD, eingeführt, mit der sich eigene Auszeichnungssprachen beschreiben lassen. Darauf beruhend wurde die Auszeichnungssprache HTML (HyperText Markup Language) als „Sprache des Internets“ entwickelt. Festgelegt wurde die Spezifikation der Sprache vom W3-Konsortium (kurz W3C). Das ist eine internationale Organisation, die an der Entwicklung neuer Protokollspezifikationen und Architekturen für das World Wide Web arbeitet. Mitglieder sind z. B. Firmen wie Adobe, Microsoft und Sun Microsystems. Lange Zeit basierten alle verfügbaren Webseiten auf HTML. 2.2 XML Entstehung Die Meta-Auszeichnungssprache SGML und die Auszeichnungssprache HTML haben einige Nachteile. SGML ist ein sehr komplexer Standard mit unzähligen Möglichkeiten und somit zum Design von Webseiten nicht geeignet. HTML, hat den plattform- und systemunabhängigen Informationsaustausch in den Datennetzen ermöglicht und somit den Internet-Boom ausgelöst. HTML wurde speziell für die Anzeige von Daten entworfen und ist zu unflexibel, um bestimmte Erweiterungen, beispielsweise die direkte Unterstützung von Videos, zu unter- stützen. HTML besteht aus einer fest definierten Menge von Auszeichnungen wie beispielsweise Überschrif- ten, Absätze, Tabellen. Aus dem Bestreben, HTML um zusätzliche über den Standard hinausgehende Möglich- keiten zu erweitern, entwickelten sich die Browser durch das nicht abgestimmte Handeln der einzelnen Hersteller unterschiedlich. Im Ergebnis wird nicht jede Seite von jedem Browser einheitlich dargestellt. Ein weiterer Nachteil von HTML besteht darin, dass in einer HTML-Seite im Wesentlichen alles Text ist. Für die gezielte Suche nach Informationen sind die Browser deshalb auf die Volltextsuche angewiesen. Hochschulversion Einführung in XML 2 © HERDT-Verlag 9 Als Alternative verabschiedete das W3-Konsortium im Februar 1998 den XML-Standard, der eine stark vereinfachte Teilmenge von SGML ist. Die Idee des W3-Konsortiums war es, eine Metasprache zu schaffen, welche die grundlegenden Vorzüge von SGML besitzt, auf die Nachteile von HTML verzichtet und für jeden Autor leicht zu erlernen ist. Derzeit umfasst die Standardisierungsdokumentation von XML ca. 35 Seiten, also nur einen Bruchteil des Umfangs der SGML-Beschreibung. Eine Version der ersten XML Empfehlung von 1998 mit Kommentaren über deren Entstehungsgeschichte von Tim Bray, der selbst Mitglied der Entwicklungskommission war, finden Sie unter http://www.xml.com/axml/axml.html. SGML MathML XML WML XHTML eigene DTD XML ist eine Teilmenge von SGML Aufbau von XML XML (eXtensible Markup Language) ist eine Teilmenge von SGML. In dem Begriff „extensible“ wird schon an- gedeutet, worum es bei dieser Sprache hauptsächlich geht: Sie ist so konzipiert, dass sie sich erweitern lässt. Dies ist möglich, da XML genau wie SGML keinen vordefinierten Aufbau in Form einer DTD (Document Type Definition) besitzt, sondern lediglich die Vorschriften zum Erstellen einer eigenen Typdefinition bereithält. Somit sind Sie in der Lage, mit einer eigenen DTD neue Sprachelemente zu entwickeln. In XML wird die Struktur der Auszeichnungssprache definiert. Die definierten Elemente haben keinerlei Bedeutung für das Aussehen. Dies wird beispielsweise erst über Cascading Stylesheets (CSS) definiert. Die definierten Elemente beschreiben vielmehr die logische Struktur eines Dokuments und ermöglichen es, beliebige Strukturen zu bezeichnen. Die Metasprache XML ist nicht der Nachfolger der Auszeichnungssprache HTML. Während XML das Instru- mentarium zur Bezeichnung von Dokumentstrukturen liefert, stellt HTML einen beschränkten Satz von Elementen zur Verfügung, mit dem Dokumente logisch ausgezeichnet werden können. Beispiel <html> <head> <title>Titel der Seite</title> </head> <body> <h1>Überschrift der 1.Ebene</h1> <p>Absatz mit Informationen</p> <p>Absatz mit Informationen</p> </body> </html> <dokument> <kopf> <titel>Titel der Seite</titel> </kopf> <koerper> <ueber>Überschrift der 1. Ebene</ueber> <absatz>Absatz mit Informationen</absatz> <absatz>Absatz mit Informationen</absatz> </koerper> </dokument> Gegenüberstellung der Syntax von HTML und XML Der Inhalt eines XML-Dokuments ist eine Baumstruktur mit genau einem Wurzelelement und stellt die interne Struktur des Dokuments dar. Dieser Baum kann durch einen sogenannten XML-Parser aufgebaut werden. Auf diese Weise kann für eine Anwendung, z. B. einen Browser, der Zugriff auf einzelne Baum- knoten ermöglicht werden. Hochschulversion 2 XML 1.1 - Grundlagen 10 © HERDT-Verlag Parser XML Anwendung Aufbereitung der XML-Daten über eine Baumstruktur Derzeit existieren spezielle Sprachen, die von der XML-Spezifikation abgeleitet wurden. Nachfolgend finden Sie eine kleine Auswahl. Sprache Erläuterung Internetadressen XHTML Extensible Hypertext Markup Language Neuformulierung von HTML 4.0 auf Basis von XML (vgl. Kap. 16) http://www.w3.org/TR/xhtml11/ MathML Mathematical Markup Language Sprache zur Darstellung mathematischer Strukturen http://www.w3.org/Math SVG Scalable Vector Graphics Sprache zur Definition von Grafikobjekten (vgl. Kap. 17) http://www.w3.org/Graphics/SVG CML Chemical Markup Language Informationen über chemische Strukturen http://cml.sourceforge.net Weitere XML-verwandte Technologien DTD Document Type Definition ist eine Sprache zur Definition von möglichen Elementtypen, Attri- buten und Entities innerhalb eines XML-Dokuments. DTD benutzt eine SGML-verwandte Syntax. Schema Schema ist wie DTD eine Empfehlung zur Definition der Struktur eines XML-Dokuments. Das Er- stellen eines Schemas erfolgt über die XML-Syntax und ist somit ebenfalls ein XML-Dokument. XHTML Extensible Hypertext Markup Language ist eine Auszeichnungssprache für Webseiten. Sie ist die Neuformulierung von HTML 4.0 in XML 1.0. XSL Extensible Stylesheet Language dient unter anderem zum Erstellen der Definition von Style- sheets. Sie beschreiben, wie die XML-Daten dem Benutzer angezeigt werden sollen. Zu XSL gehören XSL-FO (Formatting Objects), XSLT und damit indirekt auch XPath. XSLT Extensible Stylesheet Language for Transformations ist eine Sprache für die Umwandlung von XML-Dokumenten in andere Dokumenttypen, wie z. B. HTML oder auch wieder XML. XSLT beschreibt dabei, wie das Dokument transformiert werden soll. XPath Extensible Path Language ist eine Sprache zum Adressieren von Teilen eines XML-Dokuments, die sowohl von XSLT als auch von XPointer verwendet werden kann. XPath war früher Bestand- teil von XSLT und ist jetzt ein eigener Standard. XLink Extensible Linking Language ist eine Spezifikation für Hyperlinks im XML-Dokument. Sie enthält den Adressierungsstandard XPointer. XPointer Extensible Pointer Language gibt an, wie Adressen in XLink-Ausdrücken zu verwenden sind. XPointer legt das Format des Teils eines Hyperlinks fest, der auf eine Sprungmarke (Anker) eines XML-Dokuments verweist. XQuery Extensible Query Language ist eine Abfragesprache, die XML als Datenmodell verwendet. Hochschulversion Einführung in XML 2 © HERDT-Verlag 11 SGML HTML XML XLink XPointer XSLTXSL XHTML XQuery XPath Schema DTD Zusammenhang von SGML, HTML, XML und verwandten Technologien 2.3 Die Verwendung von XML Basis des Datenaustauschs Obwohl ursprünglich als Form zur Darstellung von Dokumenten gedacht, hat sich XML mittlerweile als Sprache für den Datenaustausch zwischen Systemen etabliert. Diese Möglichkeit der Anwendung der Sprache wurde bereits frühzeitig erkannt. Ron Rappaport, ein Industrieanalyst der Firma Zona Research, drückte es 1998 folgendermaßen aus: „XML ist ein einfacherer, flexiblerer und kostengünstigerer Weg, um Daten zwischen verschiedenen Anwendungen auszutauschen, als alle heute vorhandenen Mittel. Es ist ein Schlüsselelement der Business-zu-Business-Kommunikation (B2B). XML wird den Informationsaustausch in Firmen revolutionieren, vergleichbar mit der Entwicklung des Telefons, Fax und Fotokopierers. Diese vorgenannten Erfindungen erleichterten den Informationsaustausch erheblich, und XML ist dabei, diese Entwicklung im Internet zu vollziehen.“ Heute wird immer mehr XML verwendet, wenn es um die Darstellung und den Austausch von Informationen in Unternehmen geht. Mitverantwortlich für diese positive Entwicklung sind Softwarehersteller wie IBM, Adobe Systems, Microsoft und Sun Microsystems, die den Standard bereits seit Jahren in ihren Produkten einsetzen. Beispielsweise basiert das Format der Dokumente der Office Suite von Microsoft auf XML. Der Großteil der Softwareanwendungen besitzt heute eine Schnittstelle, um Daten im XML-Format zu im- bzw. exportieren und immer mehr relationale Datenbankmanagementsysteme unterstützen das Format XML. Ein Beispiel für den möglichen Einsatz von XML als unabhängige Datenplattform ist die Speicherung von Produktdaten im elektronischen Handel (E-Commerce). Benutzt eine Vielzahl von Anbietern eine gemeinsam entwickelte Sprache zum Verwalten des Produktkatalogs, ist es für den Endnutzer auf einfache Weise möglich, nach einem bestimmten Produkt im Internet zu suchen, ohne jede einzelne Webseite des Anbieters aufzurufen. Er schickt sogenannte Software-Agenten auf die Suche nach dem preiswertesten Angebot. Diese durchsuchen das Internet nach den festgelegten Suchkriterien und liefern dem Kaufinteressenten nur das zurück, was er wissen will: Wie viel kostet ein Produkt bei den verschiedenen Anbietern und wo erhalte ich es am günstigsten? XML im Unternehmen Nicht nur im Internet verbreitet sich die Anwendung von XML. Auch die Verwaltung von Firmendaten verein- facht sich durch die Anwendung des XML-Formats für die Datenspeicherung. Stellen Sie sich vor, Sie sind Händler von Computer-Hardware. In diesem Fall werden Sie eine Datenbank erstellen, welche die Produkte Ihres Unternehmens verwaltet. Ihren Kunden möchten Sie monatlich eine Informations-CD mit den neuesten Produkten zukommen lassen, wobei die Daten zusätzlich im Internet in Form eines Online-Shops zu finden sein sollen. Als Werbemittel versenden Sie einen gedruckten Katalog, den Sie ebenfalls als Download- Möglichkeit im Internet anbieten möchten. Hochschulversion 2 XML 1.1 - Grundlagen 12 © HERDT-Verlag Datenbankserver im Intranet Daten für CD-Erstellung Daten für Online-Katalog Daten für Druckmedium Datenbank für Online-Shop Allein diese Art der Produktdarstellung erfordert bisher eine drei- bis vierfache Datenhaltung, da Sie die Daten für jedes unterschiedliche Medium in das entsprechende Format bringen müssen. Medium Datenformat Datenbankserver SQL-Abfragesprache Online-Katalog PDF (Portable Document Format) Daten auf CD HTML Druckmedium PostScript, zunehmend auch PDF Mit XML stellen Sie einmalig die notwendigen Daten zur Verfügung und können diese über eine XSL-Trans- formation in das gewünschte Ausgabeformat bringen. Mit dem definierten Format von XSL-FO (Formatting Objects) beschreiben Sie, wie die Ausgabe der Daten aussehen soll. Ein Prozessor setzt die Beschreibung um und generiert das entsprechende Ausgabeformat, z. B. ein PDF oder RTF-Dokument. XML und HTML Während XML in der beschriebenen Form heute vielfach zum Einsatz kommt, konnte der ursprüngliche Ansatz HTML durch XML abzulösen, nicht realisiert werden. Die als Nachfolgesprache gedachte Empfehlung XHTML stieß bei den Entwicklern von Webseiten auf ein eher gedämpftes Echo. Eine Ursache dafür waren die Anforderungen an einen 100% exakten Code. Jeder Fehler in einer XHTML führt dazu, dass die Seite nicht dargestellt werden kann. Als Konsequenz auf die mangelnde Akzeptanz wurde mit HTML5 ein Weg zur Modernisierung von HTML gewählt. Dieser erlaubt sowohl die flexiblere Anwendung von HTML als auch, wenn der Entwickler es möchte, den Einsatz der strengeren Regeln von XHTML. Mit XHTML als eine Form der Anwendung von XML beschäftigt sich Kapitel 16. Hochschulversion Einführung in XML 2 © HERDT-Verlag 13 Hochschulversion 3 XML 1.1 - Grundlagen 14 © HERDT-Verlag 3 Aufbau eines XML-Dokuments In diesem Kapitel erfahren Sie wie Sie ein XML-Dokument erstellen was Sie bei der Angabe von Elementen beachten müssen wie Sie Daten in eine XML-Struktur bringen was unter einem wohlgeformten Dokument zu verstehen ist Voraussetzungen Editor zum Erfassen des Quelltextes XML-fähiger Browser Grundkenntnisse in HTML (sind hilfreich) 3.1 Die grundlegende XML-Syntax Abhängig vom gewählten Zeichensatz kann ein XML-Dokument im Text-Format dargestellt werden. Somit kann es in jedem Texteditor, beispielsweise dem Windows-Standard-Editor Notepad, erstellt werden. Das Dokument enthält, wie in HTML, die Elemente und die zu verarbeitenden Daten. Dabei wird das Dokument in zwei Bereiche eingeteilt, den Prolog mit den Angaben zum XML-Dokument, der Dokumenttyp-Definition sowie gegebenenfalls weiteren Angaben wie eine zu verwendende Stylesheet-Deklaration für die Darstellung der Datei und den Bereich mit der Auflistung der Elemente. Beschreibung XML Prolog (u. a. DTD-Definition) <?xml version=\"1.0\"?> <!DOCTYPE ...> Elemente <BEREICH> </BEREICH> Der XML-Standard 1.1 erlaubt die Prolog-Definition <?xml version=\"1.1\"?>, jedoch unterstützen die beiden weitverbreiteten Browser Internet Explorer und Firefox diese Version nicht. Deshalb wird in den Beispielen dieses Buches weiterhin die Version 1.0 angegeben. Die XML-Version 1.1 können Sie angeben, wenn die von Ihnen verwendete Anwendung diese Version unterstützt. Beispiel: kap03\\start.xml Im folgenden Beispiel erstellen Sie ein XML-Dokument und zeigen es in einem Browser an. Öffnen Sie einen Texteditor. Geben Sie den nachfolgenden XML-Code ein.   <?xml version=\"1.0\"?> <GRUSS>Hallo Welt!</GRUSS>  Diese Zeile kennzeichnet das Dokument als XML-Dokument.  Ähnlich wie in HTML wird das öffnende Tag GRUSS in spitzen Klammern angegeben. Zwischen dem öff- nenden und schließenden Tag befinden sich die zu verarbeitenden Informationen. Speichern Sie den XML-Code unter dem Dateinamen start.xml. Starten Sie den Browser Internet Explorer oder Mozilla Firefox. Laden Sie die soeben gespeicherte Datei start.xml in den Browser. Hochschulversion Aufbau eines XML-Dokuments 3 © HERDT-Verlag 15 „start.xml“ im Internet Explorer „start.xml“ im Mozilla Firefox Der Quelltext des XML-Dokuments wird in beiden Browsern angezeigt. Die Elemente und die Daten werden farblich voneinander getrennt dargestellt. Zusätzlich zeigt der Internet Explorer auch die Verarbeitungs- vorschrift <?xml version=\"1.0\"?> an. Jede XML-Auszeichnung muss in spitze Klammern gesetzt werden. Falsch Richtig ?xml version=\"1.0\"? <?xml version=\"1.0\"?> Alle angegebenen Elemente müssen ein Anfangs- und Ende-Tag besitzen. Falsch Richtig <ELEMENT1>Inhalt <ELEMENT1>Inhalt</ELEMENT1> Die Bezeichnung des jeweiligen Elements ist an keine vorgegebene Richtlinie gebunden. Die Groß- und Kleinschreibung von XML-Elementen ist von Bedeutung, da XML case-sensitive ist, d. h zwischen der Groß- und Kleinschreibung von Elementnamen unterscheidet. Schreiben Sie das Start-Tag groß, müssen Sie das schließende Ende-Tag ebenfalls großschreiben. Wenn Sie das Start-Tag kleinschreiben, müssen Sie auch das Ende-Tag kleinschreiben. Entscheiden Sie sich für eine einheitliche Schreibweise. Falsch Richtig <img src=\"bild.jpg\">Bild</IMG> <IMG src=\"bild.jpg\">Bild</IMG> Den Namen eines Elements können Sie in XML selbst bestimmen. Er darf aus folgenden Zeichen bestehen: Buchstaben (auf Namen, die mit \"xml\" beginnen, ist zu verzichten) Ziffern, Unterstrich Umlaute und Sonderzeichen (je nach vereinbartem Zeichensatz) Diese Zeichen können Sie beliebig miteinander kombinieren. Ein Elementname beginnt mit einem Buch- staben oder einem Unterstrich. Danach sind Buchstaben (je nach Zeichensatz auch Umlaute), Ziffern, Punkte, Unterstriche und Bindestriche zulässig. Doppelpunkte dürfen nur im Zusammenhang mit Namensräumen verwendet werden. Leerzeichen und Fragezeichen sind nicht zulässig. Reservierte Zeichen Einige Zeichen dürfen nicht im Text oder Elementnamen verwendet werden, weil sie zur Abgrenzung von Element und Inhalt sowie Attribut und Wert verwendet werden. Dies bedeutet, die Zeichen , , , und dürfen nicht im Inhalt verwendet werden, da sie ein Teil der Auszeichnungssprache sind. Deshalb müssen sie als Entities angegeben werden. Zeichen Entity Erklärung &lt; lower than (kleiner als) &gt; greater than (größer als) &quot; quotation (Anführungszeichen) &apos; apostrophe (Apostroph) &amp; ampersand (kaufmännisches Und) Hochschulversion 3 XML 1.1 - Grundlagen 16 © HERDT-Verlag CDATA-Blöcke CDATA steht für Character Data. Als CDATA gekennzeichnete Blöcke werden nicht durch den XML-Parser überprüft. Teile eines XML-Dokuments, die reservierte Zeichen benötigen, können in einem CDATA-Block eingeschlossen werden und werden deshalb nicht überprüft. Die mehrfache und aufwendige Verwendung von Entities erübrigt sich damit. <![CDATA[ Hier können reservierte Zeichen verwendet werden ]]> Ein CDATA-Block beginnt mit der Zeichenkette <![CDATA[ . Ein CDATA-Block endet mit der Zeichenkette ]]> . Alle im Block enthaltenen Zeichen werden nicht vom XML-Parser als reservierte Zeichen gewertet. Die Zeichenkette zur Kennzeichnung des Endes des CDATA-Blockes darf selbst nicht innerhalb des Blockes vorkommen. 3.2 Prolog als Definition eines XML-Dokuments Angabe der XML-Version Jedes XML-Dokument wird mit der Processing Instruction (Verarbeitungsvorschrift) <?xml ...?> eingeleitet. Diese teilt dem Browser bzw. XML-Prozessor mit, dass es sich im Nachfolgenden um ein Doku- ment mit XML-Daten handelt. Zusätzlich wird die Versionsnummer der verwendeten XML-Syntax angegeben. <?xml version=\"1.0\"?> Eine Processing Instruction, kurz PI, beginnt mit <? und endet mit ?> und beinhaltet eine spezielle Anweisung für den Prozessor. Angabe des Zeichensatzes XML-Dokumente sind Textdaten. Deshalb muss angegeben werden, welcher Zeichensatz in einem Dokument angewendet werden kann und wie die Zeichen in Byte-Form kodiert werden sollen. Fehlt die Angabe des Zeichensatzes, wird als Standard UTF-8 verwendet. In Abhängigkeit von der eingestellten Speicherform des Editors kann eine fehlende Angabe zu Problemen führen. Ändern Sie das bisherige Beispiel, um die deutschen Umlaute in das Dokument einzufügen. Beispiel: kap04\\encoding-start.xml <?xml version=\"1.0\"?> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> Öffnen Sie diese Datei in einem Browser. Verwenden Sie den Windows Editor mit seiner Speichervoreinstellung (ANSI), führt dies zu folgender Ansicht: Leere Ausgabe im Internet Explorer Konkreter Fehlerhinweis im Mozilla Firefox Hochschulversion Aufbau eines XML-Dokuments 3 © HERDT-Verlag 17 Im Gegensatz zu früher gibt der Internet Explorer keine Fehlermeldung aus, wenn ein ungültiges Zeichen im Text gefunden wurde. Die Anzeige bleibt leer. Ungültig sind in diesem Fall der Umlaut sowie das Zeichen . Diese Zeichen kommen nicht in jedem Zeichensatz vor, da sie spezielle Zeichen der deutschen Sprache sind. Es wurde eine Zeichensatzfamilie entwickelt, welche die verschiedenen Sprachen auch im Internet unter- stützt. Diese Familie besteht aus verschiedenen Zeichensätzen, die eine Kombination der ersten 128 Zeichen des ASCII-Zeichensatzes und des sprachspezifischen Latin-Zeichensatzes darstellen. ASCII-Zeichensatz 128 Zeichen Code 0 bis 127 Latin-Zeichensatz 128 Zeichen Code 128 bis 255 Das hat den Vorteil, dass die üblichen lateinischen Groß- und Kleinbuchstaben, die arabischen Ziffern und die Sonderzeichen, wie Satzzeichen oder kaufmännische Zeichen, in all diesen Zeichensätzen immer zur Verfü- gung stehen. Wichtige Latin-Zeichensätze Zeichensatz für Latin 1, ISO 8859-1 die westeuropäischen und amerikanischen Sprachen Deutsch, Amerikanisch, Eng- lisch, Französisch Latin 2, ISO 8859-2 die slawischen Sprachen Polnisch, Rumänisch, Slowakisch Latin 3, ISO 8859-3 die Sprachen Esperanto, Galizisch, Maltesisch und teilweise Türkisch Latin 4, ISO 8859-4 bis ISO 8859-8 die Sprachen Estnisch, Lettisch und Litauisch. Dieser Zeichensatz enthält noch wei- tere Unterteilungen für die Sprachen Bulgarisch, Russisch, Ukrainisch, Serbisch, Mazedonisch usw. Latin 5, ISO 8859-9 die Sprache Türkisch Latin 6, ISO 8859-10 die Sprachen Lappländisch und Grönländisch Latin 9, ISO 8859-15 Überarbeitung der ISO 8859-1; beinhaltet u. a. auch das Euro-Symbol € Zusätzlich zur ISO-Norm 8859 steht auch die ISO/IEC-Norm 10646 zur Verfügung. Diese beinhaltet die Unicode-Formate UTF-8 und UTF-16, die jeder XML-Prozessor lesen und umsetzen kann. Im XML-Dokument geben Sie in der Processing Instruction den zu verwendenden Zeichensatz über das Schlüsselwort encoding an. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> Sie werden überwiegend den Zeichensatz ISO 8859-1 benutzen. Dieser enthält beispielsweise die für die deutsche Sprache typischen Umlaute , , sowie das . Beispiel: kap03\\encoding.xml Fügen Sie das Schlüsselwort encoding mit dem westeuropäischen Zeichensatz ISO-8859-1 ein. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> Ausgabe im Internet Explorer Ausgabe im Mozilla Firefox Ü ß Ä Ö Ü ß Hochschulversion 3 XML 1.1 - Grundlagen 18 © HERDT-Verlag 3.3 Anlegen von XML-Elementen Die Elemente eines XML-Dokuments beschreiben die Struktur eines Dokuments. Sie sind nicht für die Aus- gabe am Bildschirm zuständig. oberstes Element Unterelement Unterelement Unterelement Unterelement Unterelement Unterelement Unterelement Unterelement Unterelement Unterelement Unterelement Baumstruktur eines XML-Dokuments Das oberste Element verzweigt sich in weitere Unterelemente. Diese können sich wiederum in mehrere Unterelemente unterteilen. Da diese Aufteilung der Struktur eines Baumes (Stamm, Ast, Zweig, Blatt) ähnelt, wird sie auch als Baumstruktur bezeichnet. Elemente mit einem Inhalt Alle Elemente bestehen aus einem Anfangs- und einem Ende-Tag. Das Anfangs-Tag enthält zwischen den spitzen Klammern den Namen des Elements und die optionalen Attribute. Das Ende-Tag besteht neben den spitzen Klammern aus dem Elementnamen, dem ein Schrägstrich vorangestellt wird. Hat ein Element kei- nen Inhalt, können Anfangs- und Ende-Tag in Kurzschreibweise zusammengefasst werden. Die Elementnamen dürfen Sonderzeichen enthalten, wenn der entsprechende Zeichensatz in der XML- Processing Instruction vereinbart ist. Syntax <xml-element>Inhalt des Elements</xml-element> Beispiel: kap03\\elemente-start.xml In dem bisherigen XML-Beispiel haben Sie bereits ein Element in das Dokument eingefügt. <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> Der angegebene Text wird somit als Inhalt des Elements GRUSS gekennzeichnet und kann im weiteren Ver- lauf über diese Bezeichnung angesprochen und verarbeitet werden. Erweitern Sie das Beispiel um den Namen des Autors. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> <AUTOR>Heiko Schröder</AUTOR> Öffnen Sie die XML-Datei im Internet Explorer oder im Firefox. / Hochschulversion Aufbau eines XML-Dokuments 3 © HERDT-Verlag 19 Fehlerhafte Ausgabe im Internet Explorer Fehlermeldung im Mozilla Firefox Die Browser zeigen jeweils einen Fehler an, da nur ein Element der obersten Ebene zugelassen ist. XML verlangt in der Dokumentstruktur eine eindeutige Kennzeichnung des obersten Hauptelements. Erst dann können weitere Unterelemente eingefügt werden. Im Beispiel befinden sich die Elemente GRUSS und AUTOR in der gleichen Hierarchie. Die Lösung des Problems besteht darin, ein Hauptelement zu benennen, das alle anderen Elemente umschließt. Beispiel: kap03\\elemente.xml    <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <DOKUMENT> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> <AUTOR>Heiko Schröder</AUTOR> </DOKUMENT>  Das Hauptelement mit der Bezeichnung DOKUMENT wird festgelegt.  Die Elemente GRUSS und AUTOR befinden sich innerhalb des Hauptelements DOKUMENT.  Das Hauptelement DOKUMENT wird geschlossen. Übernehmen Sie das Beispiel und öffnen Sie es im Browser. Anzeige im Internet Explorer Anzeige im Mozilla Firefox Weitere Unterelemente hinzufügen Die Grundstruktur eines XML-Dokuments darf nur aus einem Hauptelement bestehen. Darunter können Sie dann mehrere Unterelemente einfügen. Auch diese können weitere Unterelemente enthalten, die wiederum auch Unterelemente enthalten können usw. Es ist sinnvoll, XML-Daten bis zum kleinstmöglichen Element aufzuteilen. Diese Daten können später besser ermittelt und verarbeitet werden. Hochschulversion 3 XML 1.1 - Grundlagen 20 © HERDT-Verlag Die bisherige Struktur des Beispiels soll weiter untergliedert werden. Beispiel: kap03\\subelemente.xml      <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <DOKUMENT> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> <AUTOR> <VORNAME>Heiko</VORNAME> <NACHNAME>Schröder</NACHNAME> </AUTOR> </DOKUMENT>  Das Element DOKUMENT ist das Hauptelement und umschließt alle weiteren Unterelemente.  Die bisherige Angabe des Autors wird weiter untergliedert. Die nachfolgenden Elemente sollen den Autor näher spezifizieren.  Der Vorname des Autors wird als Unterelement des Elements AUTOR definiert.  Der Nachname des Autors wird angegeben.  Das Element AUTOR wird mit dem Ende-Tag </AUTOR> abgeschlossen. Achten Sie darauf, dass das schließende Tag des jeweiligen Elements entsprechend der Hierarchie gesetzt wird. Dies bedeutet, Sie dürfen die einzelnen Elemente nicht ineinander verschachteln, sondern müssen die jeweilige Elementstruktur beachten. Folgende Angabe wäre beispielsweise fehlerhaft: <AUTOR> <VORNAME> <NACHNAME> </VORNAME> </NACHNAME> </AUTOR>       Richtig hingegen ist folgende Reihenfolge: <AUTOR> <VORNAME> </VORNAME> <NACHNAME> </NACHNAME> </AUTOR>       Elemente ohne Inhalt In HTML enthalten einige Elemente keinen Inhalt, beispielsweise das Tag img oder das Element br. Auch XML erlaubt die Angabe eines Elements ohne Inhalt. Syntax <xml-element></xml-element> Fügen Sie in Ihr Beispiel ein leeres Element ein und öffnen Sie die Datei in Ihrem Browser. Beispiel: kap03\\ohneinhalt.xml <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <DOKUMENT> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> <AUTOR> <VORNAME>Heiko</VORNAME> <NACHNAME>Schröder</NACHNAME> DOKUMENT GRUSS AUTOR VORNAME NACHNAME DOKUMENT GRUSS AUTOR Hochschulversion Aufbau eines XML-Dokuments 3 © HERDT-Verlag 21  <FOTO></FOTO> </AUTOR> </DOKUMENT> Element-Kurzform im Internet Explorer Element-Kurzform im Mozilla Firefox Die Browser laden die XML-Datei, ohne eine Fehlermeldung auszugeben. Sie stellen die Elemente jedoch anders dar als bisher gewohnt . Sie fügen die beiden angegebenen Tags zu einem Element in Kurzform zusammen. Diese Darstellung ist völlig korrekt, da in der XML-Syntax die Angabe eines leeren Elements in Kurzform möglich ist. Die Browser optimieren die Ausgabe eines Elements ohne Inhalt automatisch. Syntax <xml-element /> Sie können die Kurzschreibweise für ein leeres Element verwenden. Dabei wird vor das Zeichen ein Schrägstrich geschrieben. Zusätzlich können Sie vor dem Schrägstrich ein Leerzeichen einfügen. Im Gegensatz zu XHTML ist das Leerzeichen in XML nicht zwingend erforderlich. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <DOKUMENT> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> <AUTOR> <VORNAME>Heiko</VORNAME> <NACHNAME>Schröder</NACHNAME> <FOTO /> </AUTOR> </DOKUMENT> 3.4 Attribute eines Elements Mit einem Attribut haben Sie die Möglichkeit, ein Element genauer zu spezifizieren oder bestimmte Wert- vorgaben zuzuweisen. In HTML können Sie beispielsweise einen Absatz über die Angabe von <p align=\"center\"> zentriert ausrichten. Sie sollten dabei beachten, dass Attribute innerhalb des Elements nur einmal angegeben werden können, Unterelemente hingegen beliebig oft. Die Angabe der Reihenfolge der Attribute eines Elements ist nicht fest fixiert und kann flexibel gehandhabt werden. Attribute werden z. B. eingesetzt, wenn bestimmte Werte vorgegeben werden sollen und keine eigenen Werte angegeben werden dürfen. Syntax <xml-element AttributName1=\"Wert1\" AttributName2=\"Wert2\">Inhalt</xml-element> Die Anzahl der festgelegten Attribute ist theoretisch unbegrenzt, jedoch darf ein bestimmtes Attribut inner- halb eines Elements nur einmal verwendet werden. Die Werte werden in einfachen oder doppelten Anfüh- rungszeichen angegeben. > /   Hochschulversion 3 XML 1.1 - Grundlagen 22 © HERDT-Verlag Beispiel: kap03\\attribute.xml Dem XML-Element FOTO werden verschiedene Attribute zugeordnet.   <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <DOKUMENT> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> <AUTOR> <VORNAME>Heiko</VORNAME> <NACHNAME>Schröder</NACHNAME> <FOTO quelle=\"bild.jpg\" /> <FOTO quelle=\"bild.jpg\" hoehe=\"200\" breite=\"100\" /> </AUTOR> </DOKUMENT>  Das Element FOTO besitzt ein Attribut, mit dem der Name der Grafikdatei bestimmt wird.  Das Element FOTO besitzt drei verschiedene Attribute, das Attribut quelle zur Angabe der Grafikdatei sowie die Attribute hoehe und breite, mit denen die Höhe und die Breite der Grafik festgelegt werden. Attributnamen Die Attribute können Sie selbst definieren – wie die Elementnamen. Welche Attribute angegeben werden müssen und welchen Wert ein Attribut besitzen darf, legen Sie in der Dokumenttyp-Definition (DTD) bzw. dem XML-Schema fest, auf die in den nächsten Kapiteln näher eingegangen wird. Neben den selbst zu definierenden Attributnamen sind in der XML-Spezifikation zwei Attribute festgelegt, welche für jedes Element genutzt werden können: xml:lang kennzeichnet die verwendete Sprache des Inhaltes eines Elements xml:space bestimmt den Umgang mit Leerraum im Element Als Werte zur Festlegung der Sprache werden die in der ISO-Norm ISO 639 festgelegten zwei- bzw. dreistelligen Ländercodes verwendet, beispielsweise <Element xml:lang=\"en\"> .. Inhalt .. </Element> Die Leerraumbehandlung steuert den Umgang des XML-Prozessors mit Leerzeichen, Tabulatoren und Leerzeilen im Inhalt eines Elements. Die Vorgaben werden jedoch nicht von allen Anwendungen vollständig beachtet. Die Wirkung des Attributs ist deshalb unterschiedlich. Mögliche Werte sind: preserve alle Leerräume sollen so, wie im Inhalt vorhanden verarbeitet werden default der Umgang mit den Leeräumen wird der jeweiligen Anwendung überlassen 3.5 Kommentare hinzufügen In XML können Sie, wie in jeder Programmier- und Skriptsprache, Kommentare einfügen, um eigene Notizen im Quelltext zu hinterlegen. Quelltexte sollten Sie immer so kommentieren, dass Sie auch nach längerer Zeit den Quelltext nachvollziehen können und dass der Quelltext auch jederzeit von einer anderen Person verstanden und gepflegt werden kann. Kommentare werden vom verwendeten Programm/Parser/Browser nicht berücksichtigt. <!-- Kommentar --> Einen Kommentar leiten Sie mit der Zeichenkette <!-- ein. Danach folgt die Erläuterung, die in das Dokument eingefügt werden soll. Einen Kommentar schließen Sie mit der Zeichenkette --> ab. Hochschulversion Aufbau eines XML-Dokuments 3 © HERDT-Verlag 23 Beispiel: kap03\\kommentar.xml <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <DOKUMENT> <GRUSS>Ich grüße die Welt mit meinem ersten XML-Dokument.</GRUSS> <AUTOR> <VORNAME>Heiko</VORNAME> <NACHNAME>Schröder</NACHNAME> <!-- Nachfolgend erscheint ein Foto von mir --> <FOTO quelle=\"bild.jpg\" hoehe=\"200\" breite=\"100\" /> </AUTOR> </DOKUMENT> Bei Kommentaren ist zu beachten, dass sie nicht vor der Processing Instruction zur XML-Deklaration stehen dürfen, keine Kommentare innerhalb von Kommentaren erlaubt sind, sie nicht innerhalb von Tags oder Processing Instruction stehen dürfen. 3.6 Wohlgeformtheit eines XML-Dokuments Der Begriff „Wohlgeformtheit“ wird Ihnen in Bezug auf XML des Öfteren begegnen. Ein wohlgeformtes Dokument, im Englischen „well formed document“, bedeutet: Ein XML-Dokument besteht aus dem Prolog und mindestens einem Element. Es gibt nur ein Hauptelement (Wurzelelement oder auch root element). Alle Elemente sind richtig verschachtelt. Sie dürfen sich nicht überlappen. Alle Attributwerte stehen in einfachen oder doppelten Anführungszeichen. Ein Element darf nicht zwei Attribute mit demselben Namen besitzen. Kommentare dürfen nicht direkt in den Elementen eingefügt werden. Reservierte Zeichen wie oder sind in der speziellen Form &lt; bzw. &gt; anzugeben. Die aktuellen Browser testen bei der Anzeige eines Dokuments dessen Wohlgeformtheit. Enthält das Doku- ment Fehler, zeigt Ihnen dies der Browser sofort an. Wird Ihr Dokument also im Browser ohne eine Fehler- meldung angezeigt, haben Sie für den Prozessor des Browsers ein wohlgeformtes XML-Dokument erstellt. 3.7 Ein XML-Dokument erstellen Nachdem Sie die grundlegenden Regeln zum Erstellen eines einfachen XML-Dokuments erlernt haben, sind Sie in der Lage, die folgende Aufgabe in einem XML-Dokument zu strukturieren. Sie besitzen zu Hause beispielsweise eine Reihe von Musik-CDs, Schallplatten und MP3-Dateien. Zur besseren Übersicht Ihrer Musiksammlung können Sie diverse Verwaltungsprogramme nutzen. Durch die Verwaltung der Musikalben über XML können Sie diese Daten flexibel nutzen. Grobstruktur Als Erstes muss das Hauptelement des XML-Dokuments benannt werden. Die Bezeichnung des Elements sollte so gewählt werden, dass sie auch Aufschluss über dessen Inhalt gibt. Beispielsweise könnte der Name des Hauptelements MUSIKSAMMLUNG lauten. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <MUSIKSAMMLUNG> <ALBUM> </ALBUM> </MUSIKSAMMLUNG> Hochschulversion 3 XML 1.1 - Grundlagen 24 © HERDT-Verlag Grobstruktur mit Attribut Da für Musik die verschiedensten Tonträger und -formate existieren (Compact Discs, Schallplatten, MP3- Dateien etc.), sollten diese in der Katalogisierung berücksichtigt werden. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <MUSIKSAMMLUNG> <ALBUM typ=\"CD\"> </ALBUM> <ALBUM typ=\"Vinyl\"> </ALBUM> <ALBUM typ=\"MP3\"> </ALBUM> </MUSIKSAMMLUNG> Feinstruktur Als Nächstes folgt die weitere Unterteilung der verschiedenen Musikmedien. Ein Album lässt sich eindeutig über den Namen des Interpreten und den Titel des Albums identifizieren. Zusätzlich sollen die Lieder des jeweiligen Albums in der XML-Datei gespeichert werden. Demzufolge wird das Element ALBUM erweitert, indem die Unterelemente INTERPRET, TITEL und LIED eingefügt werden. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <MUSIKSAMMLUNG> <ALBUM typ=\"CD\"> <INTERPRET></INTERPRET> <TITEL></TITEL> <LIED></LIED> </ALBUM> <ALBUM typ=\"Vinyl\"> <INTERPRET></INTERPRET> <TITEL></TITEL> <LIED></LIED> </ALBUM> <ALBUM typ=\"MP3\"> <INTERPRET></INTERPRET> <TITEL></TITEL> <LIED></LIED> </ALBUM> </MUSIKSAMMLUNG> Die Struktur für die Verwaltung Ihrer Musiksammlung ist somit abgeschlossen. Die Daten können nun in das XML-Dokument eingefügt werden, in dem sie jeweils in das entsprechende Element eingefügt werden. Beispiel: kap03\\musiksammlung.xml <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <MUSIKSAMMLUNG> <ALBUM typ=\"CD\"> <INTERPRET>Moby</INTERPRET> <TITEL>Play</TITEL> <LIED>Honey</LIED> <LIED>Find my baby</LIED> <LIED>Porcelain</LIED> <LIED>Why does my heart feel so bad?</LIED> <LIED>South side</LIED> <LIED>Rushing</LIED> <LIED>Bodyrock</LIED> <LIED>Natural Blues</LIED> <LIED>Machete</LIED> Hochschulversion Aufbau eines XML-Dokuments 3 © HERDT-Verlag 25 <LIED>...</LIED> </ALBUM> <ALBUM typ=\"Vinyl\"> <INTERPRET>a-ha</INTERPRET> <TITEL>Minor earth major sky</TITEL> <LIED>Minor earth major sky</LIED> <LIED>Little black</LIED> <LIED>...</LIED> </ALBUM> <ALBUM typ=\"MP3\"> <INTERPRET>Mesh</INTERPRET> <TITEL>Fragmente</TITEL> <LIED>Trust you</LIED> <LIED>My defender</LIED> <LIED>...</LIED> </ALBUM> </MUSIKSAMMLUNG> Möchten Sie die XML-Struktur noch weiter verfeinern, fügen Sie der Hierarchie entsprechend in den beste- henden Elementen weitere Unterelemente ein. Beispielsweise könnten Sie spezielle Informationen zum Herausgeber, zum Erscheinungsjahr, zur Gesamtspielzeit, zur Spielzeit eines Titels und eigene Anmerkungen hinterlegen. Beispiel: kap03\\musiksammlung_erw.xml <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <MUSIKSAMMLUNG> <ALBUM typ=\"CD\"> <INTERPRET>Moby</INTERPRET> <TITEL>Play</TITEL> <GESAMTZEIT>63:03</GESAMTZEIT> <LABEL>Mute Records Limited</LABEL> <JAHR>1999</JAHR> <LIED> <LIEDTITEL>Honey</LIEDTITEL> <TITELZEIT>3:28</TITELZEIT> </LIED> <LIED> <LIEDTITEL>Find my baby</LIEDTITEL> <TITELZEIT>3:59</TITELZEIT> </LIED> <LIED> <LIEDTITEL>Porcelain</LIEDTITEL> <TITELZEIT>4:01</TITELZEIT> </LIED> <LIED>...</LIED> </ALBUM> </MUSIKSAMMLUNG> 3.8 XML-Editor Editix Mittlerweile gibt es, wie für jede Sprache, auch Programme, die Sie bei der Erstellung von XML-Dokumenten unterstützen. Ein für nicht kommerzielle Zwecke kostenlos verwendbares Programm zum Erfassen von XML- Elementen ist Editix 2008. Herunterladen können Sie dieses englischsprachige Programm über die Web- adresse http://free.editix.com. Neben der freien gibt es eine lizensierte Version, mit einem erweiterten Funktionsumfang. Hochschulversion 3 XML 1.1 - Grundlagen 26 © HERDT-Verlag Editix ist eine Anwendung, die das Erstellen eines XML-Dokuments visuell unterstützt. Es erlaubt Ihnen die Eingabe von Daten für den Aufbau einer XML-Struktur. Das Programm verwaltet die Standardelemente eines XML-Dokuments, wie Elemente und Attribute sowie die notwendigen Daten. Eine visuelle Unterstützung während der Dateneingabe bietet die farbige Hervorhebung von Elementen, Attributen und Werten. Ebenso kann die Baumansicht eingeblendet werden, die Ihnen die XML-Struktur mit allen Elementen übersichtlich anzeigt. Zusätzlich erhalten Sie Informationen über den korrekten Aufbau (Wohlgeformtheit).  In dieser Baumansicht werden die einzelnen Elemente des Dokuments übersichtlich dargestellt. Bei der Auswahl eines Elements werden darunter die Attribute aufgelistet.  Die Eingabe der XML-Elemente und Daten erfolgt in diesem Bereich. Die Syntax wird farblich hervorgehoben, dies verhilft zu einer besseren Übersicht.  Treten während der Eingabe Fehler auf, werden entsprechende Meldungen in der Statusleiste angezeigt.  Eventuell auftretende Fehler beim Validieren des XML-Dokuments werden hier aufgelistet. Mit einem Doppelklick kann sofort zu dem fehlerhaften Element gesprungen werden. Zur näheren Erläuterung der Bedienung des Programms lesen Sie die englischsprachige Windows-Hilfe, die dem Programm beigefügt ist. 3.9 Schnellübersicht Ein wohlgeformtes XML-Dokument beinhaltet ... einen Prolog mit der Angabe der Version und des verwendeten Zeichensatzes genau ein Hauptelement Außerdem gilt: Alle angegebenen Elemente müssen ein Anfangs- und Ende-Tag besitzen, auch wenn es sich um ein leeres Element handelt. Das schließende Tag des Elements muss entsprechend der Hierarchie gesetzt werden. Der Name des Elements ist frei wählbar. Die Groß- und Kleinschreibung der Elemente ist zu beachten. Jedes einzelne Element kann weitere Unterelemente enthalten. Die Elementnamen dürfen auch Sonderzeichen enthalten, wenn der entsprechende Zeichensatz ver- einbart ist. Angegebene Attributwerte müssen immer in Anführungszeichen gesetzt werden.     Hochschulversion Aufbau eines XML-Dokuments 3 © HERDT-Verlag 27 3.10 Übungen Übung 1: Theoriefragen zum Aufbau eines XML-Dokuments Übungsdatei: -- Ergebnisdatei: kap03\\uebung1-2.html  Beschreiben Sie, wie das Gerüst eines XML-Dokuments aufgebaut ist und welche Angaben für die Wohlgeformtheit notwendig sind.  Erklären Sie, was unter Attributen zu verstehen ist und wie viele Attribute pro Element ver- wendet werden können. Übung 2: Strukturieren von Informationen Übungsdatei: -- Ergebnisdateien: kap03\\uebung3.html, kap03\\uebung3.xml  Sie absolvieren ein XML-Seminar mit mehreren Teilnehmern. Geben Sie die nachfolgenden Informationen in einer XML-Struktur an. Beachten Sie dabei, welche Informationen einmalig sind und welche mehrmals vorkommen. Ziel des Seminars: Einführung in XML Datum: 02.04. - 06.04. in XML-Stadt Zeitplan: ab 09:00 Uhr Themen: Überblick XHTML XML-Struktur ab 13:00 Uhr Themen: DTD entwickeln Darstellung von XML mit XSL 17:00 Uhr - Ende Personen: Seminarleiter Herr Hans Hauser Teilnehmer Herr Rolf Rabicht Frau Sigrun Sieghaar Frau Linda Landmann Herr Bruno Brahms Übung 3: XML-Struktur entwickeln Übungsdatei: -- Ergebnisdatei: kap03\\uebung4.xml  Entwickeln Sie eine XML-Struktur, mit der Sie die technischen Details von Kraftfahrzeugen verwalten können. Folgende Informationen sollen integriert werden: BMW Mercedes Audi Modell BMW Z8 SLK 32 AMG 1.8 T quattro Leergewicht 1690 kg 1495 kg 1395 kg Zylinder 8 6 4 Hubraum 4941 cm³ 3199 cm³ 1781 cm³ Leistung 294 kW 260 kW 165 kW Höchstgeschwindigkeit 250 km/h 250 km/h 243 km/h von 0 auf 100 km/h 4,7 s 5,2 s 6,4 s Hochschulversion 4 XML 1.1 - Grundlagen 28 © HERDT-Verlag 4 Elemente der DTD In diesem Kapitel erfahren Sie wie Sie die Elemente und Inhalte der XML-Daten festlegen wie eine Dokumenttyp-Definition aufgebaut ist was unter einem gültigen Dokument zu verstehen ist wozu Parser notwendig sind Voraussetzungen Kenntnisse im Aufbau eines XML-Dokuments 4.1 Dokumenttyp-Definition Definition des Datenmodells einer XML-Datei In einem XML-Dokument ist die Dokumenttyp-Definition kurz DTD ein zentraler Bestandteil. Die Dokumenttyp-Definition ist das Regelwerk, nach dem sich die Dokumente richten müssen. Sie enthält die folgenden Richtlinien: welche Elemente das Dokument enthalten darf, welchen Inhalt die Elemente haben dürfen, welche Attribute erlaubt sind, welche Werte die Attribute annehmen können, wie die Elemente und in welcher Reihenfolge die Elemente ineinander geschachtelt werden dürfen. Eine Dokumenttyp-Definition selbst ist kein XML-Dokument. Für die Dokumenttyp-Definition wird eine SGML-verwandte Syntax verwendet. Durch die Verwendung einer formalen Sprache zur Beschreibung des Datenmodells einer XML-Datei ist gewährleistet, dass die Beschreibung selbst von Programmen gelesen und ausgewertet werden kann. Damit kann die sogenannte Validierung einer XML-Datei, ihre Überprüfung unter Berücksichtigung des für sie festgelegten Datenmodells, automatisch durch Programme erfolgen. In Anlehnung an die objektorientierte Programmierung wird im Verhältnis von DTD und XML-Datei auch die Begrifflichkeit der DTD als Definition einer Klasse von Dokumenten und den einzelnen XML-Dateien als Dokumentinstanzen verwendet. Anstelle einer DTD kann auch ein XML-Schema zur Definition des Datenmodells einer XML-Datei verwendet werden (vgl. Kapitel 7 und 8). Angabe der DTD in HTML HTML benötigt zur Validierung eines HTML-Dokuments und zur Spezifikation der möglichen Elemente und Attribute eine DTD. Deren Einbindung ist für ein HTML-Dokument jedoch nicht zwingend notwendig, da die Browser diese Definition bereits kennen und intern umsetzen können. Folgendermaßen können Sie im HTML-Code angeben, welche HTML-Version Ihr Dokument unterstützt. <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\"> Hochschulversion Elemente der DTD 4 © HERDT-Verlag 29 Diese Zeile verweist auf eine Dokumenttyp-Definition für den HTML-Standard 4.0. Die Anweisung DOCTYPE HTML PUBLIC bedeutet, dass sich der Inhalt einer Webseite auf die öffentlich verfügbare HTML-DTD be- zieht. Die Angaben zwischen den Anführungszeichen geben Auskunft über den Herausgeber der DTD, das W3-Konsortium, den SGML-Dokumenttyp HTML in der Sprachversion 4.0 sowie die Sprache, in der die Elemente definiert wurden. Ab HTML5 ist auch die entsprechende Kurzangabe möglich: <!DOCTYPE html\"> 4.2 Definition einer internen DTD Eine DTD wird innerhalb eines XML-Dokuments über die Syntax <!DOCTYPE name [ <!-- Element-Definitionen --> ]> direkt nach der Versionsangabe im XML-Prolog <?xml version=\"1.0\"?> und vor dem eigentlichen Beginn des XML-Elements definiert. Eingeleitet wird die DTD mit dem Schlüsselwort <!DOCTYPE ...>. Die Bezeich- nung name ist hierbei eine eindeutige Bezeichnung für die nachfolgende Dokumenttyp-Definition. Innerhalb der eckigen Klammern werden die möglichen Elemente definiert, die im XML-Dokument vorkommen dürfen. Die Norm erwartet bei der Namensangabe den Namen des obersten Elements. Daher muss der Name der DTD so benannt werden wie das Hauptelement der XML-Datei. Beispiel: kap04\\doctype.xml     <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <!DOCTYPE MUSIKSAMMLUNG [ <!-- Definitionen der einzelnen Elemente --> ]> <MUSIKSAMMLUNG> <!-- Die einzelnen Elemente mit den Daten. --> </MUSIKSAMMLUNG>  Das Dokument beginnt mit der Versionsangabe im XML-Prolog.  Die Dokumenttyp-Definition mit dem Namen MUSIKSAMMLUNG wird eingeleitet.  Die DTD wird geschlossen und beendet.  Es beginnt das Hauptelement der XML-Datei mit den verschiedenen Unterelementen. Verwenden Sie eine interne Dokumenttyp-Definition, sollten Sie die einleitende Verarbeitungsvorschrift <?xml ...?> um das Schlüsselwort standalone erweitern. Diese Option kennzeichnet, ob der Parser eine externe DTD einlesen muss oder ob die DTD innerhalb des XML-Dokuments definiert ist. <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> Die Angabe von standalone=\"yes\" teilt dem Parser mit, dass die Dokumenttyp-Definition innerhalb des ge- ladenen XML-Dokuments zu finden ist. Das XML-Dokument benötigt keine weiteren externen Dateien. Die automatische Vorgabe standalone=\"no\" teilt dem XML-Prozessor mit, dass noch weitere externe Dateien einzubinden sind. Hochschulversion 4 XML 1.1 - Grundlagen 30 © HERDT-Verlag 4.3 Deklarieren der Elementtypen Elementtyp-Deklarationen legen die Namen der Unterelemente fest, die innerhalb der übergeordneten Elemente möglich sind. Es wird angegeben, von welcher Art ihre Inhalte sind und welche Attribute verwendet werden dürfen. Die Elementtyp-Deklaration legt folgende Regeln innerhalb einer Dokumenttyp-Definition fest: die Syntax eines Elements, ob bestimmte Elemente mehrfach vorkommen dürfen, den Typ eines Elements, die Reihenfolge der Elemente in dem XML-Dokument. Zu beachten ist dabei Folgendes: Ein Element muss eindeutig definiert sein. Elementnamen sind „case-sensitive“, sodass auf Groß- und Kleinschreibung zu achten ist. Das zur Elementtyp-Deklaration notwendige Schlüsselwort ELEMENT muss immer in Großbuchstaben geschrieben werden. 4.4 Angabe der Elemente Zur näheren Erläuterung wird die bereits erstellte Musiksammlung als Beispiel verwendet und das zusätzliche Element AUTOR eingefügt. In diesem Element soll der Name der Person gespeichert werden, die den Daten- satz hinzugefügt hat. <MUSIKSAMMLUNG> <ALBUM> <AUTOR></AUTOR> <INTERPRET></INTERPRET> <TITEL></TITEL> <LIED></LIED> </ALBUM> </MUSIKSAMMLUNG> Elementgruppen Eine Elementgruppe ist ein XML-Element mit weiteren Unterelementen und wird in der Dokumenttyp-Defini- tion mithilfe des Schlüsselworts <!ELEMENT name (Unterelemente)> angegeben. Das Schlüsselwort <!ELEMENT leitet die Festlegung für ein Element mit der Bezeichnung name ein. Innerhalb der nachfolgenden Klammern werden die weiteren Unterelemente angegeben, die sich inner- halb des Elements name befinden dürfen. <!ELEMENT MUSIKSAMMLUNG (ALBUM)> Das erste Element in dem Beispiel ist das Hauptelement MUSIKSAMMLUNG. Dieses enthält ein weiteres Element mit der Bezeichnung ALBUM. Die obige Definition besagt daher, dass sich in dem Element MUSIKSAMMLUNG nur das Unterelement ALBUM befinden darf. Innerhalb des Elements <ALBUM> befinden sich weitere Unterelemente, die Sie ebenfalls definieren müssen. Folgende Möglichkeiten der Verknüpfung der einzelnen Elemente stehen Ihnen dabei zur Verfügung: Hochschulversion Elemente der DTD 4 © HERDT-Verlag 31 Operator Bedeutung Die Unterelemente werden generell in Klammern geschrieben. Mehrere Unterelemente werden mit einem Komma (Sequenz-Operator) voneinander getrennt und geben die Reihenfolge der anzugebenden Elemente an. Der senkrechte Strich ist der Oder-Operator. Sie können eines der angegebenen Unter- elemente wählen. #PCDATA Der Inhalt des Elements kann aus einer beliebigen Zeichenkette bestehen. Im nachfolgenden Beispiel werden die Elemente AUTOR, INTERPRET, TITEL und LIED als Unterelemente des Elements ALBUM mit dem Sequenz-Operator verknüpft. Damit ist festgelegt, in welcher Reihenfolge die Elemente anzugeben sind. <!ELEMENT MUSIKSAMMLUNG (ALBUM)> <!ELEMENT ALBUM (AUTOR, INTERPRET, TITEL, LIED)> Da der Interpret eines Albums sehr allgemein gehalten ist, könnten Sie statt des Elements INTERPRET auch angeben, ob es sich um eine Gruppe handelt. Dazu verknüpfen Sie die möglichen Elementnamen über den Oder-Operator und setzen diese in Klammern. <!ELEMENT MUSIKSAMMLUNG (ALBUM)> <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE), TITEL, LIED)> Durch diese Definition müssen die Elemente AUTOR, TITEL, LIED im Element ALBUM in dieser Reihenfolge angegeben werden. Aus der Gruppe (INTERPRET | GRUPPE) können Sie ein beliebiges Element wählen. Einzelne Elemente Ein einzelnes Element, das keine weiteren Unterelemente enthält, wird mit der Definition <!ELEMENT name (#PCDATA)> angegeben. Durch die Angabe von #PCDATA wird der Datentyp des Elements festgelegt, der besagt, dass der Inhalt aus beliebigen Zeichenketten bestehen darf. Jedes als Unterelement festgelegte Element und jedes Element, das über einen Oder-Operator verknüpft ist, muss in der Dokumenttyp-Definition als Einzelelement definiert werden. Die Definition der restlichen Elemente der Musiksammlung erfolgt auf die folgende Art und Weise:   <!ELEMENT MUSIKSAMMLUNG (ALBUM)> <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE), TITEL, LIED)> <!-- Es folgen die Unterelemente von ALBUM --> <!ELEMENT AUTOR (#PCDATA)> <!ELEMENT INTERPRET (#PCDATA)> <!ELEMENT GRUPPE (#PCDATA)> <!ELEMENT TITEL (#PCDATA)> <!ELEMENT LIED (#PCDATA)>  Das Element ALBUM umschließt die Unterelemente AUTOR, TITEL, LIED und eines von INTERPRET oder GRUPPE.  Jedes Element muss definiert werden und enthält die Daten einer beliebigen Zeichenfolge. Dies wird über die Angabe von #PCDATA kenntlich gemacht. Hochschulversion 4 XML 1.1 - Grundlagen 32 © HERDT-Verlag Genereller Aufbau einer DTD Struktur des XML-Dokuments Struktur der Dokumenttyp-Definition <HAUPTELEMENT> </HAUPTELEMENT> <UNTERELEMENT> </UNTERELEMENT> <ELEMENT1>...</ELEMENT1> <ELEMENT2>...</ELEMENT2> <ELEMENT3>...</ELEMENT3> <!DOCTYPE HAUPTELEMENT [ <!ELEMENT HAUPTELEMENT (UNTERELEMENT)> <!ELEMENT UNTERELEMENT (ELEMENT1, ELEMENT2, ELEMENT3)> <!ELEMENT ELEMENT1 (#PCDATA)> <!ELEMENT ELEMENT2 (#PCDATA)> <!ELEMENT ELEMENT3 (#PCDATA)> ]> Inhalt eines Elements Die bisherige Definition erzwingt für ein Element auch die Angabe aller anderen Unterelemente. Dies be- deutet, dass Sie für jeden Interpreten den Titel des Albums angeben müssen, aber nur ein Lied benennen dürfen. Jedoch besteht ein Musikalbum nicht nur aus einem Lied, sondern aus mehreren Liedern. Ebenso könnte es sein, dass Sie kein Lied eines Albums mit Namen kennen und dies deshalb erst später nachtragen möchten. Für die Daten eines Albums gelten in der Musiksammlung die folgenden Regeln: Ein Album ist von mindestens einem Interpreten. Das Album besitzt einen Titel. Zu einem Album gehört eine vorher nicht bekannte Anzahl von Liedern, d. h. eine beliebige Anzahl. Ob ein Element einen Inhalt besitzen muss oder ob es mehrmals innerhalb des übergeordneten Elements vor- kommen kann, bestimmen Sie mithilfe der nachfolgenden Zeichen zur Angabe der Häufigkeit. Zeichen Bedeutung 0 oder 1 Wird ein Fragezeichen hinter einer Elementbezeichnung oder einem Klammerausdruck ange- geben, darf das Element weggelassen oder nur einmal angegeben werden. beliebig oft, auch 0-mal Eine mit einem Stern gekennzeichnete Elementbezeichnung erlaubt eine beliebige Anzahl der Verwendung des Elements. Es darf auch weggelassen werden. beliebig oft, aber mindestens einmal Sie können beliebig viele Elemente einfügen. Jedoch darf dieses Element nicht weggelassen werden. einmal Geben Sie kein Zeichen an, muss das Element genau einmal innerhalb des übergeordneten Elements verwendet werden. Beispiel: kap04\\musiksammlung-element.xml Anhand eines Beispiels soll Ihnen der Einsatz dieser Zeichen nähergebracht werden. Dazu wird die Musik- sammlung erweitert, sodass Sie beispielsweise beliebig viele Alben verwalten und für jedes Album beliebig viele Lieder (auch 0) angeben können. ? * + Hochschulversion Elemente der DTD 4 © HERDT-Verlag 33      <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <!DOCTYPE MUSIKSAMMLUNG [ <!ELEMENT MUSIKSAMMLUNG (ALBUM+)> <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE), TITEL, LIED*)> <!ELEMENT AUTOR (#PCDATA)> <!ELEMENT INTERPRET (#PCDATA)> <!ELEMENT GRUPPE (#PCDATA)> <!ELEMENT TITEL (#PCDATA)> <!ELEMENT LIED (#PCDATA)> ]>  In einer Musiksammlung möchten Sie mehr als nur ein Album speichern. Markieren Sie dazu das Element ALBUM mit dem Zeichen . Damit stellen Sie sicher, dass innerhalb des XML-Dokuments das Element mehrfach vorkommen darf, aber mindestens einmal angegeben werden muss.  Das Element AUTOR muss angegeben werden, um nachzuvollziehen, wer den Datensatz eingegeben hat, und erhält deshalb kein Zeichen zur Angabe der Häufigkeit.  Das Element INTERPRET oder GRUPPE kann innerhalb des übergeordneten Elements ALBUM nur einmal gesetzt werden.  Das Element TITEL muss angegeben werden, um die CD, Schallplatte, MP3-Datei oder Musikkassette eindeutig zu identifizieren.  Da die Anzahl der Lieder auf einem Album nicht von vornherein bekannt ist, wird das Element so fest- gelegt, dass es gar nicht oder beliebig oft angegeben werden darf. Sollen in der Musiksammlung alle Elemente gleich oft vorkommen, müssen Sie nicht jedes einzelne Element mit dem entsprechenden Zeichen versehen. In diesem Fall geben Sie das Zeichen außerhalb der Elemente an.   <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE), TITEL, LIED)*> oder <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE), TITEL, LIED)+>  Die Unterelemente des Hauptelements ALBUM müssen nicht zwingend angegeben werden.  Die Elemente AUTOR, TITEL, LIED und eines der Elemente INTERPRET, GRUPPE müssen mindestens einmal im Dokument erscheinen. Inhaltsmodelle mit EMPTY und ANY Bisher haben Sie Elemente definiert, die als Inhalt eine beliebige Zeichenfolge besitzen können (#PCDATA). Es kann jedoch auch Elemente ohne einen Inhalt geben. Derartige Elemente benötigen kein Ende-Tag und werden auch als „leere Elemente“ bezeichnet. In der Auszeichnungssprache HTML sind dies beispielsweise br für den Zeilenumbruch oder hr für die horizontale Linie. In der DTD eines XML-Dokuments werden die Elemente ohne einen Inhalt mit dem Schlüsselwort EMPTY definiert. <!ELEMENT name EMPTY> Zusätzlich können Sie XML-Elemente mit dem Schlüsselwort ANY deklarieren. <!ELEMENT name ANY> Ein Element mit diesem Inhaltsmodell kann jedes andere Element der DTD beinhalten, auch sich selbst. Es wird jedoch selten angewandt, weil keine Einschränkungen zum Inhalt gemacht werden. Hochschulversion 4 XML 1.1 - Grundlagen 34 © HERDT-Verlag 4.5 Externe Teilmenge der DTD Möchten Sie eine Dokumenttyp-Definition für mehrere XML-Dokumente verwenden, empfiehlt es sich, diese als externe Datei auszulagern. Statt die Definition des Dokumentes immer wieder in allen Dokumenten festzulegen, können Sie eine zentrale Datei anlegen und von jeder einzelnen XML-Datei darauf zugreifen. Diese externe DTD enthält damit die Definitionen für alle XML-Dateien, die darauf zugreifen. Ändern Sie die Definition eines Elements in der externen DTD, wirkt sich diese Ände- rung in allen anderen XML-Dokumenten aus, in denen die DTD eingebunden ist. Vollständige externe Teilmenge Eine externe Dokumenttyp-Definition ist fast identisch mit einer internen Dokumenttyp-Definition. Der Unterschied besteht darin, dass in einer externen Teilmenge der DTD die Angabe der Verarbeitungsvorschrift <!DOCTYPE name [ ]> fehlt. Diese Angabe wird innerhalb des XML-Dokuments eingefügt und darf nicht in die externe Teilmenge geschrieben werden. Das Einbinden einer externen Teilmenge in ein XML-Dokument erfolgt über die modifizierte Verarbeitungs- vorschrift <!DOCTYPE ...>. <!DOCTYPE name SYSTEM \"URI\"> Durch das Schlüsselwort SYSTEM wird der entsprechenden Anwendung mitgeteilt, dass eine externe Doku- menttyp-Definition zu verwenden ist. Der Parameter URI (Uniform Resource Identifier) ist durch den Datei- namen oder die URL der DTD-Datei zu ersetzen und immer in Anführungszeichen anzugeben. Ein Uniform Resource Identifier (URI) ist eine Zeichenkette, die eine Internetressource darstellt. Der meist- verwendete Parameter ist der Uniform Resource Locator (URL), der eine Internetadresse bezeichnet.    <!-- DTD im selben Ordner --> <!DOCTYPE name SYSTEM \"extern.dtd\"> <!-- DTD in einem anderen Ordner --> <!DOCTYPE name SYSTEM \"../dtd/extern.dtd\"> <!-- DTD von einem anderen Server --> <!DOCTYPE name SYSTEM \"http://www.example.com/dtd/extern.dtd\">  Wenn die DTD-Datei im selben Ordner gespeichert ist wie die XML-Datei, genügt die Angabe des Datei- namens.  Befindet sich die DTD in einem anderen Ordner, müssen Sie den Pfad angeben.  Wird auf eine DTD auf einem anderen Server verwiesen, ist die gesamte URL anzugeben. Verwenden Sie eine externe Dokumenttyp-Definition, dann können Sie in den darauf zugreifenden XML- Dokumenten den einleitenden XML-Befehl <?xml …?> um die Angabe standalone=\"no\" erweitern. <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?> Die Angabe von standalone=\"no\" teilt der Anwendung mit, dass für die Dokumenttyp-Definition eine oder mehrere externe Dateien geladen werden müssen. Da dies eine standardmäßige Einstellung ist, muss sie nicht unbedingt angegeben werden. externe DTD <!ENTITY... <!ELEMENT... <!ELEMENT... XML- Dokument <!DOCTYPE... SYSTEM...> XML- Dokument <!DOCTYPE... SYSTEM...> XML- Dokument <!DOCTYPE... SYSTEM...> XML- Dokument <!DOCTYPE... SYSTEM...> Hochschulversion Elemente der DTD 4 © HERDT-Verlag 35 Beispiel: kap04\\extern.dtd Lagern Sie die folgende Dokumenttyp-Definition in eine externe Datei aus und speichern Sie die Datei unter dem Namen extern.dtd. <!ELEMENT MUSIKSAMMLUNG (ALBUM+)> <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE)+, TITEL, LIED*)> <!ELEMENT AUTOR (#PCDATA)> <!ELEMENT INTERPRET (#PCDATA)> <!ELEMENT GRUPPE (#PCDATA)> <!ELEMENT TITEL (#PCDATA)> <!ELEMENT LIED (#PCDATA)> Beispiel: kap04\\musiksammlung-extdtd.xml Ändern Sie die Angabe <!DOCTYPE ...>, sodass die Dokumenttyp-Definition aus der externen Datei extern.dtd geladen wird.    <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?> <!DOCTYPE MUSIKSAMMLUNG SYSTEM \"extern.dtd\"> <MUSIKSAMMLUNG> <ALBUM>...</ALBUM> </MUSIKSAMMLUNG>  Der XML-Prolog wird um die Angabe standalone=\"no\" erweitert, um das verarbeitende Programm zu informieren, dass externe Dokumenttyp-Definitionen geladen werden müssen.  Mit dieser Angabe binden Sie die Datei extern.dtd für die Dokumenttyp-Definition der nachfolgenden Elemente ein.  Ab hier folgen die XML-Elemente. Speichern Sie das XML-Dokument unter dem Namen musiksammlung-extdtd.xml in dem- selben Ordner wie die zuvor extern angelegte Datei extern.dtd. Laden Sie die Datei in das Programm Editix. Wählen Sie das Menü XML - Check for a well-formed / valid document. Alternative: S k Die Software testet das XML-Dokument anhand der vorgegebenen DTD auf Gültigkeit und gibt eine entsprechende Meldung aus. Das XML-Dokument ist gültig Fehler: Ein Element wurde nicht geschlossen Der Sinn von XML ist es, die Struktur einer XML-Datei über eine DTD zu definieren, die für jeden zugänglich und nutzbar sein soll. Dazu wird die DTD jedem anderen Autor auf einem Webserver zur weiteren Nutzung zur Verfügung gestellt. Zum Einbinden einer solchen öffentlich zugänglichen Dokumenttyp-Definition benutzen Sie das Schlüsselwort PUBLIC. <!DOCTYPE name PUBLIC \"Kennung\" \"URI\"> Die Einbindung einer öffentlichen DTD wird um den Parameter Kennung in Form des Formal Public Identifier (FPI) erweitert. Er beinhaltet die Angaben zum Herausgeber, die Angabe des Dokumententyps sowie die Sprache, in der sie verfasst wurde. Hochschulversion 4 XML 1.1 - Grundlagen 36 © HERDT-Verlag Beispielsweise können Sie die öffentlich verfügbaren Dokumenttyp-Definitionen des W3-Konsortiums zur Definition einer XHTML-Struktur benutzen und in das entsprechende Dokument einbinden. <!-- öffentliche XHTML1.1-DTD von W3.org --> <!DOCTYPE HTML PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"> Aufteilung der Kennung - Der Herausgeber ist nicht als Besitzer registriert (ein '+' steht für registrierte Besitzer). W3C Der Herausgeber der Definition ist das W3-Konsortium. DTD XHTML 1.1 Der Dokumententyp ist die Definition der XHTML-1.1-Spezifikation. EN Die Sprache, in der die Definition verfasst wurde, ist Englisch. Erweiterte externe Teilmenge Definitionen von Elementen, Entities oder Attributen einer externen DTD können Sie in XML durch eine interne Definition erweitern. Entities sind Platzhalter für bestimmte festgelegte Inhalte. In HTML erfolgt eine analoge Kombination von externen und internen Daten bei der Einbindung von Cascading Stylesheets und JavaScript-Funktionen. <!DOCTYPE name SYSTEM \"URI\" [interne Definition]> Zum Erweitern der externen DTD geben Sie hinter der Angabe der URI innerhalb der eckigen Klammern die internen Dokumenttyp-Definitionen für Ihr XML-Dokument an. Beispiel: kap04\\musiksammlung.dtd Sie stellen anderen Nutzern Ihre externe DTD für den Aufbau einer Musiksammlung im Internet zur Verfü- gung. <!ELEMENT MUSIKSAMMLUNG (ALBUM+)> <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE)+, TITEL, LIED*)> <!ELEMENT AUTOR (#PCDATA)> <!ELEMENT INTERPRET (#PCDATA)> <!ELEMENT GRUPPE (#PCDATA)> <!ELEMENT TITEL (#PCDATA)> <!ELEMENT LIED (#PCDATA)> Beispiel: kap04\\musiksammlung-entity.xml Da Sie nicht immer im Element <AUTOR> Ihren Namen vollständig angeben möchten, legen Sie ein Namens- kürzel fest, das nur in Ihrem XML-Dokument gültig sein soll.      <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\" ?> <!DOCTYPE MUSIKSAMMLUNG SYSTEM \"musiksammlung.dtd\" [ <!ENTITY mm \"Max Mustermann\"> ]> <MUSIKSAMMLUNG> <ALBUM> <AUTOR>&mm;</AUTOR> <INTERPRET>Moby</INTERPRET> <TITEL>Play</TITEL>  Hochschulversion Elemente der DTD 4 © HERDT-Verlag 37 <LIED>Honey</LIED> <LIED>Find my baby</LIED> <LIED>Porcelain</LIED> <LIED>...</LIED> </ALBUM> </MUSIKSAMMLUNG>  Die Definition in der Datei musiksammlung.dtd wird in das XML-Dokument eingebunden.  Die interne Definition wird eingeleitet.  Mit der Deklaration <!ENTITY ...> legen Sie für Ihren Namen den Platzhalter fest. In diesem Fall wird für den Namen Max Mustermann der Platzhalter mm festgelegt. Nähere Informationen zu Entities folgen im nächsten Kapitel.  Die interne Definition wird abgeschlossen.  Es folgen die eigentlichen XML-Elemente.  Der Inhalt des Elements AUTOR wird mit dem entsprechenden Namen gefüllt. Angegeben wird in diesem Fall der Platzhalter mm, der von den Zeichen und eingeschlossen ist. Das Anwendungsprogramm mit dem XML-Parser erkennt, dass es sich hierbei um einen Entity-Verweis handelt, und verwendet auto- matisch die entsprechende Zeichenfolge Max Mustermann. 4.6 Gültiges Dokument Definition eines gültigen Dokuments In der Definition der Wohlgeformtheit ist festgelegt, dass ein XML-Dokument aus dem Prolog und mindes- tens einem Element bestehen muss. In einem gültigen Dokument, im Englischen „valid document“, müssen zusätzlich die folgenden Kriterien erfüllt sein. Es muss eine interne oder externe Dokumenttyp-Definition enthalten. Das Dokument muss sich an die aufgestellten Regeln der DTD halten. Es dürfen nur die in der DTD definierten Elemente innerhalb des Dokuments benutzt werden. Alle notwendigen Attribute müssen verwendet werden. Die Werte der Attribute müssen gültig sein. Alle Inhalte der Elemente müssen den festgelegten Datentypen entsprechen. Um ein Dokument auf Gültigkeit zu testen, ist je nach verwendetem XML-Editor ein zusätzliches Programm notwendig. Parser Ein XML-Dokument kann nicht direkt von einer Anwendung verarbeitet werden, sondern wird von einem Parser in seine Bestandteile zerlegt. Dabei wird es auf Wohlgeformtheit und Gültigkeit überprüft. Der Parser liest ein Dokument ein und übermittelt an die Anwendung (z. B. einen Browser) die Eigenschaften und die Struktur der Daten. In XML nutzen die verarbeitenden Programme Parser, um die Gültigkeit eines XML- Dokuments zu überprüfen. Erst wenn die Daten keinen Fehler aufweisen, werden sie zur Weiterverarbeitung durch die Anwendung genutzt. Es werden zwei Typen von Parsern unterschieden. Nicht validierende Parser Sie kontrollieren lediglich, ob die XML-Elemente gegen die Wohlgeformtheit des Dokuments verstoßen. Validierende Parser Sie überprüfen die Datenstruktur eines XML-Dokuments auf die Einhaltung der Dokumenttyp- oder Schema-Definitionen. Das Prüfen auf Gültigkeit schließt da- bei automatisch das Prüfen auf die Wohlgeformtheit ein. Hochschulversion 4 XML 1.1 - Grundlagen 38 © HERDT-Verlag Stößt der Parser auf Verstöße gegen die XML-Syntax und die festgelegten Dokumenttyp-Definitionen, wird die Anwendung darüber benachrichtigt. Eine weitere Auswertung der Daten ist nicht sinnvoll, da sich Folge- fehler einstellen können. Die XML-Spezifikation gibt keine Auskunft darüber, auf welche Art eine XML-Prüfung durchzuführen ist. Es bleibt somit Ihre Entscheidung, welche Parser Sie verwenden und welche Prüfungen stattfinden sollen. Dokument auf Gültigkeit testen Im Programm Editix können Sie die Gültigkeit einer XML-Datei und deren Dokumenttyp-Definition direkt über den Menüpunkt XML - Check for a well-formed / valid document überprüfen lassen. Im Programm XMLSpy erfolgt der Test auf Wohlgeformtheit über den Menüpunkt XML - Wohlgeformtheit prüfen, die Validierung über XML - XML validieren. Das XML-Dokument ist wohlgeformt Eine nicht definierte Abkürzung wurde gefunden 4.7 Schnellübersicht Was bedeutet in der Element-Definition einer DTD ...? Angabe eines oder mehrerer Unterelemente Reihenfolge der Unterelemente Oder-Operator für die Auswahl der Elemente Das Element darf weggelassen oder einmal angegeben werden (0.. 1). Das Element darf weggelassen oder beliebig oft angegeben werden (0.. n). Das Element muss mindestens einmal und kann mehrmals angegeben werden (1.. n). #PCDATA Der Dateninhalt kann aus beliebigen Zeichenketten bestehen. EMPTY Definition eines Elements ohne Inhalt ANY Das Element darf jedes andere Element der DTD enthalten. Sie möchten … eine interne Teilmenge der DTD anlegen <!DOCTYPE name [Element-Definitionen]> eine externe Teilmenge der DTD einbinden <!DOCTYPE name SYSTEM \"URI\"> <!DOCTYPE name PUBLIC \"URI\"> eine interne Definition hinzufügen <!DOCTYPE name SYSTEM \"URI\" [interne DTD]> <!DOCTYPE name PUBLIC \"URI\" [interne DTD]> Elementgruppen deklarieren <!ELEMENT name (Unterelemente)> Elemente definieren <!ELEMENT name (#PCDATA)> <!ELEMENT name (#EMPTY)> Hochschulversion Elemente der DTD 4 © HERDT-Verlag 39 4.8 Übungen Übung 1: Theoretische Fragen Übungsdatei: -- Ergebnisdatei: kap04\\uebung1-3.html  Erklären Sie, wozu Parser notwendig sind und welche Unterschiede es zwischen den zwei Parsertypen gibt.  Erläutern Sie, wann ein Dokument als \"gültiges Dokument\" bezeichnet wird.  Legen Sie die Vorteile einer externen Dokumenttyp-Definition dar. Übung 2: DTD festlegen und auslagern Übungsdatei: -- Ergebnisdateien: kap04\\uebung4.xml, kap04\\uebung5.xml, kap04\\seminar.dtd  Erstellen Sie eine interne Dokumenttyp-Definition für die XML-Struktur des Dokuments, das die Informationen zum Seminar aus der Übung des Kapitels 3 enthält. Ignorieren Sie dabei die angegebenen Attribute.  Lagern Sie die erstellte DTD aus und prüfen Sie die Gültigkeit des Dokuments mithilfe des Programms Microsoft XML Validation Tool. Übung 3: Externe DTD erstellen Übungsdatei: -- Ergebnisdateien: kap04\\uebung6.xml, kap04\\kfz.dtd  Erstellen Sie eine externe Dokumenttyp-Definition für die Fahrzeugverwaltung aus der Übung von Kapitel 3. Hochschulversion 5 XML 1.1 - Grundlagen 40 © HERDT-Verlag 5 DTD – Attribute von Elementen In diesem Kapitel erfahren Sie wie Sie die Attribute eines Elements festlegen und nutzen welche Attributtypen es gibt wie Sie Platzhalter mithilfe von Entities einsetzen wie Sie auf externe Binärdaten verweisen Voraussetzungen Aufbau eines XML-Dokuments Elemente der DTD 5.1 Attributlisten-Definition Attribute werden verwendet, um Elemente genauer zu spezifizieren. Auch in XML können Sie die Attribute eines Elements festlegen. Eine Attributlisten-Definition in einer DTD hat die folgenden Eigenschaften: Sie legt fest, welchem Element bestimmte Attribute zugewiesen werden können. Es werden der Typ eines Attributs und die möglichen Werte beschrieben. Sie können eine bestimmte Voreinstellung eines Attributs festlegen. Diese kann zu einer speziellen Interpretation durch eine Anwendung dienen. Grundlegend wird ein Attribut über das Schlüsselwort ATTLIST innerhalb der Dokumenttyp-Definition fest- gelegt. <!ATTLIST Element AttributName (AttributTyp)> Das Element, dem das Attribut zugewiesen werden soll, wird als Parameter Element bezeichnet. Dahinter folgt die Angabe des Attributnamens. Über die Angabe AttributTyp wird festgelegt, welche Werte dem Attribut übergeben werden können. Es gibt drei Gruppen von Attributtypen: Eine beliebige Zeichenkette, die über das Schlüsselwort CDATA definiert wird. Eine Aufzählung, für die es kein spezielles Schlüsselwort gibt. Bei einer Aufzählung werden die mög- lichen Werte direkt vorgegeben. Die Schlüsselwörter, die unter dem Begriff \"Token\" zusammengefasst werden. Die möglichen Schlüs- selwörter werden im weiteren Verlauf des Kapitels näher erläutert. Beispiel Das HTML-Element IMG zum Darstellen einer Grafik besitzt mehrere Attribute, wie die Rahmenbreite border, die alternative Textangabe alt bzw. title oder die Größenangaben height und width. Das Attribut, das Sie angeben müssen, um die Grafik im Browser anzeigen zu lassen, ist die Angabe des Bildnamens über das Attribut src. Die Kurzform der Attributdefinition, wenn alle anderen Attribute erst einmal nicht betrachtet werden, lautet: <!ATTLIST IMG src CDATA #REQUIRED> Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 41 In der Attributliste des Elements IMG wird src als Attribut vereinbart. Die Angabe von CDATA besagt, dass der Name der Quelldatei src eine beliebige Zeichenfolge enthalten kann, die zwingend angegeben werden muss (#REQUIRED). Das Schlüsselwort CDATA gibt an, dass einem Attribut jede beliebige Zeichenkette zugeordnet werden kann. Folgendes sollten Sie beachten: Das Schlüsselwort ATTLIST ist immer in Großbuchstaben zu schreiben. Die Definition eines Attributs kann an einer beliebigen Stelle innerhalb der DTD vorgenommen werden. Um sie jedoch leichter lesbar zu machen, notieren Sie die Definition direkt hinter dem entsprechenden Element. Für ein Element können auch mehrere Attributlisten-Definitionen angelegt werden. Sie werden vom Parser automatisch zu einer Liste zusammengefasst. Werden mehrere Deklarationen für ein und dasselbe Attribut eines Elements vorgenommen, wird nur die erste berücksichtigt. Nachfolgende Definitionen werden ignoriert. Attributvorgaben Oft ist es sinnvoll, bestimmte Werte eines Attributs vorzugeben. Das Attribut kann dann nur einen der angebotenen Werte annehmen. Die Festlegung der Attributvorgabe erfolgt über die Definition der Wert- vorgaben. <!ATTLIST IMG src CDATA align (left|center|right)> Die Werte werden in Klammern angegeben und mit dem Zeichen voneinander getrennt. Der Nutzer kann nur eine der Vorgaben in dem entsprechenden Attribut verwenden. Das obige Beispiel legt fest, dass das Attribut align entweder den Wert left, center oder right annehmen kann. Andere Angaben verur- sachen Fehler innerhalb des verarbeitenden Programms. Wertvorgabe Standardmäßig können Sie dem Attribut einen bestimmten Vorgabewert zuweisen. Dabei wird ein Wert vor- gegeben, den das Attribut automatisch annehmen soll, wenn es nicht angegeben wird. Ein Beispiel ist das Attribut align des HTML-Elements IMG. Geben Sie das Attribut nicht an, wird das Bild automatisch linksbündig dargestellt. <!ATTLIST IMG src CDATA align (left|center|right) \"left\"> Für das Attribut align werden die möglichen Werte left, center und right definiert. Mit der nachfolgen- den Angabe von left wird automatisch festgelegt, dass das Attribut align den Wert left erhält, wenn das Attribut nicht angegeben wird. Bei der Angabe eines vorgegebenen Wertes ist darauf zu achten, dass dieser immer in Anführungszeichen gesetzt werden muss. Wenn Sie ein Attribut definiert haben, muss es gegebenenfalls nicht unbedingt angegeben werden. Darum müssen Sie festlegen, ob das Attribut angegeben werden muss oder ob es ein optionaler Parameter ist. Hier- für stehen die Schlüsselworte #REQUIRED und #IMPLIED zur Verfügung. Über eine Wertvorgabe können Sie festlegen, welcher Wert automatisch als Vorgabewert genutzt werden soll. Feste Werte definieren Sie mit #FIXED. Hochschulversion 5 XML 1.1 - Grundlagen 42 © HERDT-Verlag #REQUIRED Dieses Schlüsselwort legt fest, dass ein bestimmtes Attribut unbedingt angegeben werden muss. Wird das Attribut nicht angegeben, ist das XML-Dokument nicht gültig. <!ATTLIST IMG src CDATA #REQUIRED> Dieses zusätzliche Schlüsselwort legt eindeutig fest, dass innerhalb des Elements IMG unbedingt das Attribut src angegeben werden muss. Beispiel: kap05\\attlist_required.xml <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <!DOCTYPE HTML [ <!ELEMENT HTML (IMG)> <!ELEMENT IMG EMPTY> <!ATTLIST IMG src CDATA #REQUIRED align (left|center|right) \"left\"> ]> <HTML> <IMG src=\"bild.jpg\" align=\"center\" /> </HTML> #IMPLIED Ein weiteres Schlüsselwort ist die optionale Angabe #IMPLIED. Mit dieser Angabe stellen Sie frei, ob das defi- nierte Attribut genutzt wird. Die Definition der alternativen Beschreibung einer Grafik lautet beispielsweise: <!ATTLIST IMG src CDATA #REQUIRED alt CDATA #IMPLIED> Es ist Ihnen also freigestellt, ob Sie das Attribut innerhalb des Elements angeben oder nicht. Auch das HTML- Element IMG enthält Attributvorgaben, wie z. B. alt für die Textalternative zur Grafik. Beispiel: kap05\\attlist_implied.xml <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <!DOCTYPE HTML [ <!ELEMENT HTML (IMG)> <!ELEMENT IMG EMPTY> <!ATTLIST IMG src CDATA #REQUIRED alt CDATA #IMPLIED align (left|center|right) \"left\"> ]> <HTML> <IMG src=\"bild.jpg\" alt=\"Ein Bild\" /> </HTML> #FIXED Über das Schlüsselwort #FIXED können Sie einen festen Wert definieren. In diesem Fall kann das Attribut keinen anderen Wert annehmen, da dieses Schlüsselwort für die Definition einer Art konstanter Attribute bestimmt ist. <!ATTLIST IMG src CDATA #REQUIRED alt CDATA #IMPLIED align (left|center|right) \"left\" typ CDATA #FIXED \"image\"> Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 43 Auch wenn in dem betreffenden Element dem erdachten Attribut typ kein Wert zugewiesen wird, erhält es standardmäßig den festen Vorgabewert image. Die fast vollständige Definition der möglichen Attribute für das Einbinden einer Grafik in eine Webseite wird anhand der Dokumenttyp-Definition des HTML-Elements IMG gezeigt. Beispiel: kap05\\img.xml Im folgenden Beispiel legen Sie die Dokumenttyp-Definition für das HTML-Element IMG an und definieren die verschiedenen Attribute. In der XML-Struktur werden die beiden Attribute src und alt verwendet.        <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <!DOCTYPE HTML [ <!ELEMENT HTML (IMG)> <!ELEMENT IMG EMPTY> <!ATTLIST IMG src CDATA #REQUIRED alt CDATA #IMPLIED align (left|center|right) \"left\" title CDATA #IMPLIED height CDATA #IMPLIED width CDATA #IMPLIED border CDATA #IMPLIED hspace CDATA #IMPLIED vspace CDATA #IMPLIED> ]> <HTML> <IMG src=\"bild.jpg\" alt=\"Ein Bild\" /> </HTML>  Innerhalb der Dokumenttyp-Definition wird das Element IMG als Unterelement des Elements HTML fest- gelegt.  Das Element IMG enthält keinen Wert und wird somit als leerer Elementinhalt EMPTY definiert.  Für das Element IMG wird die Definition der möglichen Attribute eingeleitet.  Um eine Grafik darzustellen, wird über das Schlüsselwort #REQUIRED der Name der zu verwendenden Datei als Wert des Attributs src angegeben. Die Angabe des Attributs wird dadurch erzwungen. Der Wert des Attributs kann eine beliebige Zeichenfolge sein (CDATA).  Die Alternativangabe der Bilddatei wird über das Attribut alt angegeben. Da diese Angabe nicht not- wendig ist, um ein Bild anzuzeigen, wird es, wie auch die nachfolgenden Attribute, als #IMPLIED defi- niert.  Die Ausrichtung einer Grafik ist eine mögliche Angabe, die nicht zwingend erforderlich ist. Die Werte für das Attribut align sind in Klammern vorgegeben. Entweder kann das Attribut den Wert left, center oder right enthalten. Andere Werte sind nicht möglich. Wird kein Attribut angegeben, wird automatisch das Attribut align mit dem Wert left benutzt.  Das Element IMG wird mit einigen Attributangaben verwendet. Attributliste der Musiksammlung Zur näheren Erläuterung wird die bereits erstellte Musiksammlung als Beispiel verwendet. Das Attribut typ soll, wie bisher, innerhalb des Elements ALBUM verwendet werden, um die Art des Tonträgers anzuzeigen. <MUSIKSAMMLUNG> <ALBUM typ=\"...\"> <AUTOR></AUTOR> <INTERPRET></INTERPRET> <TITEL></TITEL> <LIED></LIED> </ALBUM> </MUSIKSAMMLUNG> Hochschulversion 5 XML 1.1 - Grundlagen 44 © HERDT-Verlag Zur Auswahl stehen hierbei die Typen CD, Vinyl als Synonym für die Schallplatte, MP3 für die Alben im ent- sprechenden Soundformat und MC für die gute alte Musikkassette. Die Attributlisten-Definition für das Element ALBUM legen Sie folgendermaßen fest: <!ATTLIST ALBUM typ (CD | MP3 | Vinyl | MC)> Da heutzutage mehr MP3s als CDs, Schallplatten oder Musikkassetten verkauft werden, können Sie bei der Attributlisten-Definition davon ausgehen, dass in der Musiksammlung die Mehrzahl der Alben als MP3 angegeben werden. In diesem Fall ist es besser, das Attribut typ=\"MP3\" als Voreinstellung zu definieren. <!ATTLIST ALBUM typ (CD | MP3 | Vinyl | MC) \"MP3\"> Wenn das Attribut typ jetzt nicht angegeben wird, erhält das Album automatisch den Typ MP3. Demzufolge wären beide nachfolgende Angaben, mit dem Attribut  und ohne Attribut , identisch.   <ALBUM typ=\"MP3\"> <TITEL>Minor Earth Major Sky</TITEL> </ALBUM> <ALBUM> <TITEL>Minor Earth Major Sky</TITEL> </ALBUM> Beispiel: kap05\\musiksammlung-dtd.xml Dies ist die vollständige XML-Datei für die Musiksammlung inklusive der Attributlisten-Definition.      <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <!DOCTYPE MUSIKSAMMLUNG [ <!ELEMENT MUSIKSAMMLUNG (ALBUM+)> <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE)+, TITEL, LIED*)> <!ATTLIST ALBUM typ (CD | MP3 | Vinyl | MC) \"MP3\"> <!ELEMENT AUTOR (#PCDATA)> <!ELEMENT INTERPRET (#PCDATA)> <!ELEMENT GRUPPE (#PCDATA)> <!ELEMENT TITEL (#PCDATA)> <!ELEMENT LIED (#PCDATA)> ]> <MUSIKSAMMLUNG> <ALBUM> <AUTOR></AUTOR> <INTERPRET></INTERPRET> <TITEL></TITEL> <LIED></LIED> </ALBUM> </MUSIKSAMMLUNG>  Das Hauptelement MUSIKSAMMLUNG darf mehrere Elemente mit der Bezeichnung ALBUM enthalten.  Innerhalb des Elements ALBUM dürfen wiederum die in Klammern aufgelisteten Elemente angegeben werden.  Zusätzlich wird für das Element ALBUM das Attribut typ festgelegt. Dieses darf die Werte CD, MP3, Vinyl oder MC enthalten. Geben Sie später in der XML-Struktur das Attribut nicht an, wird der Attributwert durch das verarbeitende Programm automatisch auf den Wert MP3 gesetzt.  Die möglichen Inhalte der nachfolgenden Elemente, die innerhalb des Elements ALBUM notiert werden müssen, werden festgelegt.  Die XML-Struktur der Musiksammlung wird angelegt. Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 45 5.2 Attributtypen CDATA Die am meisten verwendeten Attributtypen sind CDATA-Attribute. Deren Inhalte können, genau wie #PCDATA in Elementen, aus beliebigen Zeichenfolgen bestehen. Der Unterschied zwischen beiden besteht darin, dass bei CDATA auch Zeichen enthalten sein dürfen, die normalerweise als XML-Zeichen interpretiert werden könnten, wie z. B. , . Bei #PCDATA (parsed character data) zählen diese Zeichen zur XML-Sprache.   <!ATTLIST PERSON name CDATA> ... <PERSON name=\"Max Mustermann\"></PERSON>  Der Name einer Person kann beliebige Zeichen enthalten.  Dem Element PERSON wird das Attribut name=\"Max Mustermann\" zugewiesen. Aufzählung Neben der Angabe beliebiger Zeichen als Wert für ein Attribut können Sie auch aufzählen, welche Werte vor- gegeben sind. Aus diesen Werten ist einer auszuwählen.   <!ATTLIST TELEFON nutzungsart (geschäftlich|privat|g|p)> ... <TELEFON nutzungsart=\"p\">555-1234</TELEFON>  Ein gültiger Wert für die Nutzung des Telefons ist in diesem Fall geschäftlich oder privat. Auch die entsprechende Abkürzung g oder p kann mit dieser Definition verwendet werden.  Das Element TELEFON wird über das Attribut nutzungsart als private Telefonnummer gekennzeichnet. Token Unter dem Begriff Token werden verschiedene Attributtypen zusammengefasst. Ein Token ist eine Zeichen- folge, die für einen Parser eine syntaktische Einheit darstellt und über die nachfolgenden Attributtypen fest- gelegt und angesprochen wird. ID Für jedes Element in einem XML-Dokument können Sie eine eindeutige Bezeichnung (ID) vergeben. Mit dieser ID können Sie beispielsweise das entsprechende Element über eine Skriptsprache direkt ansprechen und aus- werten. Die ID bezieht sich global auf alle Elemente des Dokuments. Der Wert darf nur einmal vorkommen.   <!ATTLIST PERSON kennung ID #IMPLIED> ... <PERSON kennung=\"P1487\">Max Mustermann</PERSON>  Die Attributlisten-Definition legt fest, dass innerhalb des Elements PERSON über das Attribut kennung eine eindeutige Kennzeichnung zugewiesen werden kann (Attributtyp ID).  Die eindeutige Bezeichnung wird festgelegt. IDREF und IDREFS Ein Attribut von diesem Typ verweist auf ein Element, das zuvor mithilfe des Attributtyps ID eindeutig be- stimmt wurde. Zusätzlich müssen Sie angeben, ob es sich um eine notwendige Angabe (#REQUIRED) oder um eine optionale Angabe (#IMPLIED) handelt. Der Typ IDREF kann nur verwendet werden, wenn ein Element mit der entsprechenden Referenz-ID vorhanden ist. Auf diese Weise können Sie Verknüpfungen zwischen den Daten eines XML-Dokuments herstellen. So ist es beispielsweise möglich, zwischen mehreren Personen eine Verwandtschaft zu kennzeichnen. > < Hochschulversion 5 XML 1.1 - Grundlagen 46 © HERDT-Verlag Beispiel: kap05\\token-idref.xml Im folgenden Beispiel werden verschiedenen Personen über den Attributtyp ID eindeutige Kennungen zuge- wiesen und über den Attributtyp IDREF angesprochen. Damit soll das Verwandtschaftsverhältnis der aufgelis- teten Personen gekennzeichnet werden.      <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <!DOCTYPE TOKEN [ <!ELEMENT TOKEN (PERSON*)> <!ELEMENT PERSON (#PCDATA)> <!ATTLIST PERSON kennung ID #REQUIRED> <!ATTLIST PERSON verwandt IDREF #IMPLIED> ]> <TOKEN> <PERSON kennung=\"P1\">Max Müller</PERSON> <PERSON kennung=\"P2\" verwandt=\"P3\">Max Mustermann</PERSON> <PERSON kennung=\"P3\" verwandt=\"P2\">Erwin Mustermann</PERSON> </TOKEN>  Für das Element wird das notwendige Attribut kennung bereitgestellt, um eine Person eindeutig über den Attributtyp ID zu kennzeichnen.  Des Weiteren ist die Angabe der Verwandtschaft der Person über das Attribut verwandt vom Typ IDREF möglich.  Der ersten Person wird die Kennung P1 zugewiesen.  Die nächste Person erhält die Kennung P2 und ist verwandt mit einer Person, welche die Kennung P3 hat.  Die Person Erwin Mustermann besitzt die Kennung P3 und steht somit in Verwandtschaft mit Max Mustermann. Das Attribut IDREFS ist die Pluralform von IDREF und erlaubt die Angabe mehrerer Verknüpfungen. Die ein- zelnen Angaben werden durch Leerzeichen voneinander getrennt. Beispiel: kap05\\token-idrefs.xml <!ATTLIST PERSON kennung ID #REQUIRED> <!ATTLIST PERSON verwandt IDREFS #IMPLIED> ... <TOKEN> <PERSON kennung=\"P1\">Max Müller</PERSON> <PERSON kennung=\"P2\" verwandt=\"P3 P4\">Max Mustermann</PERSON> <PERSON kennung=\"P3\" verwandt=\"P2 P4\">Erwin Mustermann</PERSON> <PERSON kennung=\"P4\" verwandt=\"P2 P3\">Erika Mustermann</PERSON> </TOKEN> NMTOKEN und NMTOKENS Mit dem Attributtyp CDATA kann jedes beliebige Zeichen benutzt werden. Mit NMTOKEN schränken Sie die er- laubten Zeichen auf Buchstaben, Ziffern und die Zeichen Punkt , Doppelpunkt , Bindestrich und Un- terstrich ein. Weder Leerzeichen noch andere Zeichen sind zulässig. Mit der Pluralform NMTOKENS lassen sich mehrere Einschränkungen festlegen. <!ATTLIST PERSON kuerzel NMTOKEN #IMPLIED> ... <TOKEN> <PERSON kuerzel=\"M.M.\">Max Müller</PERSON> </TOKEN> . : - _ Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 47 ENTITY und ENTITIES Mithilfe des Attributtyps ENTITY können Sie auf Dateien und andere Objekte verweisen. Zur Definition einer Entity vgl. Abschnitt 5.3. Die Syntax für die Deklaration eines Entity-Attributs in einer externen DTD lautet: <!ATTLIST ElementName AttributName ENTITY> NOTATION und NOTATIONS Notationen werden eingesetzt, um auf externe Informationen zuzugreifen. So wäre es beispielsweise denk- bar, dass ein Programm aufgerufen werden soll, um eine spezielle Datei anzuzeigen. <!ATTLIST ElementName AttributName (Vorgaben) NOTATION> Innerhalb der Attributlisten-Definition bestimmen Sie das Attribut für ein Element. In Klammern setzen Sie die möglichen Vorgaben. Das Schlüsselwort NOTATION schreiben Sie an das Ende der Definition. Zur Defini- tion eines Notationsdatentyps vgl. Abschnitt 5.4. <!ATTLIST PERSON foto NOTATION> ... <TOKEN> <PERSON foto=\"images/maxmueller.jpg\">Max Müller</PERSON> </TOKEN> 5.3 Referenz auf Entitäten Allgemeine Entities Über Entities (Platzhalter) werden Sonderzeichen mithilfe von Bezeichnungen dargestellt. Der Aufbau von Entities ist einheitlich. Jeder Entity-Verweis beginnt mit dem UND-Zeichen , gefolgt von der Bezeichnung des Sonderzeichens und dem abschließenden Semikolon . Die vordefinierten Entities für XML sind: Code Erläuterung Zeichen Code Erläuterung Zeichen &lt; kleiner als &apos; einfaches Anführungszeichen &gt; größer als &quot; doppeltes Anführungszeichen &amp; Ampersand In XML können Sie statt der Sonderzeichen auch Abkürzungen für lange und häufig eingesetzte Zeichen- folgen in den Inhalten eines Elements festlegen. Statt einen bestimmten Text immer erneut anzugeben, können Sie die Abkürzung verwenden. Ebenso können Sie Entities für immer wiederkehrende Elementlisten einsetzen. Entities können Sie nicht für die Bezeichnung eines Elements oder eines Attributs verwenden. Syntax Das Schlüsselwort für das Festlegen eines Platzhalters ist ENTITY. Danach folgt der Name, der später für den konkreten Text verwendet werden soll. <!ENTITY abkuerzung \"Text, auf den sich die Abkürzung bezieht\"> <!-- Verwenden als: &abkuerzung; --> Hochschulversion 5 XML 1.1 - Grundlagen 48 © HERDT-Verlag Möchten Sie den definierten Platzhalter in Ihrem Dokument verwenden, setzen Sie die entsprechende Entity ein. Dabei umschließen Sie den Entity-Namen mit den Zeichen und . Beispiel: kap05\\entity.xml Es sollen die Namen von Personen als Entities definiert und innerhalb der XML-Elemente als Inhalte verwen- det werden.     <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <!DOCTYPE ALLGENTITY [ <!ELEMENT ALLGENTITY (PERSON*)> <!ELEMENT PERSON (#PCDATA)> <!ENTITY mm \"Max Müller\"> <!ENTITY em \"Erwin Mustermann\"> ]> <ALLGENTITY> <PERSON>&mm;</PERSON> <PERSON>&em;</PERSON> </ALLGENTITY>  Mit dem Datentyp ENTITY wird der Abkürzung mm der Wert Max Müller übergeben.  Es wird die Abkürzung em definiert.  Dem Element PERSON wird die Entity mm als Inhalt übergeben. Sie liefert den Namen Max Müller.  Hier wird als Inhalt der Wert Erwin Mustermann verwendet. Parameter-Entity Parameter-Entities können Sie als Platzhalter innerhalb einer DTD betrachten. Diese Entities wenden Sie an, wenn innerhalb von Elementlisten häufig gleiche Zeichenketten wiederkehren. In der DTD von HTML sind beispielsweise die Möglichkeiten einer Ausrichtung über das Attribut align in einer Parameter-Entity defi- niert. Die Ausrichtungen von Inhalten in Überschriften, Tabellenzellen und Absätzen erfolgen hierbei immer über das Attribut align mit den Werten left, center oder right. <!ELEMENT HTML (H1 | H2 | H3 | H4 | H5 | H6 | P | TD)*> <!ELEMENT H1 align (left|center|right) #IMPLIED> <!ELEMENT H2 align (left|center|right) #IMPLIED> ... <!ELEMENT TD align (left|center|right) #IMPLIED> <!ELEMENT P align (left|center|right) #IMPLIED> Eine Parameter-Entity darf in einer Deklaration eines Elements, eines Attributs oder einer anderen Entität nur dann referenziert werden, wenn diese Referenz in einer externen DTD festgelegt wurde. Syntax Mithilfe von Parameter-Entities können Elementlisten als Abkürzung definiert und später wieder abgerufen werden. Die Definition erfolgt über die folgende Syntax: <!ENTITY % umschreibung \"wiederkehrende Elementlisten\"> <!-- Einbinden über: %umschreibung; --> Im Unterschied zur allgemeinen Entity wird in der Parameter-Entity der Platzhalter mit einem Prozentzeichen gekennzeichnet. Danach folgt die Umschreibung der Elementliste. Eingebunden wird der Platzhalter mit einem vorangestellten Prozentzeichen und einem abschließenden Semikolon . Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 49 Beispiel: kap05\\htmlalign.dtd In einer externen Datei wird die Definition der Parameter-Entities für die Elementlisten festgelegt. Dabei sollen über die Entity align die Werte left, center und right an die Elemente übergeben werden. Über die Entity heading können Sie verschiedene Größen von Überschriften verwenden.      <!ENTITY % heading \"H1 | H2 | H3 | H4 | H5 | H6\"> <!ENTITY % align \"align (left|center|right) #IMPLIED\"> <!ELEMENT HTML ((%heading;)|P|TD)*> <!ELEMENT H1 (#PCDATA)> <!ATTLIST H1 %align;> <!-- <!ATTLIST H1 align (left|center|right) #IMPLIED> --> <!ELEMENT H2 (#PCDATA)> <!ATTLIST H2 %align;> <!ELEMENT H3 (#PCDATA)> <!ATTLIST H3 %align;> <!ELEMENT H4 (#PCDATA)> <!ATTLIST H4 %align;> <!ELEMENT H5 (#PCDATA)> <!ATTLIST H5 %align;> <!ELEMENT H6 (#PCDATA)> <!ATTLIST H6 %align;> <!ELEMENT TD (#PCDATA)> <!ATTLIST TD %align;> <!ELEMENT P (#PCDATA)> <!ATTLIST P %align;>  Die Parameter-Entity wird als heading definiert und enthält die Auflistung aller HTML-Elemente für die Überschriften.  Die Angabe align (left|center|right) #IMPLIED wird als abgekürzte Parameter-Entity align definiert.  Statt alle möglichen Überschriften (H1-H6) in der Inhaltsdefinition des Hauptelements HTML anzugeben, wird die definierte Kurzform %heading; verwendet. Da nach der Auflistung der Überschriften noch eine weitere Angabe von Elementen folgt (P und TD), muss die Parameter-Entity in Klammern gesetzt werden.  Es folgt die Definition aller Elemente, die im Hauptelement HTML möglich sind.  Dem Element H1 wird die Parameter-Entity %align zugewiesen. Der Inhalt des Attributs verbirgt sich hinter der festgelegten Abkürzung %align; daraus ergibt sich die als Kommentar angegebene Attri- butlisten-Definition für die möglichen Ausrichtungsarten. Innerhalb von Elementtyp-Definitionen dürfen für die Namen keine Entities verwendet werden, da jedes Ele- ment einzeln definiert werden muss. Die Angabe von <!ELEMENT %heading; (#PCDATA)> würde z. B. beim Parsen der XML-Datei zu einer Fehlermeldung führen. Beispiel: kap05\\htmlalign.xml Die externe Teilmenge der DTD wird zur Nutzung der Parameter-Entities in die XML-Datei eingebunden. <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <!DOCTYPE HTML SYSTEM \"htmlalign.dtd\"> <HTML> <H1 align=\"center\">zentrierte Überschrift</H1> <H2 align=\"right\">rechtsbündige Überschrift</H2> </HTML> Hochschulversion 5 XML 1.1 - Grundlagen 50 © HERDT-Verlag Externe Entities Eine weitere Möglichkeit, Entities zu definieren, ist der Verweis auf bestehende XML-Dateien oder binäre Dateien, wie Bilder, Dokumente, Musikdateien usw. <!ENTITY abkuerzung SYSTEM \"Dateiname\" NDATA Binärtyp> Der Entity abkuerzung wird durch die Angabe einer Notation (NDATA=Notation Data) ein bestimmter Binärtyp zugewiesen. Dieser besagt, dass es sich um nicht interpretierbare Daten handelt, zumindest nicht in XML. Der Parameter Dateiname gibt an, auf welche externe Datei sich die Notation bezieht. Der Dateiname kann als relativer oder absoluter Pfad angegeben werden. Externe Entities werden folgendermaßen definiert: <!ENTITY pngdatei SYSTEM \"abc123.png\" NDATA png> <!ENTITY bild1 SYSTEM \"../images/bild1.gif\" NDATA gif89a> <!ENTITY pdfdatei SYSTEM \"http://www.example.com/xyz.pdf\" NDATA pdf> Die Entity-Referenz wird anders verwendet als bisher. Sie darf nur als Attributwert vom Typ Entity auftreten. <!ATTLIST Elementname Attributname ENTITY Attributvorgabe> Beispiel: kap05\\ndata.xml Es werden Entities für einzelne Grafiken gebildet, die eine festgelegte Quelldatei besitzen und vom Dateityp gif89a sind. Eingebunden werden diese Grafiken über den Aufruf der entsprechenden Entities.       <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <!DOCTYPE BILDERGALERIE [ <!NOTATION gif89a SYSTEM \"GIF\"> <!ENTITY bild1 SYSTEM \"images/bild1.gif\" NDATA gif89a> <!ENTITY bild2 SYSTEM \"images/bild2.gif\" NDATA gif89a> <!ELEMENT BILDERGALERIE (IMG)+> <!ELEMENT IMG EMPTY> <!ATTLIST IMG src ENTITY #REQUIRED> ]> <BILDERGALERIE> <IMG src=\"bild1\" /> <IMG src=\"bild2\" /> </BILDERGALERIE>  Über das Schlüsselwort NOTATION wird das Datenformat GIF definiert, welches über das Kürzel gif89a angesprochen werden kann. Zu den notwendigen Angaben für diese Definition und deren Auswirkung auf das Verhalten des Programms vgl. Abschnitt 5.4.  Der Entity bild1 wird der Name einer binären Datei zugewiesen, die unter dem Pfad images/bild1. gif zu finden ist. Die Datei ist vom Notationstyp gif89a.  Hier wird der Entity bild2 der Name der Datei images/bild2.gif im Format gif89a zugewiesen.  Das Attribut src , das zwingend angegeben werden muss, enthält die soeben definierten Entities.  Dem Element IMG wird das Attribut src mit dem Wert bild1 zugewiesen. Der Parser stellt durch die Attributdeklaration  fest, dass es sich bei dem Wert um ein Entity handelt. Die Angabe des Wertes bild1 und dessen Deklaration  zeigt, wo die Grafikdatei zu finden ist.  Dem zweiten Element IMG wird der Name der Binärdatei images/bild2.gif  zugewiesen. Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 51 5.4 Datentyp Notation In einer Notation werden die Datenformate definiert, die zur Anzeige oder Verarbeitung auf andere Anwen- dungen verweisen sollen. Dem Parser wird auf diese Weise mitgeteilt, wie er die Entities behandeln soll. <!NOTATION abkuerzung SYSTEM \"Verweis oder Datentyp\"> Die Definition legt fest, welche Abkürzung mit dem angegebenen Dateiformat gleichzusetzen ist. Beispiels- weise können Sie über das Schlüsselwort SYSTEM die URI bestimmter Anwendungsprogramme angeben. Öffentlich zugängliche Definitionen können Sie auch über das Schlüsselwort PUBLIC kenntlich machen. Nachdem in einer Notationsdeklaration ein Kürzel mit einer Anwendung verbunden wurde, kann ein Attribut vom Typ NOTATION deklariert werden. <!ATTLIST ElementName AttributName NOTATION (abkuerzung)> Ein Attribut vom Typ NOTATION darf nicht auf einem Element deklariert werden, das als EMPTY deklariert wurde. Beispiel: kap05\\notation.xml Es wird die Abkürzung tif angelegt, die automatisch bei einem Aufruf als Attributwert eines Elements das angegebene Programm oder den Verweis ausführt.    <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <!DOCTYPE BILDERGALERIE [ <!NOTATION tif SYSTEM \" C:\\Programme\\TV\\tifviewer.exe\"> <!ELEMENT BILDERGALERIE (IMG)> <!ELEMENT IMG (#PCDATA)> <!ATTLIST IMG typ NOTATION (tif) #REQUIRED quelle CDATA #REQUIRED> ]> <BILDERGALERIE> <IMG typ=\"tif\" quelle=\"images/bild.tif\" /> </BILDERGALERIE>  In der Notation wird über die Abkürzung tif der Pfad zu einer lokalen Anwendung definiert, um das Bild anzuzeigen.  Dem Attribut typ des Elements IMG wird der Datentyp NOTATION zugewiesen.  Das Element IMG erhält über das Attribut typ den Notationstyp tif. Um das nachfolgende Bild quelle in einem Anwendungsprogramm darzustellen, wird auf den Pfad des ausführbaren Bildbetrachters tifviewer.exe verwiesen. Weitere Beispiele für Notationsdeklarationen sind: <!NOTATION mpeg SYSTEM \"http://www.example.com/programs/mpeg32.exe\"> <!NOTATION mid SYSTEM \"midplayer.exe\"> <!NOTATION html PUBLIC \"-//W3C//DTD HTML 4.0//EN\"> <!NOTATION gif PUBLIC \"-//Compuserve //NOTATION Graphics Interchange Format//EN\"> <!NOTATION pdf PUBLIC \"-//Adobe Inc.//NOTATION Portable Document Format//EN\"> Die Strukturen der möglichen übergebenen Werte in den Notationen sind noch nicht standardisiert. Wie die Werte interpretiert werden, ist von der verwendeten Anwendung abhängig, welche die Daten verarbeiten soll. Somit ist es derzeit möglich, beliebige Informationen als Werte anzugeben. Hochschulversion 5 XML 1.1 - Grundlagen 52 © HERDT-Verlag Beispiel: kap05\\ms.dtd Die bisherige Musiksammlung soll um die Informationen zur Gesamtspielzeit, zur veröffentlichenden Musik- firma (Label) und zum Erscheinungsjahr erweitert werden. Zusätzlich soll es möglich sein, jedem Album ein oder mehrere Bilder in den Formaten gif oder jpg zuweisen zu können.          <!NOTATION jpg PUBLIC \"-//ISO DIS 10918//NOTATION JPEG Graphics Format//EN\"> <!NOTATION gif PUBLIC \"-//Compuserve//NOTATION Graphics Interchange Format//EN\"> <!ENTITY MRL \"Mute Records Limited\"> <!ELEMENT MUSIKSAMMLUNG (ALBUM+)> <!ELEMENT ALBUM (AUTOR, (INTERPRET | GRUPPE), TITEL, GESAMTZEIT?, LABEL?, JAHR?, BILD*, LIED*)> <!ATTLIST ALBUM typ (CD | MP3 | Vinyl | MC) \"MP3\"> <!ELEMENT AUTOR (#PCDATA)> <!ELEMENT INTERPRET (#PCDATA)> <!ELEMENT GRUPPE (#PCDATA)> <!ELEMENT TITEL (#PCDATA)> <!ELEMENT GESAMTZEIT (#PCDATA)> <!ELEMENT LABEL (#PCDATA)> <!ELEMENT JAHR (#PCDATA)> <!ELEMENT BILD (#PCDATA)> <!ATTLIST BILD typ NOTATION (gif | jpg) #REQUIRED quelle CDATA #REQUIRED > <!ELEMENT LIED (#PCDATA)>  Mit der Notation wird das Datenformat jpg definiert.  Das Graphics Interchange Format der Firma Compuserve wird als Notation gif festgelegt.  Die Entity MRL wird definiert und kann später als Abkürzung für die Zeichenkette Mute Records Limited eingesetzt werden.  Das Element MUSIKSAMMLUNG enthält das Unterelement ALBUM, das mehrfach vorkommen kann.  Das Element ALBUM beinhaltet die Elemente AUTOR, TITEL, GESAMTZEIT, LABEL, JAHR, BILD und LIED sowie die über den ODER-Separator verknüpften Elemente INTERPRET und GRUPPE. Diese können je nach Angabe einmalig oder mehrfach im Element ALBUM verwendet werden.  Dem Element ALBUM wird ein optionales Attribut typ zugewiesen. Wird es nicht angegeben, erhält das Attribut automatisch den Wert MP3.  Es folgt die Datentyp-Definition der einzelnen Elemente.  Dem leeren Element BILD werden die Attribute typ und quelle zugewiesen. Das Attribut typ ist vom Datentyp NOTATION und darf entweder den Wert gif oder den Wert jpg enthalten. Der Wert des Attributs quelle hingegen kann eine beliebige Zeichenfolge sein. Beide Attribute sind bei der Angabe des Elements BILD unbedingt mit anzugeben (#REQUIRED).  Zuletzt wird das Element LIED als beliebige Zeichenfolge definiert. Beispiel: kap05\\ms.xml Die Dokumenttyp-Definition ms.dtd wird in die XML-Datei der Musiksammlung eingebunden und innerhalb der XML-Struktur verwendet.       <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <!DOCTYPE MUSIKSAMMLUNG SYSTEM \"ms.dtd\" [ <!ENTITY hs \"Heiko Schröder\"> ]> <MUSIKSAMMLUNG> <ALBUM> <AUTOR>&hs;</AUTOR> <INTERPRET>Moby</INTERPRET> <TITEL>Play</TITEL> Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 53     <GESAMTZEIT>63:03</GESAMTZEIT> <LABEL>&MRL;</LABEL> <JAHR>1999</JAHR> <BILD typ=\"jpg\" quelle=\"images/moby_play1.jpg\" /> <BILD typ=\"jpg\" quelle=\"images/moby_play2.jpg\" /> <LIED>Honey</LIED> <LIED>Find my baby</LIED> <LIED>Porcelain</LIED> <LIED>Why does my heart feel so bad?</LIED> </ALBUM> <ALBUM typ=\"Vinyl\"> <AUTOR>&hs;</AUTOR> <GRUPPE>a-ha</GRUPPE> <TITEL>Minor earth major sky</TITEL> <GESAMTZEIT>63:03</GESAMTZEIT> <LABEL>&MRL;</LABEL> <JAHR>1999</JAHR> <BILD typ=\"gif\" quelle=\"images/aha_minor.gif\" /> <LIED>Minor earth major sky</LIED> <LIED>Little black</LIED> <LIED>Velvet</LIED> <LIED>Summer moved on</LIED> </ALBUM> </MUSIKSAMMLUNG>  Die XML-Datei wird mit dem Prolog eingeleitet. Die Angabe standalone=\"no\" teilt der Anwendung mit, dass dieses Dokument eine externe Datei benötigt.  Die Dokumenttyp-Definition wird als externe Datei ms.dtd in die XML-Datei geladen.  Innerhalb der XML-Datei wird die externe Teilmenge der DTD um die Entity hs erweitert. Diese Entity wird später als Platzhalter für den Namen des Autors verwendet.  Die XML-Daten werden durch das Hauptelement MUSIKSAMMLUNG eingeleitet.  Das Unterelement ALBUM enthält kein Attribut, besitzt jedoch durch die DTD automatisch das Attribut typ mit dem Wert MP3.  Der Name des Autors wird über die Entity hs angegeben.  Das Element LABEL enthält den Wert der Entity MRL (Mute Records Limited).  Dem Album des Interpreten Moby werden zwei Bilder zugewiesen. Diese sind vom Notationstyp jpg und befinden sich im Unterordner images des XML-Dokuments.  Das zweite Album erschien als Schallplatte und erhält somit das Attribut typ mit dem Wert Vinyl.  Das Bild dieses Albums ist vom Notationstyp gif. Entitys in externen DTDs werden von den aktuellen Browsern nicht unterstützt. Die Ausführung der Datei führt zu einer Fehlermeldung im Mozilla Firefox bzw. zu einer fehlerhaften Darstellung im Internet Explorer. Opera und Chrome verhalten sich analog zum Firefox. Fehlermeldung im Mozilla Firefox Fehlerhafte Darstellung im Internet Explorer Befindet sich die Entity im internen Definitionsteil der DTD des XML-Dokuments, wird das Dokument korrekt dargestellt. Hochschulversion 5 XML 1.1 - Grundlagen 54 © HERDT-Verlag Mozilla Firefox Internet Explorer 5.5 Schnellübersicht Attributtypen Beschreibung #REQUIRED Attribut muss mit dem Element angegeben werden #IMPLIED Attribut kann mit dem Element angegeben werden CDATA Attributwert darf beliebige Zeichenfolge enthalten Aufzählung Mögliche Werte werden vorgegeben Token Oberbegriff für verschiedene Attributtypen ID Attribut erhält eine eindeutige Bezeichnung IDREF / IDREFS Attribut verweist auf ein mit einer ID gekennzeichnetes Element NMTOKEN / NMTOKENS Attributwert darf nur eingeschränkte Zeichen enthalten ENTITY / ENTITIES Anlegen eines Verweises auf eine Zeichenkette NOTATION / NOTATIONS Zugriff auf externe, meist binäre Daten Sie möchten … Attributlisten anlegen <!ATTLIST Element AttributName (AttributTyp)> mögliche Werte vorgeben <!ATTLIST Element AttributName (Wert1|Wert2...) \"Vorgabe\"> allgemeine Entities definieren <!ENTITY abkuerzung \"Text, auf den sich die Abkürzung bezieht\"> allgemeine Entities einsetzen &abkuerzung; Parameter-Entities definieren <!ENTITY % umschreibung \"wiederkehrende Elementlisten\"> Parameter-Entities einsetzen %umschreibung; externe Entities definieren <!ENTITY abkuerzung SYSTEM \"Dateiname\" NDATA Binärtyp> externe Entities einsetzen abkuerzung Datenformate definieren <!NOTATION abkuerzung SYSTEM \"Verweis oder Datentyp\"> Hochschulversion DTD – Attribute von Elementen 5 © HERDT-Verlag 55 5.6 Übung Übung 1: Mit Attributvorgaben arbeiten Übungsdatei: -- Ergebnisdateien: kap05\\uebung1.xml, kap05\\uebung1.dtd Erweitern Sie die Musiksammlung, indem Sie für das Element ALBUM zusätzlich eine Bewer- tung des Albums zulassen. Es soll jedoch dem Autor überlassen sein, ob er eine Bewertung von 0 bis 5 Punkten für die Qualität des Albums vergeben möchte. Übung 2: Attributlisten festlegen Übungsdatei: -- Ergebnisdateien: kap05\\uebung2.xml, kap05\\uebung2.dtd  Das Element TITEL soll als Attribut stil die Werte Schlager, Klassik, Pop, Rock, Independent und Volksmusik enthalten.  Legen Sie in der DTD fest, dass das Attribut stil unbedingt angegeben werden muss. Übung 3: Attributwerte hinzufügen Übungsdatei: -- Ergebnisdateien: kap05\\uebung3.xml, kap05\\uebung3.dtd Fügen Sie in die Dokumenttyp-Definition des XML-Dokuments, das die Angaben zu Ihrem Seminar enthält, die Attribute anrede und typ ein. Diese Werte sollen für die Elemente eingesetzt werden, die sich auf Personenangaben beziehen. Die Werte sind nachfolgend fest vorgegeben. anrede = Herr oder Frau typ = Seminarleiter oder Teilnehmer Übung 4: Mit Attributwerten arbeiten Übungsdatei: -- Ergebnisdateien: kap05\\uebung4.xml, kap05\\uebung4.dtd Legen Sie in der Fahrzeugverwaltung Attribute an, mit denen Sie die Maßeinheiten der technischen Details festlegen. Anmerkung: Nutzen Sie für die Definition der möglichen Attributwerte „ccm“ für „cm³“ sowie „kmh“ statt „km/h“. Hochschulversion 6 XML 1.1 - Grundlagen 56 © HERDT-Verlag 6 Namensräume In diesem Kapitel erfahren Sie was unter Namensräumen zu verstehen ist welche Möglichkeiten es gibt, Namensräume zu definieren wie Sie mithilfe von Namensräumen HTML-Elemente in XML einsetzen können Voraussetzungen Grundlegende HTML-Kenntnisse 6.1 Grundlagen zu Namensräumen Sie erstellen Ihre XML-Datei und verweisen dabei, um die Struktur Ihres Dokumentes zu definieren, auf eine öffentliche, bereits bestehende Dokumenttyp-Definition. Da Sie in Ihrem Dokument noch einige zusätzliche Elemente verwenden möchten, müssen Sie diese Elemente innerhalb Ihres XML-Dokuments definieren. externe DTD <!ENTITY...> <!ELEMENT...> <!ATTLIST...> <!ELEMENT name ...> XML- Dokument <!DOCTYPE name SYSTEM URI [ <!ATTLIST name anrede..> ]> <daten> <name anrede=\"Herr\">Meier</name> </daten> Beim Einsatz von fremden externen XML-Daten kann es vorkommen, dass die Namen von Elementen doppelt vergeben werden. Sie können nicht sicherstellen, dass diese Dokumente nur Elemente verwenden, die Sie nicht in Ihrer eigenen XML-Datei definiert haben. Falls Sie dazu noch andere Attributvorgaben als in der DTD verwenden, würde dies zu einer Fehlermeldung beim Parsen des XML-Dokuments führen.   <VERWALTUNG> <DATEN> <NAME>Meier</NAME> </DATEN> <!-- ... --> <DATEN> <NAME anrede=\"Herr\">Meier</NAME> </DATEN> </VERWALTUNG>  In der externen Teilmenge der DTD wurde das Element NAME festgelegt, damit es in dieser Form genutzt werden kann.  In Ihrer XML-Datei möchten Sie jedoch jeden Namen mit einer eindeutigen Anrede als Attribut kenn- zeichnen, sodass Sie zwischen Frau und Herr unterscheiden können. Dazu legen Sie in der internen Definition das Attribut anrede fest. Wenn Sie das vorgestellte Beispiel verwenden, informiert Sie der Parser, dass das Dokument ungültig ist. Er teilt Ihnen mit, dass das Element NAME bereits in der externen DTD festgelegt wurde. Sie möchten jedoch nicht auf das Attribut anrede verzichten. Hochschulversion Namensräume 6 © HERDT-Verlag 57 Zu diesem Zweck wurde am 14. Januar 1999 vom W3-Konsortium die Empfehlung zur Verwendung von so- genannten XML-Namensräumen (engl. XML Namespaces) veröffentlicht. Diese Spezifikation stellt sicher, dass die verwendeten Elementnamen eindeutig gekennzeichnet werden können. Namensräume können über eine URI identifiziert werden, also über eine eindeutige Bezeichnung. Die Angabe einer URI stellt sicher, dass der erstellte Namensraum auch wirklich eindeutig ist, z. B. eine Internetadresse. Diese Datei oder Internetadresse muss nicht existieren, es kann ein beliebiger Fantasiename sein. Hierbei geht es nur um die Eindeutigkeit der Bezeichnung. 6.2 Deklaration von Namensräumen Jeder Namensraum muss deklariert werden, bevor Sie ihn verwenden können. Die Deklaration erfolgt über die Verwendung von reservierten Attributen. Der Attributname muss entweder xmlns (xmlns = XML Name- spaces) lauten oder es muss das Präfix xmlns: (mit dem Doppelpunkt) verwendet werden. Voreingestellter Namensraum als Dateninsel Einen Namensraum, der standardmäßig in einem XML-Dokument verwendet wird, deklarieren Sie über das Attribut xmlns. Dieser wird auch als Dateninsel bezeichnet. <Hauptelement xmlns=\"URI\"> <Element>Daten</Element> <Element /> </Hauptelement> Das Attribut xmlns leitet die Bezeichnung des Namensraums für das Element mit all seinen Unterelementen ein. Die URI stellt die Eindeutigkeit des Namensraums sicher und kann eine beliebige Bezeichnung sein. Beispiel: kap06\\xlmns-html.xml Es wird ein Namensraum angelegt, der im gesamten XML-Dokument gültig ist und daher bei jedem Element angewendet werden kann. Für das Beispiel wird die Festlegung des HTML-Namensraums vorgenommen.    <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <html xmlns=\"http://www.w3.org/TR/REC-html40\"> <body > <title>Namensraum</title> <h2>Namensräume in XML</h2> <img src=\"img/kopf.jpg\" align=\"right\" /> <p align=\"center\">Dies ist ein Absatz mit XML-Daten.</p> <p style=\"color:red;\">Farbiger Absatz.</p> <a href=\"#\">Dies ist ein Hyperlink in einem XML-Dokument.</a> </body> </html>  Für das XML-Dokument wird über das Attribut xmlns der Namensraum voreingestellt. Im Falle von HTML 4.0 sieht das W3-Konsortium die URI http://www.w3.org/TR/REC-html40 vor. Alle Elemente, die zwischen <html> und </html> stehen, gehören damit zum HTML-Namensraum.  Es folgen die einzelnen Elemente, die sich auf den HTML-Namensraum beziehen.  Der Namensraum wird mit dem schließenden Element </html> beendet. Das XML-Dokument ist damit nicht automatisch ein HTML-Dokument, das dementsprechend bei der Anzeige im Browser formatiert wird. Die Elemente gehören nur dem HTML-Namensraum an. Eine URI muss nicht un- bedingt eine tatsächliche Internetadresse sein. Hochschulversion 6 XML 1.1 - Grundlagen 58 © HERDT-Verlag Mehrere Dateninseln Um einen Namensraum nicht für ein gesamtes Dokument, sondern nur für einzelne Elementstrukturen zu definieren, muss er in dem entsprechenden Unterelement vereinbart werden. Er findet dann auch auf die darin geschachtelten Elemente Anwendung. Beispiel: kap06\\xmlns-all.xml Es wird ein Namensraum angelegt, der im gesamten XML-Dokument gültig ist und daher bei jedem Element angewendet werden kann. In einem Unterelement wird ein weiterer Namensraum angelegt.     <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <VERWALTUNG xmlns=\"http://www.irgendeineURI.de\"> <DATEN> <NAME>Meier</NAME> </DATEN> <DATEN xmlns=\"http://www.irgendeineURI.de/mit-anrede\"> <NAME anrede=\"Herr\">Meier</NAME> </DATEN> </VERWALTUNG>  Im Hauptelement VERWALTUNG ist eine Namensraumdeklaration enthalten. Dabei wird zur Eindeutigkeit auf die URI http://www.irgendeineURI.de Bezug genommen.  Das Element DATEN wird mit seinem Unterelement NAME festgelegt.  Für das nächste Element DATEN wird ein neuer Namensraum deklariert, sodass im Unterelement zusätz- lich das Attribut anrede angegeben werden kann, ohne gegen die Gültigkeit des XML-Dokuments zu verstoßen.  Mit dem schließenden Element </DATEN> ist wieder der erste Namensraum aktiv. Namensräume mit qualifizierten Namen Nicht immer ist es sinnvoll, einen Namensraum für mehrere Elemente gleichzeitig festzulegen. Hierfür defi- nieren Sie einen Namensraum mit einem qualifizierten Namen, auch Präfix genannt. Dieses Präfix können Sie innerhalb der umschlossenen Elemente einsetzen, wenn Sie es benötigen. <Hauptelement> <Element xmlns:Präfix=\"URI\"> <Präfix:Unterelement>Daten</Präfix:Unterelement> <Unterelement /> </Element> <-- weitere Elemente --> </Hauptelement> Durch die Einbindung eines Namensraums am Element beziehen sich alle untergeordneten Elemente automa- tisch auf den angegebenen Namensraum. Präfixe sind Teil des Elementnamens und müssen immer an dem jeweiligen Element angegeben werden, um anzuzeigen, dass das Element zu dem entsprechenden Namens- raum gehört. Das Präfix wird immer durch einen Doppelpunkt vom Elementnamen getrennt. : Hochschulversion Namensräume 6 © HERDT-Verlag 59 Beispiel: kap06\\xmlns.xml Es wird ein Namensraum angelegt, der an einem XML-Element definiert wird und somit auch für dessen Unterelemente gültig ist.    <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <VERWALTUNG> <DATEN> <NAME>Meier</NAME> </DATEN> <DATEN xmlns:extra=\"http://www.irgendeineURI.de/mit-anrede\"> <extra:NAME anrede=\"Herr\">Meier</extra:NAME> </DATEN> </VERWALTUNG>  Sie legen einen Namensraum für das Element DATEN und seine untergeordneten Elemente an. Um den Namensraum anzusprechen, erhält er die Bezeichnung extra.  Damit Sie das zusätzliche Attribut anrede anwenden können, notieren Sie das Unterelement NAME mit dem Namensraum extra.  Das Element DATEN wird geschlossen. Damit wird auch der Namensraum extra beendet. Ein möglicher- weise nachfolgendes Element Name kann nicht mehr das Attribut anrede besitzen. Namensraum für ein Element Sie können einen Namensraum auch einmalig verwenden. Dazu geben Sie ihn direkt an dem Element an. Das Element wird mit der Bezeichnung des Namensraums eingeleitet. Innerhalb des Elements wird der Namensraum über die Angabe xmlns definiert. Beachten Sie hierbei, dass beim Schließen des Elements der Namensraum ebenfalls anzugeben ist. <Hauptelement> <Präfix:Element xmlns:Präfix=\"URI\">Daten</Präfix:Element> <Element /> </Hauptelement> Beispiel: kap06\\xmlns-element.xml Es wird ein Namensraum angelegt, der nur für ein bestimmtes Element gültig ist und daher nicht bei anderen Elementen angewendet werden kann.   <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <VERWALTUNG> <DATEN> <NAME>Meier</NAME> </DATEN> <DATEN> <extra:NAME xmlns:extra=\"http://www.irgendeineURI.de/mit-anrede\" anrede=\"Herr\">Meier</extra:NAME> </DATEN> </VERWALTUNG>  Der Namensraum extra wird vor dem Element NAME angegeben. Danach erfolgt die Festlegung des Namensraums mit der Bezeichnung extra.  Das Element NAME wird mit der zusätzlichen Angabe des Namensraums extra wieder geschlossen. Hochschulversion 6 XML 1.1 - Grundlagen 60 © HERDT-Verlag Mehrere Namensräume mit qualifizierten Namen Mehrere Namensräume mit qualifizierten Namen können Sie ebenfalls im Hauptelement eines XML-Doku- ments definieren. Beispiel: kap06\\xmlns-multiple.xml Im XML-Dokument sollen gleichzeitig Elemente mit unterschiedlichen Attributdefinitionen verwendet werden. Die Nutzung können Sie durch zwei verschiedene Namensräume ermöglichen. Die Namensräume werden im Hauptelement des XML-Dokuments deklariert.    <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <standard:VERWALTUNG xmlns:standard=\"http://www.irgendeineURI.de/standard\" xmlns:extra=\"http://www.irgendeineURI.de/extra\"> <standard:DATEN> <standard:NAME>Meier</standard:NAME> </standard:DATEN> <extra:DATEN> <extra:NAME anrede=\"Herr\">Meier</extra:NAME> </extra:DATEN> </standard:VERWALTUNG>  Für das Dokument werden die beiden Namensräume standard und extra mit jeweils verschiedenen URIs festgelegt. Für die eindeutige Nutzung wird jedem Element das entsprechende Präfix vorangestellt.  Das Element DATEN wird mit seinen Unterelementen als Standard-Variante gekennzeichnet.  Dieses Element DATEN wird dem Namensraum extra zugewiesen, und deshalb kann das Element Name z. B. das zusätzliche Attribut anrede enthalten. 6.3 Externe DTD und eigener Namensraum Zur exakten Gültigkeit eines XML-Dokuments ist es notwendig, dass Sie die Definition der Dokumenttypen einbinden, indem Sie auf eine bereits bestehende DTD zugreifen. Damit Sie beispielsweise einem Element eigene, zusätzliche Attribute hinzufügen können, müssen Sie die bestehende Definition überschreiben und das neue Attribut definieren. Dazu müssen Sie einen Namensraum deklarieren. Im nachfolgenden Beispiel binden Sie die DTD für die XML-Struktur einer Mitarbeiterverwaltung ein. Diese Struktur soll so erweitert werden, dass Sie neben dem Namen des Mitarbeiters als Attribut die entsprechende Anrede angeben können. Beispiel: kap06\\verwaltung.dtd Der Inhalt der bisherigen DTD lautet folgendermaßen: <!ELEMENT VERWALTUNG (DATEN+)> <!ELEMENT DATEN (NAME)> <!ELEMENT NAME (#PCDATA)> Hiermit wird die Struktur des XML-Dokuments festgelegt. Dem Element NAME ist standardmäßig kein Attribut anrede zugeordnet. Beispiel: kap06\\xmlns-dtd-falsch.xml Wenn Sie die Datei verwaltung.dtd als externe DTD in Ihr Dokument einbinden, sind Sie gezwungen, die Strukturdefinition einzuhalten. Durch die Angabe des Attributs anrede wird das XML-Dokument aufgrund der DTD ungültig. Hochschulversion Namensräume 6 © HERDT-Verlag 61 <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <!DOCTYPE VERWALTUNG SYSTEM \"verwaltung.dtd\"> <VERWALTUNG> <DATEN> <NAME>Meier</NAME> </DATEN> <DATEN> <NAME anrede=\"Herr\">Meier</NAME> </DATEN> </VERWALTUNG> Wenn Sie die Datei mit dem Programm XMLSPY erfassen, zeigt dieses bei einer Überprüfung mittels XML - XML validieren den Fehler an, dass das Attribut anrede nicht in der DTD definiert ist. Ausgabe, dass ein nicht definiertes Attribut verwendet wurde Im Programm Editix wird der Fehler ebenfalls angezeigt Das Problem kann mit dem Anlegen eines separaten Namensraums umgangen werden. Damit bei einer ein- gebundenen DTD die Definitionen überschrieben werden können, müssen Sie zusätzlich eine interne DTD erstellen. Damit das XML-Dokument gültig ist, müssen Sie den Attributnamen xmlns für den Namensraum in der DTD deklarieren. Hochschulversion 6 XML 1.1 - Grundlagen 62 © HERDT-Verlag Beispiel: kap06\\xmlns-dtd.xml Sie definieren einen Namensraum, der im Element DATEN angewendet werden kann, damit im Unterelement NAME die Angabe des Attributs anrede möglich ist.      <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <!DOCTYPE VERWALTUNG PUBLIC \"//Meine eigene DTD\" \"verwaltung.dtd\" [ <!ATTLIST DATEN xmlns:extra CDATA #FIXED \"http://www.mitanrede.de\"> <!ATTLIST NAME extra:anrede (Herr|Frau) #IMPLIED> ]> <VERWALTUNG> <DATEN> <NAME>Meier</NAME> </DATEN> <DATEN xmlns:extra=\"http://www.mitanrede.de\"> <NAME extra:anrede=\"Herr\">Meier</NAME> </DATEN> </VERWALTUNG>  Über die Anweisung DOCTYPE binden Sie die externe Dokumenttyp-Definition verwaltung.dtd ein. Somit ist die Syntax eines Elements vorgegeben.  Für das Element DATEN legen Sie die Attributliste für den Namensraum extra fest. Der Attributwert kann eine beliebige Zeichenfolge beinhalten (CDATA), die jedoch mit http://www.mitanrede.de fest- gelegt ist (#FIXED).  Dem Element NAME wird über den Namensraum extra das Attribut anrede hinzugefügt. Die Attribut- werte sind mit Herr bzw. Frau vorgegeben. Die Angabe des Attributs ist aber keine Pflicht (#IMPLIED).  Im zweiten Element DATEN geben Sie das Präfix xmlns mit dem Namensraum extra an. Der Namens- raum wird damit für alle weiteren Unterelemente aktiv.  Der Namensraum extra ermöglicht Ihnen damit trotz Nutzung einer vorgegebenen, externen DTD die Angabe des zusätzlichen Attributs anrede. 6.4 Übungen Übung 1: Theoriefragen zu Namensräumen Übungsdatei: -- Ergebnisdatei: kap06\\uebung1-2.html  Erklären Sie, warum das Anlegen eines Namensraums bei der Verwendung mehrerer Doku- menttyp-Definitionen wichtig ist.  Zählen Sie die verschiedenen Arten eines Namensraums auf. Übung 2: Verwenden mehrerer Namensräume Übungsdatei: -- Ergebnisdatei: kap06\\uebung3.xml Fügen Sie im XML-Dokument mit den Seminardaten einen beliebigen Namensraum ein, der es dem Seminarleiter ermöglicht, für die Angabe seines Alters das Attribut alter zu hinter- legen. Diese Angabe soll nicht zwingend vorgeschrieben sein. Hochschulversion Namensräume 6 © HERDT-Verlag 63 Hochschulversion 7 XML 1.1 - Grundlagen 64 © HERDT-Verlag 7 XML Schema In diesem Kapitel erfahren Sie was XML Schema ist wie XML Schema die bisherige DTD ersetzen kann wie Sie einfache Elemente und Attribute definieren welche Einschränkungen der Elementinhalte möglich sind welche verschiedenen Datentypen es gibt Voraussetzungen Kenntnisse des Aufbaus von XML-Dokumenten Kenntnisse in der Anwendung von DTD 7.1 Der Unterschied zwischen Schema und DTD Entwicklung XML Schema Die bisherige Festlegung der möglichen XML-Elemente, Attribute und Inhalte über die Dokumenttyp-Defini- tion (DTD) benutzt eine SGML-verwandte Syntax. Dies hat zur Folge, dass Sie die XML-Instanz in einem ande- ren Format als die Beschreibungsregeln definieren müssen. Außerdem unterstützen die DTDs nur wenige Datentypen. Somit können Sie über eine DTD nicht festlegen, dass der Wert eines bestimmten Attributs nur innerhalb eines definierten Bereichs liegen darf. Bereits im Jahr 1999 wurden Anforderungen zur Modellierung von Schema für XML-Daten veröffentlicht (siehe http://www.w3.org/TR/NOTE-xml-schema-req.html). Seit 2001 gibt es mit der XML Schema Definition Language (XSD), kurz XML Schema, eine Empfehlung des W3-Konsortiums, um die Struktur und den Inhalt eines XML-Dokuments zu beschreiben. Das Erstellen eines Schemas erfolgt über die XML-Syntax. Schema ist somit ein eigenes XML-Dokument. Aufgrund der XML-Struktur werden die Beschreibungsregeln eines XML- Dokuments maschinenlesbar. Mit XML Schema haben Sie Zugriff auf verschiedene Datentypen, wie z. B. date, time, boolean, Float, decimal, hexBinary usw. Zudem können Sie eigene Datentypen erstellen, die auf vorhandenen Datentypen basieren können. Es lassen sich in XML Schema auch Namensräume definieren, damit Elemente mit derselben Bezeichnung in verschiedenen Dokumenten verwendet werden können. Seit Mai 2012 gibt es die Weiterentwicklung XML Schema 1.1. Das Ziel dieser Version ist in erster Linie, Schwachpunkte von XML Schema 1.0 zu beheben. Daneben stehen Änderungen im Mittelpunkt, welche die Erstellung von flexiblen Schemas unterstützen und die Anwendung von XML Schema generell erleichtern. Auf Grund der Abwärtskompatibilität validiert ein Prozessor für die Version 1.1 auch 1.0 Schema Dateien. Allerdings wird zum gegenwärtigen Zeitpunkt XML Schema 1.1 von vielen Tools noch nicht unterstützt. Der Abschnitt 8.5 gibt einen kurzen Überblick über einige Neuerungen in Schema 1.1. Ausführliche Informationen zu XML Schema finden Sie im Internet unter http://www.w3.org/XML/Schema. Die Unterschiede von Schema und DTD Folgende Regeln können festgelegt werden: DTD Schema Syntax eines Elements Attribute eines Elements mögliche Kindelemente Standardwerte und feste Werte für Elemente und Attribute Hochschulversion XML Schema 7 © HERDT-Verlag 65 Folgende Regeln können festgelegt werden: DTD Schema Reihenfolge der Elemente Anzahl der möglichen Elemente Datentyp der Elemente Datentyp der Attribute eigene Datentypen Es stellt sich die Frage, warum XML Schema nicht die DTDs ablöst. Die Schwächen der DTD können auch als deren Stärke angesehen werden. Abgesehen davon, dass für die DTD eine neue Syntax erlernt werden muss, ist diese sehr gut zu überschauen. Die DTD ist daher für nicht kritische Anwendungen attraktiv, bei denen z. B. kein besonderer Wert auf detaillierte Datentypen gelegt werden muss. Die Standardanwendung von XML Schema wird überwiegend der Datenaustausch zwischen Geschäftspartnern (B2B - Business to Business) sowie zwischen Firmen und Kunden (B2C - Busines to Consumer) sein, bei denen eine genaue Definition von Datentypen und Wertebereichen von grundlegender Bedeutung ist. Beispiel: kap07\\start.xml Eine einfache XML-Struktur mit Adressdaten hat beispielsweise den nachfolgenden Inhalt: <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <Adresse> <Name>Herbert Hagedorn</Name> <Strasse>Hasenweg 13</Strasse> <Ort>Frankfurt/Main</Ort> <PLZ>60000</PLZ> </Adresse> Beispiel: kap07\\start.dtd Die entsprechende DTD für die XML-Instanz lautet: <!ELEMENT Adresse (Name, Strasse, Ort, PLZ)> <!ELEMENT Name (#PCDATA)> <!ELEMENT Strasse (#PCDATA)> <!ELEMENT Ort (#PCDATA)> <!ELEMENT PLZ (#PCDATA)> Die erste Zeile legt fest, dass das Element Adresse vier Unterelemente besitzt. Die einzelnen Elemente sind vom Datentyp #PCDATA, also einer beliebigen Zeichenkette. Beispiel: kap07\\start.xsd Das XML Schema für die Daten einer XML-Instanz sieht folgendermaßen aus:    <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:element name=\"Adresse\"> <xs:complexType> <xs:sequence> <xs:element name=\"Name\" type=\"xs:string\" /> <xs:element name=\"Strasse\" type=\"xs:string\" /> <xs:element name=\"Ort\" type=\"xs:string\" /> <xs:element name=\"PLZ\" type=\"xs:integer\" /> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> Hochschulversion 7 XML 1.1 - Grundlagen 66 © HERDT-Verlag  Für die Nutzung von Schema wird der Namensraum xs angelegt.  Das Oberelement Adresse wird als komplexer Typ festgelegt, der eine bestimmte Reihenfolge von Elementen besitzt.  Die vier Unterelemente werden als Sequenz definiert. Drei sind einfache Zeichenketten vom Datentyp string und das Element PLZ ist vom Typ integer. Sie besitzen keine weiteren Unterelemente oder Attribute. Schema-Definition validieren Die Software Editix unterstützt Sie auch bei der Überprüfung von Schema-Definitionen. Wie bei DTD- Beschreibungen können Sie diese über das Menü XML - Check for a well-formed / valid document oder alternativ über S k überprüfen lassen. Im Internet können Sie ebenfalls eine Vielzahl kostenloser Angebote zum Testen einzelner XML Schemata nut- zen, z. B. das Angebot der Firma CoreFiling (ehemals DecisionSoft). Dieser Validator läuft auf dem Webserver des Anbieters. Zu finden ist das Angebot unter http://www.corefiling.com/opensource/schemaValidate.html. Auch hier geben Sie zur Überprüfung die Schema- sowie die XML-Datei an. Online XML Schema Validator 7.2 Grundlagen zu XML Schema Namensraum von XML Schema Das Element schema ist das Hauptelement eines XML Schemas. Das Element kann folgende Attribute be- inhalten: <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"URI\" targetNamespace=\"URI\" elementFormDefault=\"qualified|unqualified\" attributeFormDefault=\"qualified|unqualified\"> ... </xs:schema> Das Attribut xmlns:xs besagt, dass die Elemente und Datentypen, die in diesem Schema genutzt wer- den, aus dem Namensraum http://www.w3.org/2001/XMLSchema kommen. Es legt auch fest, dass die Elemente und Datentypen dieses Namensraums mit dem Präfix xs: gekennzeichnet werden müs- sen. Das Präfix kann von Ihnen beliebig benannt werden. Mit xmlns=\"URI\" geben Sie den standard- mäßig zu verwendenden Namensraum an. Über das Attribut targetNamespace=\"URI\" können Sie festlegen, in welchem Namensraum sich die Elemente in der XML-Instanz befinden müssen, damit die nachfolgende Definition angewendet wird. Ob jedem Element und jedem Attribut das Namensraum-Präfix vorangestellt werden muss, können Sie über die optionalen Attribute elementFormDefault und attributeFormDefault angeben. Stan- dardmäßig ist jeweils der Wert unqualified eingestellt, sodass das Präfix nicht angegeben werden muss. Mit qualified erzwingen Sie einen qualifizierten Namen, also das Voranstellen des Präfixes. Hochschulversion XML Schema 7 © HERDT-Verlag 67 Schema-Datei mit XML-Dokument verknüpfen <Hauptelement xmlns=\"URI\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"Namensraum Schema-Datei\"> ... </Hauptelement> In einer XML-Datei definieren Sie mit dem Attribut xmlns einen standardmäßigen Namensraum, dem alle Elemente des Dokuments angehören, denen kein Präfix vorangestellt ist. Außerdem wird der Na- mensraum xsi für die XML-Schema-Instanz angegeben. Genau wie das Präfix xs für das XML Schema hat sich hierfür die Angabe von xsi durchgesetzt. Das Attribut schemaLocation mit dem vorangestellten Namensraum besitzt einen Wert, der aus zwei Teilen besteht. Sie geben damit dem Parser einen Hinweis, wo er für den angegebenen Namensraum eine geeignete Schema-Datei finden kann. Der Parser ist jedoch nicht unbedingt an diese Schema- Datei gebunden. Die Schema-Datei besitzt entsprechend der Konvention immer den Dateityp .xsd. Verwenden Sie in Ihrem XML-Dokument keinen Namensraum, haben Sie die Möglichkeit, die Schema-Datei über das Attribut xsi:noNamespaceSchemaLocation einzubinden. Als Wert wird nur die absolute oder relative Angabe der Schema-Datei erwartet. Die Angabe von xsi:schemaLocation entfällt dement- sprechend. <Hauptelement xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"Schema-Datei\"> ... </Hauptelement> Beispiel: kap07\\adresse-start.xml Die Einbindung der bereits erstellten Schema-Datei start.xsd erfolgt über die Angabe des entsprechenden Namensraums.      <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <Adresse xmlns=\"http://www.herdt.com\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.herdt.com start.xsd\"> <Name>Herbert Hagedorn</Name> <Strasse>Hasenweg 13</Strasse> <Ort>Frankfurt/Main</Ort> <PLZ>60000</PLZ> </Adresse>  Die Angaben zur einzubindenden Schema-Datei erfolgen hinter dem Hauptelement der XML-Instanz.  Zuerst wird der Standard-Namensraum für das gesamte Dokument festgelegt. Hier ist es der Namens- raum http://www.herdt.com.  Der Namensraum der XML-Instanz wird über die angegebene URI definiert. Das Präfix xsi steht für die XML-Schema-Instanz und kann von Ihnen beliebig benannt werden.  Für den Namensraum xsi wird die Schema-Datei start.xsd empfohlen, die über das Schlüsselwort schemaLocation angegeben wird.  Es folgen die Elemente der XML-Instanz. Öffnen Sie das XML-Dokument im Browser. Der Browser prüft das Dokument nur auf Wohlgeformtheit. Mögliche Fehler in der Schema-Datei werden Ihnen nicht angezeigt. Somit können Sie nicht mit hundertprozentiger Sicherheit sagen, dass die XML-Datei korrekt (valid) ist. Hierfür benötigen Sie die bereits erwähnten Parser, die XML Schema verarbeiten und aus- werten können. Hochschulversion 7 XML 1.1 - Grundlagen 68 © HERDT-Verlag 7.3 Schema-Grundgerüst Bevor Sie die einfachen oder komplexen Elemente, die Attributangaben, die möglichen Datentypen und die Möglichkeiten zur Einschränkung von Daten kennenlernen, erhalten Sie einen Einblick in die bisherige Dokumenttyp-Definition und Sie erfahren, wie diese Definition jetzt über Schema realisiert wird. Beispiel: kap07\\abfolge.xsd Das folgende Beispiel zeigt Ihnen die grundlegenden Elemente des Schemas, die bei einer Definition erwartet werden.          <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:element name=\"Hauptelement\"> <xs:complexType> <xs:sequence> <xs:element name=\"Unterelement1\" /> <xs:element name=\"Unterelement2\" /> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> , Das Attribut xmlns des Elements schema legt über das Präfix xs den Namensraum der Elemente fest. Mit der Zeit haben sich die Abkürzungen xs: bzw. xsd: als Standardangabe durchgesetzt. , Mit dem Element element hinterlegen Sie den Namen des möglichen Elements, das im XML-Doku- ment erwartet wird. , Die Angabe weiterer Unterelemente wird als komplexer Typ angesehen und deshalb mit dem Element complexType eingeleitet. , Wenn sich mehrere Elemente unterhalb eines Elements befinden können, werden diese über das Element sequence eingeleitet. Damit geben Sie an, dass die nachfolgenden Elemente in der angegebenen Reihenfolge auftreten müssen.  Analog zu Punkt  geben Sie über element name die Namen der untergeordneten Elemente an. Mit diesem Beispiel haben Sie eine Struktur definiert, mit der in einem XML-Dokument das Element Haupt- element mit den beiden Unterelementen Unterelement1 und Unterelement2 erwartet wird. Beispiel: kap07\\bestell.xml Ein Warenkorbsystem einer beliebigen Webseite im Internet generiert zum Beispiel die nachfolgenden Bestell-Informationen in Form einer XML-Datei. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <Bestellung bestelldatum=\"2014-09-27\"> <Adresse> <Name>Herbert Hagedorn</Name> <Strasse>Hasenweg 13</Strasse> <Ort>Frankfurt/Main</Ort> <PLZ>60000</PLZ> </Adresse> <Ware> <Buch BestellNr=\"3453865219\"> <Titel>Wolfsmond. Der dunkle Turm.</Titel> <Autor>Stephen King</Autor> <Anzahl>1</Anzahl> <PreisEUR>15.00</PreisEUR> </Buch> </Ware> </Bestellung> Hochschulversion XML Schema 7 © HERDT-Verlag 69 Beispiel: kap07\\bestell.dtd Eine DTD, die diese Struktur beschreibt, könnte beispielsweise so aussehen: <!ELEMENT Bestellung (Adresse, Ware)> <!ATTLIST Bestellung bestelldatum CDATA #REQUIRED> <!ELEMENT Adresse (Name, Strasse, Ort, PLZ)> <!ELEMENT Name (#PCDATA)> <!ELEMENT Strasse (#PCDATA)> <!ELEMENT Ort (#PCDATA)> <!ELEMENT PLZ (#PCDATA)> <!ELEMENT Ware (Buch+)> <!ELEMENT Buch (Titel, Autor, Anzahl, PreisEUR)> <!ATTLIST Buch BestellNr CDATA #REQUIRED> <!ELEMENT Titel (#PCDATA)> <!ELEMENT Autor (#PCDATA)> <!ELEMENT Anzahl (#PCDATA)> <!ELEMENT PreisEUR (#PCDATA)> Mit dieser Definition ist die grundlegende Struktur der XML-Datei festgelegt. Sie haben jedoch keine Möglichkeit, Einfluss auf die angegebenen Werte zu nehmen. So können Sie z. B. über eine DTD nicht sicherstellen, dass das Datum immer im richtigen Format jjjj-mm-tt (Jahr, Monat, Tag) an- gegeben wird. Theoretisch könnte auch das Datum 27.09.2014 angegeben werden. Der Parser kann dies nicht unterscheiden. Außerdem soll in diesem Beispiel das Aussehen einer Bestellnummer standardisiert sein. Solch eine Nummer muss aus zehn Ziffern bestehen. Die richtige Angabe der Bestellnummer ist mit dieser DTD auch nicht sichergestellt. Mit XML Schema können Sie diese Vorschriften definieren. Sie können sogar festlegen, dass pro Bestellung nur eine maximale Anzahl an Büchern möglich sein soll. Dies können Sie dann mithilfe eines Validators prüfen. Beispiel: kap07\\bestell.xsd Die DTD wird in das XML-Schema konvertiert und die angegebenen Bedingungen bezüglich Datum und Bestellnummer werden hinzugefügt.       <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:element name=\"Bestellung\"> <xs:complexType> <xs:sequence> <xs:element name=\"Adresse\" type=\"BestellAdresse\" /> <xs:element name=\"Ware\" type=\"WarenTyp\" /> </xs:sequence> <xs:attribute name=\"bestelldatum\" type=\"xs:date\" /> </xs:complexType> </xs:element> <xs:complexType name=\"BestellAdresse\"> <xs:sequence> <xs:element name=\"Name\" type=\"xs:string\" /> <xs:element name=\"Strasse\" type=\"xs:string\" /> <xs:element name=\"Ort\" type=\"xs:string\" /> <xs:element name=\"PLZ\" type=\"xs:integer\" /> </xs:sequence> </xs:complexType> <xs:complexType name=\"WarenTyp\"> <xs:sequence> <xs:element name=\"Buch\" minOccurs=\"0\" maxOccurs=\"unbounded\"> <xs:complexType> Hochschulversion 7 XML 1.1 - Grundlagen 70 © HERDT-Verlag      <xs:sequence> <xs:element name=\"Titel\" type=\"xs:string\" /> <xs:element name=\"Autor\" type=\"xs:string\" /> <xs:element name=\"Anzahl\"> <xs:simpleType> <xs:restriction base=\"xs:positiveInteger\"> <xs:maxInclusive value=\"10\" /> </xs:restriction> </xs:simpleType> </xs:element> <xs:element name=\"PreisEUR\" type=\"xs:decimal\" /> </xs:sequence> <xs:attribute name=\"BestellNr\" type=\"BestellNrTyp\" use=\"required\" /> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> <xs:simpleType name=\"BestellNrTyp\"> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"\\d{10}\" /> </xs:restriction> </xs:simpleType> </xs:schema>  Jedes Element hat das Präfix xs:, das über xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" mit dem XML Schema Namensraum assoziiert wird.  Es wird das Hauptelement Bestellung definiert.  Dieses besitzt eine Folge von weiteren Elementen (Sequence). Die Elemente Adresse und Ware sind von einem selbstdefinierten Datentyp.  Das Attribut bestelldatum, das dem Element Bestellung zugeordnet wird, ist vom Datentyp date und wird somit als Datum betrachtet.  Der eigene Datentyp BestellAdresse wird definiert. Dieser besteht aus einer Reihe von weiteren Ele- menten, wobei deren Reihenfolge durch sequence vorgegeben wird.  Im eigenen Datentyp WarenTyp wird über das Attribut maxOccurs festgelegt, dass das Element Buch in der XML-Struktur mehrmals vorkommen kann.  Für das Element Anzahl wird über das Element restriction eine positive Ganzzahl definiert, die maximal den Wert 10 haben kann.  Der Preis des Buches wird über den dezimalen Datentyp für das Element PreisEUR festgelegt.  Ein Buch muss das Attribut BestellNr besitzen, das dem Datentyp BestellNrTyp entspricht.  Wie der Datentyp BestellNrTyp aufgebaut ist, wird hier festgelegt.  Über das Element pattern und den regulären Ausdruck wird die notwendige Form der Bestellnummer festgelegt. In diesem Fall wird eine 10-stellige Zahl erwartet. 7.4 Einfache Typen Einfache Elemente Ein einfaches Element ist ein XML-Element, das keine weiteren Attribute und Elemente enthalten kann. Der Inhalt des Elements kann von einem beliebigen Datentyp sein, z. B. boolean, string, integer, date usw. <xs:element name=\"Elementname\" type=\"xs:Typ\" default=\"Wert\" fixed=\"Wert\" /> Ein einfaches Element definieren Sie über die Angabe des Elements xs:element und das Attribut name. Den Datentyp, aus dem der Inhalt des Elements bestehen muss, legen Sie über das Attribut type fest. Die meist- genutzten Datentypen sind: Hochschulversion XML Schema 7 © HERDT-Verlag 71 xs:string für Zeichenketten, z. B. \"Schema ist recht umfangreich\" xs:decimal für Dezimalzahlen, z. B. 1.4, 3.14, -456.78901 xs:integer für Ganzzahlen, z. B. 1, -2, 456, 1000 xs:boolean für die Wahrheitswerte true oder false xs:date für englischsprachig formatierte Datumsangaben, z. B. 2014-09-27 oder 14-09-27 xs:time für Zeitangaben, z. B. 11:37:52, 11:37:52+01:00 Über das Element-Attribut default können Sie einen Standardwert des Elements festlegen, der automatisch eingesetzt werden soll, wenn der Wert in der XML-Instanz nicht angegeben wird. Mit fixed können Sie sogar bestimmen, dass nur dieser bestimmte Wert eingesetzt werden soll und sonst kein anderer. Beispiel <xs:element name=\"Name\" type=\"xs:string\" /> <xs:element name=\"PLZ\" type=\"xs:integer\" /> <xs:element name=\"Land\" type=\"xs:string\" default=\"Deutschland\" /> <xs:element name=\"Geburtstag\" type=\"xs:date\" /> <xs:element name=\"Alter\" type=\"xs:integer\" /> Das Element Name wird als Zeichenkette und PLZ als Zahl erwartet. Das Element Land ist ebenfalls eine Zeichenkette, wobei der Wert Deutschland automatisch eingesetzt wird, wenn im XML-Dokument kein Ele- mentwert angegeben wird. Der Geburtstag kann nur als Datum angegeben werden, wobei die englische Schreibweise zu beachten ist. Für das Element Alter muss eine Ganzzahl angegeben werden. Attribute Einfache Elemente können keine Attribute besitzen. Soll ein Element ein Attribut erhalten, so muss es ein komplexes Element sein. Das Attribut selbst wird innerhalb des komplexen Elements als einfaches Element deklariert. Die Syntax für die Festlegung eines Attributs lautet: <xs:attribute name=\"Attributname\" type=\"xs:Datentyp\" default=\"Wert\" fixed=\"Wert\" use=\"required|optional|prohibited\" /> Den Namen des Attributs legen Sie über das Schlüsselwort name fest. Der Datentyp wird, wie beim ein- fachen Element, über type angegeben. Für die Werte von default und fixed gilt dasselbe wie bei den einfachen Elementen. Zusätzlich gibt es das Schlüsselwort use, mit dem Sie festlegen können, ob das Attribut des Elements angegeben werden muss. Mögliche Werte sind required (Pflicht), optional (wahlweise) bzw. prohibited (verboten). Die Definition von Attributen darf in Schema-Dateien nur am Ende eines komplexen Elements, direkt vor dem schließenden Tag </xs:element>, angegeben werden. Beispiel Dies ist ein Element mit einem Attribut, das den Namen bezüglich des Geschlechts der Person näher be- schreibt. <Name geschlecht=\"w\">Ulli Werner</Name> Die mögliche Attributdefinition dazu lautet: <xs:attribute name=\"geschlecht\" type=\"xs:string\" use=\"required\" /> Hochschulversion 7 XML 1.1 - Grundlagen 72 © HERDT-Verlag Elemente einschränken Die Einschränkungen (engl. Restrictions) werden genutzt, um für XML-Elemente und Attribute spezielle Werte vorzuschreiben bzw. die Auswahl einzuengen. Einschränkungen an XML-Elementen werden Fassetten (engl. Facets) genannt. Die Festlegungen werden vom Element restriction umschlossen. <xs:restriction base=\"Datentyp\"> Mit dem Attribut base legen Sie den Datentyp fest, von dem das Element abgeleitet werden soll. Wenn das Element eine bestimmte Ganzzahl enthalten soll, dann erbt es die Haupteigenschaften des Datentyps Integer. Eine bestimmte Zeichenkette wird grundlegend vom Datentyp String abgeleitet. Einschränkung auf Wertebereiche <xs:restriction base=\"Datentyp\"> <xs:minInclusive value=\"Wert\" /> <!-- angegebener Wert inklusive --> <xs:maxInclusive value=\"Wert\" /> </xs:restriction> <xs:restriction base=\"Datentyp\"> <xs:minExclusive value=\"Wert\" /> <!-- Wert nicht inklusive --> <xs:maxExclusive value=\"Wert\" /> </xs:restriction> Innerhalb der Festlegung restriction definieren Sie den Wertebereich des Elements. Beim Verwenden von minInclusive und maxInclusive gehören die angegebenen Werte mit zu dem möglichen Bereich, wo- gegen bei minExclusive und maxExclusive die Werte ausgeschlossen werden. Beispiel: kap07\\alter.xsd In einer XML-Datei sind zu den möglichen Personenangaben auch Angaben zum Alter enthalten. Menschen können nicht jünger als 0 Jahre sein und in den seltensten Fällen älter als 120 werden. Also soll z. B. ein Element Alter nur ganze Zahlen zwischen 0 und 120 enthalten.      <xs:element name=\"Alter\"> <xs:simpleType> <xs:restriction base=\"xs:integer\"> <xs:minInclusive value=\"0\" /> <xs:maxInclusive value=\"120\" /> </xs:restriction> </xs:simpleType> </xs:element>  Das Element Alter, dessen Inhalte eingeschränkt werden sollen, umschließt die gesamte Definition.  Da das Element keine weiteren Elemente oder Attribute enthält, ist es vom einfachen Typ und wird dementsprechend mit simpleType gekennzeichnet.  Mit restriction leiten Sie die Einschränkung ein und legen fest, dass der Inhalt vom Datentyp integer abgeleitet wird.  Das Element minInclusive beschreibt den unteren Wert, wobei der angegebene Wert ebenfalls mög- lich ist (inklusive).  Mit maxInclusive legen Sie den oberen Wert fest. Einschränkung auf Werte <xs:restriction base=\"Datentyp\"> <xs:enumeration value=\"Wert1\" /> <xs:enumeration value=\"Wert2\" /> </xs:restriction> Hochschulversion XML Schema 7 © HERDT-Verlag 73 Mit dem Element enumeration legen Sie mögliche Elementinhalte fest. Die Werte sind Zeichenketten, wel- che die mögliche Auswahl darstellen. Beispiel: kap07\\land.xsd Bei Länderangaben möchten Sie z. B. sichergehen, dass die Inhalte nur die Länder beinhalten, in denen Deutsch gesprochen wird. Dann geben Sie die Zeichenketten vor, die verwendet werden dürfen.    <xs:element name=\"Land\"> <xs:simpleType> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"Deutschland\" /> <xs:enumeration value=\"Österreich\" /> <xs:enumeration value=\"Schweiz\" /> </xs:restriction> </xs:simpleType> </xs:element>  Die folgende Einschränkung bezieht sich auf das Element Land.  Die Elementwerte sind vom Datentyp string, also Zeichenketten.  Die möglichen Elementinhalte, die in einer XML-Instanz vorkommen können, werden mit dem Element enumeration über die Angabe von value einzeln aufgelistet. Einschränkung auf eine Serie von Werten <xs:restriction base=\"Datentyp\"> <xs:pattern value=\"Wert1\" /> </xs:restriction> Das Element pattern erlaubt es Ihnen, über festgelegte Muster die zulässigen Werte eines Datentyps einzu- schränken. Die Muster werden über sogenannte regular Expressions oder reguläre Ausdrücke definiert. Für einen kompakten Einstieg in das komplexe Thema der regulären Ausdrücke ist der Wikipedia-Artikel http://de.wikipedia.org/wiki/Regulärer_Ausdruck zu empfehlen. Als Beispiel folgt eine Auflistung verschiedener regulärer Ausdrücke und deren mögliche Ergebnismengen. <xs:pattern value=\"...\"> Ergebnis [0-9] Eine einstellige Zahl zwischen 0 und 9 [0-9][0-9] Eine zweistellige Zahl wie 11, 52 oder 99 [a-f] Ein Kleinbuchstabe, entweder a, b, c, d, e oder f [xyz] Einer von den drei Kleinbuchstaben, entweder x, y oder z [a-zA-Z][0-9][a-zA-Z] Eine dreistellige Buchstaben- und Ziffernkombination wie a1b, F9E ([a-z])* Wörter mit einer beliebigen Anzahl von Kleinbuchstaben, auch keine Angabe ist möglich ([a-zA-Z])+ Wörter mit einer beliebigen Anzahl von Buchstaben, aber mindestens einem Buchstaben Herr|Frau Entweder das Wort \"Herr\" oder \"Frau\" [a-zA-Z0-9]{10} Angabe eines 10-stelligen Wortes, das aus Klein- und Großbuchstaben sowie aus Zahlen bestehen kann, z. B. ein 10-stelliges Passwort Hochschulversion 7 XML 1.1 - Grundlagen 74 © HERDT-Verlag Beispiel: kap07\\bestellnummer.xsd In einer XML-Datei sollen die Artikelnummern von Produkten hinterlegt werden. Artikelnummern haben bei vielen Firmen eine festgelegte Struktur, z. B. 123-C-45. Die möglichen Werte werden über reguläre Ausdrücke festgelegt.     <xs:element name=\"Bestellnummer\" type=\"BestellnummerTyp\" /> <xs:simpleType name=\"BestellnummerTyp\"> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"1[0-9][0-9]-[A-E]-[0-9][0-9]\" /> </xs:restriction> </xs:simpleType>  Das Element Bestellnummer umschließt die Festlegung nicht. Der Typ wird direkt über das Attribut type zugewiesen. Der Typ BestellnummerTyp wird nachfolgend festgelegt.  Über die Angabe des Attributs name legen Sie fest, auf welchen Typ sich die nachfolgende Definition bezieht. Hier wird über die Angabe von BestellnummerTyp die Einschränkung des Elements Bestell- nummer festgelegt. Der Datentyp kann auch für weitere Elemente verwendet werden.  Die Werte sind vom Datentyp string, also Zeichenketten.  Der mögliche Elementinhalt wird über das Element pattern definiert. Jedes einzelne Feld legt fest, welche Zeichen an dieser Stelle stehen dürfen. Es wird festgelegt, dass als erstes Zeichen eine 1 stehen muss, danach darf ein Zeichen folgen, das eine Zahl zwischen 0 und 9 ist [0-9]; ebenso an der dritten Stelle. Dann muss ein Bindestrich gesetzt sein, gefolgt von einem der Zeichen A, B, C, D oder E. Zum Schluss müssen wieder zwei Ziffern stehen, denen auch ein Bindestrich vorangestellt ist. Diese Fest- legung erlaubt beispielsweise die folgenden Bestellnummern: 123-C-45 oder 195-A-11 oder 111-D-00. Einschränkung nicht druckbarer Zeichen <xs:restriction base=\"Datentyp\"> <xs:whitespace value=\"preserve|replace|collapse\" /> </xs:restriction> Mit dieser Einschränkung können Sie die nicht druckbaren Zeichen (engl. whitespaces) beeinflussen. Mit nicht druckbaren Zeichen sind Tabulatoren, Leerzeichen, Zeilenumbrüche und -vorschübe gemeint. Das Schlüssel- wort hierfür lautet whitespace mit einem der drei Werte preserve (keine Veränderung), replace (Zeichen werden durch Leerzeichen ersetzt) und collapse. Der letzte Wert hat dieselbe Wirkung wie replace, nur dass zusätzlich noch mehrfache Leerzeichen zu einem Leerzeichen zusammengefasst werden und am Anfang und am Ende des Elementinhalts entfernt werden. Einschränkung der Länge einer Zeichenkette <xs:restriction base=\"Datentyp\"> <xs:length value=\"Längenangabe\" /> </xs:restriction> <xs:restriction base=\"Datentyp\"> <xs:minLength value=\"Längenangabe\" /> <xs:maxLength value=\"Längenangabe\" /> </xs:restriction> Die Länge eines Elementwertes legen Sie über length fest. Dann muss der Wert die angegebene Anzahl Zei- chen aufweisen. Einen variablen Bereich von Zeichenlängen definieren Sie mit minLength (Mindestlänge) und maxLength (Maximallänge). Geben Sie nur maxLength an, hat minLength automatisch den Wert 0. Beim fehlenden Element maxLength muss zwar die Zeichenanzahl mindestens minLength sein, hat aber keine maximale Begrenzung. Die Angabe von length ist nur bei Daten vom Typ string möglich. Bei Daten vom Typ integer oder decimal schränken Sie den Bereich über minExclusive und maxExclusive ein. Hochschulversion XML Schema 7 © HERDT-Verlag 75 Beispiel: kap07\\plz-vorwahl.xsd Wenn Adressdaten in einer XML-Datei gesichert werden, wird auch die Postleitzahl angegeben. In Deutsch- land besteht die Postleitzahl grundsätzlich aus fünf Ziffern. Dies können Sie über das Schlüsselwort length festlegen. Soll ein Elementinhalt innerhalb einer minimalen und maximalen Zeichenlänge liegen, so wird dies über minLength und maxLength definiert. Ein Beispiel dafür sind Telefon-Vorwahlnummern, wie 030 für Berlin oder 06221 für Heidelberg.     <xs:element name=\"PLZ\" type=\"PLZTyp\" /> <xs:simpleType name=\"PLZTyp\"> <xs:restriction base=\"xs:string\"> <xs:length value=\"5\" /> </xs:restriction> </xs:simpleType> <xs:element name=\"Vorwahl\"> <xs:simpleType> <xs:restriction base=\"xs:string\"> <xs:minLength value=\"3\" /> <xs:maxLength value=\"5\" /> </xs:restriction> </xs:simpleType> </xs:element>  Für das Element PLZ wird der Typ PLZTyp festgelegt.  Dieser Typ ist in diesem Beispiel vom Datentyp string.  Der Elementinhalt muss fünf Stellen lang sein. Hier ist die Werteinschränkung auch über einen regulären Ausdruck möglich, wie z. B. <xs:pattern value=\"\\d{5}\" />.  Das Element Vorwahl ist ebenfalls vom Datentyp string. Es hat jedoch mindestens drei Zeichen (minLength) und maximal fünf Zeichen (maxLength) lang zu sein. Auch hier ist die alternative Angabe von <xs:pattern value=\"\\d{3,5}\" /> möglich. Einschränkung der Genauigkeit von Dezimalzahlen <xs:restriction base=\"Datentyp\"> <xs:fractionDigits value=\"Längenangabe\" /> </xs:restriction> <xs:restriction base=\"Datentyp\"> <xs:totalDigits value=\"Längenangabe\" /> </xs:restriction> Des Weiteren gibt es die Einschränkung fractionDigits, mit der Sie die Anzahl der Nachkommastellen von Dezimalzahlen festlegen können. Der Wert muss größer oder gleich 0 sein. Die mögliche Gesamtanzahl eines Wertes bestimmen Sie über totaldigits. Als Wert wird hier eine Zahl größer 0 erwartet. Hochschulversion 7 XML 1.1 - Grundlagen 76 © HERDT-Verlag 7.5 Datentypen Werte von Elementen sind von einem bestimmten Typ, z. B. Ganzzahl, Dezimalzahl, Zeichenkette usw. Diese Typen werden Datentypen genannt. Übersicht von W3.org XML Schema stellt Ihnen standardmäßig eine Vielzahl von Datentypen zur Verfügung. Zusätzlich können Sie eigene Datentypen entwerfen. In diesem Abschnitt werden Ihnen die häufigsten Datentypen näher erläutert. Datentyp string Dieser Datentyp wird für Werte eingesetzt, die aus Zeichenketten bestehen. Dabei gibt es drei Unterschei- dungen: string, normalizedString und token. Folgende Unterschiede weisen diese Datentypen auf: string Enthält Zeichen, Zeilenvorschübe, Zeilenumbrüche und Tabulatoren normalizedString Wie string, wobei der XML-Prozessor die Zeilenvorschübe, Zeilenumbrüche und Tabulatoren automatisch entfernt token Wie normalizedString, wobei der XML-Prozessor zusätzlich führende, anhängen- de und mehrfache Leerzeichen entfernt Hochschulversion XML Schema 7 © HERDT-Verlag 77 Einschränkungen beim Datentyp string Folgende Einschränkungen können beim Datentyp string angewendet werden: enumeration length maxLength, minLength pattern whiteSpace Beispiel <xs:element name=\"Name\" type=\"xs:token\" maxLength=\"100\" /> Das Element Name ist vom Datentyp token, sodass der XML-Prozessor führende, anhängende und mehrfache Leerzeichen aus dem Elementinhalt entfernt. Die Angabe des Attributs maxLength schränkt die Länge des Inhalts auf maximal 100 Zeichen ein. Numerische Datentypen Dieser Datentyp wird eingesetzt, wenn Zahlen als Elementinhalte oder Attributwerte erwartet werden. Grundlegend gibt es zwei numerische Datentypen: die Dezimalzahlen sowie die Ganzzahlen. Der Datentyp decimal ist der allgemeine Datentyp und integer ist davon abgeleitet. Diese beiden Datentypen werden sehr häufig eingesetzt. decimal Festlegung von Fließkommazahlen, z. B. -12,345 oder 3,14 integer Ist die Ableitung von decimal und erlaubt nur ganze Zahlen, z. B. -12 oder 314 Über den Datentyp decimal sind Dezimalzahlen mit einer Genauigkeit von 18 Nachkommastellen möglich. Bei beiden spielt es keine Rolle, ob es positive oder negative Zahlen sind. Der Datentyp integer stellt eine unendlich große Zahl dar. Die Tabelle listet weitere numerische Datentypen auf, die vom Datentyp decimal abgeleitet sind. Name Wertebereich long -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807 unsignedLong 0 bis 18446744073709551615 int -2.147.483.648 bis 2.147.483.647 unsignedInt 0 bis 4294967295 short -32.768 bis 32.767 unsignedShort 0 bis 65535 byte -128 bis 127 unsignedByte 0 bis 255 negativeInteger integer mit negativen Werten (..., -2, -1) positiveInteger integer mit positiven Werten (1, 2, ...) nonNegativeInteger integer mit nicht negativen Werten (0, 1, 2, ...) nonPositiveInteger integer mit nicht positiven Werten (..., -2, -1, 0) Einschränkungen bei numerischen Datentypen Folgende Einschränkungen können bei den numerischen Datentypen angewendet werden: enumeration maxInclusive, minInclusive totalDigits, fractionDigits maxExclusive, minExclusive whiteSpace pattern Hochschulversion 7 XML 1.1 - Grundlagen 78 © HERDT-Verlag Beispiel: kap07\\numerisch.xsd    <xs:element name=\"Preis\"> <xs:simpleType> <xs:restriction base=\"xs:decimal\"> <xs:fractionDigits value=\"2\" /> </xs:restriction> </xs:simpleType> </xs:element> <xs:element name=\"Anzahl\" type=\"xs:nonNegativeInteger\" /> <xs:element name=\"Grad\"> <xs:simpleType> <xs:restriction base=\"xs:decimal\"> <xs:fractionDigits value=\"1\" /> <xs:minInclusive value=\"-90.0\" /> <xs:maxInclusive value=\"60.0\" /> </xs:restriction> </xs:simpleType> </xs:element>  Das Element Preis darf als Inhalt nur eine Dezimalzahl aufweisen. Die Genauigkeit der Zahl ist durch das Attribut fractionDigits auf zwei Nachkommastellen festgelegt.  Das Element Anzahl ist vom Typ nonNegativeInteger und darf positive Ganzzahlen, auch Null, ent- halten.  Die aktuelle Lufttemperatur soll im Element Grad festgehalten werden. Die Genauigkeit der Angabe wird auf eine Nachkommastelle festgelegt. Größere Angaben als 60.0°C für die Maximaltemperatur und weniger als -90.0°C für die Minimaltemperatur sind nicht zulässig. Zum Vergleich: Die höchste Luft- temperatur, die jemals gemessen wurde, liegt bei 57.8°C (1922 in Libyen) und die niedrigste bei -89.2°C (1983 in der Antarktis). Kalendarische Datentypen Für die Angabe einer Zeit, eines Datums oder einer bestimmten Zeitspanne werden die kalendarischen Daten- typen genutzt. Datum Datumsangaben werden über den Datentyp date realisiert, wobei die Schreibweise in der Form JJJJ-MM-TT fest vorgegeben ist. Das bedeutet, dass bei Datumsangaben zuerst die vierstellige Jahreszahl, dann die zwei- stellige Monatszahl und zum Schluss der Tag in der zweistelligen Form anzugeben ist. Diese Angaben sind jeweils durch einen Bindestrich voneinander zu trennen. Beispiel Mit der Elementdefinition von <xs:element name=\"Bestelldatum\" type=\"xs:date\" /> ist die folgende Datumsangabe möglich: <Bestelldatum>2014-09-27</Bestelldatum> Eine zusätzliche Angabe der Zeitzone ist ebenfalls möglich. Dazu wird nach dem Datum der Zeitunterschied zur Greenwich-Zeit (GMT) angegeben. Eine mitteleuropäische Zeitangabe erfolgt somit wie im Beispiel. <Bestelldatum>2014-09-27-01:00</Bestelldatum> Hochschulversion XML Schema 7 © HERDT-Verlag 79 Uhrzeit Zeitangaben sind über den Datentyp time festgelegt. Hier muss die Schreibweise im Format hh:mm:ss erfol- gen, mit der zweistelligen Stundenangabe, gefolgt von den Minuten und den Sekunden. Alle Angaben sind Pflicht. Beispiel Mit der Festlegung von <xs:element name=\"Uhrzeit\" type=\"xs:time\" /> ist die folgende Zeitangabe möglich: <Uhrzeit>11:34:02-01:00</Uhrzeit> Auch hier kann, wie bei der Datumsangabe, die Abweichung zur Greenwich-Zeit (GMT) angegeben werden. Zeitraum Über den Datentyp duration haben Sie die Möglichkeit, Zeitintervalle anzugeben. Das Intervall wird über die Form PnYnMnDTnHnMnS festgelegt. P steht für Periode und muss immer angegeben werden. n ist der Platzhalter für den jeweiligen Wert, den Sie angeben können. Y, M, D stehen für die Datumsangaben Jahr, Monat, Tag. T kennzeichnet den Beginn der Zeitangabe und muss immer angegeben werden, sobald Sie eine Zeit festlegen möchten. H, M, S stehen für die Zeitangaben Stunde, Minute, Sekunde. Durch das Voransetzen eines Minus-Zeichens sind auch negative Zeitintervalle möglich. So bedeutet z. B. -P30D die Intervallangabe „vor 30 Tagen“. Einschränkungen Folgende Einschränkungen können bei den kalendarischen Datentypen angewendet werden: enumeration maxInclusive, minInclusive pattern maxExclusive, minExclusive Beispiel Mit der Festlegung des Datentyps duration <xs:element name=\"Periode\" type=\"xs:duration\" /> kann das Element Periode folgende Inhalte besitzen: <Periode>P1Y2M3D</Periode> <!-- in einem Jahr, zwei Monaten, drei Tagen --> <Periode>PT10H20M30S</Periode> <!-- in zehn Stunden, 20 Minuten, 30 Sekunden --> <Periode>P3D10H</Periode> <!-- in drei Tagen, zehn Stunden --> <Periode>-PT30M</Periode> <!-- vor 30 Minuten --> <Periode>-P30M</Periode> <!-- im Gegensatz dazu: vor 30 Monaten --> Hochschulversion 7 XML 1.1 - Grundlagen 80 © HERDT-Verlag Zusammenfassung Name Wertebereich time Uhrzeit, die täglich wiederkehrt (09:56:12.000) date Datumsformat JJJJ-MM-TT gemäß ISO 8601 (2014-09-27) dateTime Datum und Uhrzeit (2014-09-27T09:56:12.000+01:00) gDay Tag eines Monats über ----TT (----27) gMonth Monatsformat --MM-- (--09--) gYear Jahreszahl (2014) gYearMonth Monat eines bestimmten Jahres über JJJJ-MM (2014-09) duration Zeitraumangabe (-P1DT12H = vor einem Tag und 12 Stunden) Weitere Datentypen Andere Datentypen sind base64Binary, hexBinary, float, double, language, QName und NOTATION. Mit der Version 1.1 von XML Schema (vgl. Abschnitt 8.5) wurden weitere Datentypen eingeführt, so zum Beispiel anyAtomicType (als Basisytp aller einfachen und unteilbaren Datentypen) und yearMonthDuration sowie dayTimeDuration (Ableitungen von duration). Zwei weitere interessante Datentypen, boolean und anyURI, sollen im Folgenden näher beschrieben werden. boolean Dieser Datentyp kann nur zwei Wahrheitswerte annehmen: wahr oder falsch. Mögliche Werte sind true oder 1 bzw. false oder 0. Boolean wird sehr oft zur Datentypfestlegung bei Attributen genutzt. <xs:attribute name=\"aktiv\" type=\"xs:boolean\" /> Das entsprechende Element kann folgendermaßen festgelegt sein: <Sportler aktiv=\"true\">Fabian Hambüchen</Sportler> <Sportler aktiv=\"0\">Stefanie Maria Graf</Sportler> Mit dem Element Sportler werden die Namen von Sportlern gekennzeichnet. Das Attribut aktiv beschreibt, ob der entsprechende Sportler noch aktiv tätig ist. anyURI Über diesen Datentyp können Sie die richtige Verwendung von Internetadressen und lokalen Adressen sicher- stellen. <xs:attribute name=\"src\" type=\"xs:anyURI\" /> Mit dieser Festlegung können Sie Elementen das Attribut src zuweisen, um beispielweise Angaben zu den dazugehörigen Bildern zu hinterlegen. <img src=\"http://www.example.com/bild.gif\" /> <img src=\"images/bild.gif\" /> <img src=\"file://web/ein%20bild.gif\" /> Sie sollten beachten, dass eventuelle Leerzeichen in Internetadressen durch die Zeichenkette %20 ersetzt werden müssen. Hochschulversion XML Schema 7 © HERDT-Verlag 81 Hochschulversion 8 XML 1.1 - Grundlagen 82 © HERDT-Verlag 8 Komplexe Elemente in Schema In diesem Kapitel erfahren Sie wie komplexe Elemente definiert werden wie Sie die unterschiedlichen Elementinhalte festlegen welchen Einfluss die Indikatoren auf komplexe Elemente haben 8.1 Was ist ein komplexes Element? Die bisher behandelten einfachen Elemente dürfen keine weiteren Elemente und auch keine Attribute beinhalten. Wenn ein Element Unterelemente oder Attribute beinhalten soll, muss dieses als komplexes Element definiert werden. Beispiele Das komplexe Element Adresse enthält vier weitere Unterelemente. <Adresse> <Name>Herbert Hagedorn</Name> <Strasse>Hasenweg 13</Strasse> <Ort>Frankfurt/Main</Ort> <PLZ>60000</PLZ> </Adresse> Das Element Name besitzt das Attribut kundennr, hat aber keinen Inhalt. Es ist somit ein komplexes, leeres Schema-Element. <Name kundennr=\"123\" /> Besitzt das Element einen Inhalt, spricht man von einem komplexen Element mit Inhalt. <Name kundennr=\"123\"> Herbert Hagedorn </Name> Ein komplexes Element, das ein weiteres Element und zusätzlich einen Inhalt enthält, wird komplexes Element mit gemischtem Inhalt genannt. <Kommentar> Gekauft am <Datum>26.05.2013</Datum>. </Kommentar> 8.2 Definition eines komplexen Elements Komplexe Elemente werden im XML-Schema grundsätzlich über das Element complexType kenntlich gemacht. Dabei gibt es vier verschiedene Arten von komplexen Elementen: leere Elemente; Elemente, die andere einfache oder komplexe Elemente beinhalten dürfen; Elemente, die nur einen Inhalt haben können; Elemente, die Elemente und Text enthalten dürfen. Hochschulversion Komplexe Elemente in Schema 8 © HERDT-Verlag 83 Jedes dieser Elemente kann zusätzlich auch Attribute beinhalten. Komplexe, leere Elemente <xs:element name=\"Elementname\"> <xs:complexType> <xs:attribute name=\"Attributname\" type=\"Datentyp\" /> </xs:complexType> </xs:element> Ein komplexes, leeres Element kann Attribute besitzen, hat jedoch keinen Inhalt. Die Schema-Definition des Beispiels <Name kundennr=\"123\" /> beschränkt sich daher auf die Festlegung des möglichen Attributs kundennr. Beispiel: kap08\\empty.xsd    <xs:element name=\"Name\"> <xs:complexType> <xs:attribute name=\"kundennr\" type=\"xs:positiveInteger\" use=\"required\" /> </xs:complexType> </xs:element>  Das Element, dessen Inhalte eingeschränkt werden sollen, umschließt die gesamte Definition.  Da das Element ein Attribut besitzen soll, muss es ein komplexes Element werden und ist demzufolge über das Element complexType entsprechend auszuweisen.  Das Element Name erhält über das Element attribute das Attribut kundennr, dessen Wert als positive Ganzzahl angegeben werden muss (required). Sie können aber auch das Element complexType mit einem eigenen Namen kennzeichnen. Der komplexe Typ steht damit für weitere Elementdefinitionen zur Verfügung und kann am Element über das Attribut type referenziert werden.   <xs:element name=\"Name\" type=\"NameTyp\" /> <xs:complexType name=\"NameTyp\"> <xs:attribute name=\"kundennr\" type=\"xs:positiveInteger\" use=\"required\" /> </xs:complexType>  Über das Attribut type wird für das Element Name der komplexe Typ NameTyp festgelegt.  Das Element complexType erhält die Bezeichnung NameTyp. Innerhalb dieses Elements wird das ent- sprechende Attribut definiert. Komplexes Element mit Unterelementen Bei diesem Element wird eine Reihenfolge von Unterelementen festgelegt, die in der XML-Instanz erwartet werden. <xs:element name=\"Elementname\"> <xs:complexType> <xs:sequence> <xs:element name=\"Elementname\" type=\"Datentyp\" /> <xs:element name=\"Elementname\" type=\"Datentyp\" /> </xs:sequence> </xs:complexType> </xs:element> Hochschulversion 8 XML 1.1 - Grundlagen 84 © HERDT-Verlag Im folgenden Element Adresse sollen die Elemente Name, Strasse, Ort und PLZ in der festgelegten Reihen- folge angegeben werden. <Adresse> <Name> Herbert Hagedorn </Name> <Strasse>Hasenweg 13</Strasse> <Ort>Frankfurt/Main</Ort> <PLZ>60000</PLZ> </Adresse> Beispiel: kap08\\sequence.xsd Die Schema-Definition für das Element mit weiteren Unterelementen sieht folgendermaßen aus:      <xs:element name=\"Adresse\"> <xs:complexType> <xs:sequence> <xs:element name=\"Name\" type=\"xs:string\" /> <xs:element name=\"Strasse\" type=\"xs:string\" /> <xs:element name=\"Ort\" type=\"xs:string\" /> <xs:element name=\"PLZ\" type=\"PLZTyp\" /> </xs:sequence> </xs:complexType> </xs:element> <xs:simpleType name=\"PLZTyp\"> <xs:restriction base=\"xs:integer\"> <xs:pattern value=\"\\d{5}\" /> </xs:restriction> </xs:simpleType>  Das Element Adresse wird über complexType als komplexes Element angelegt.  Über das Element sequence legen Sie fest, dass die nachfolgenden Elemente in der angegebenen Reihenfolge erscheinen müssen.  Dies bedeutet, dass zuerst das Element Name erwartet wird und dann Strasse, Ort und PLZ.  In diesem Fall ist für das Element PLZ als Datentyp die eigene Definition PLZTyp einzuhalten.  Diese Definition legt fest, dass die Postleitzahl genau fünf Ziffern aufweisen muss. Auch in diesem Beispiel kann das Element Adresse mit einem Typ verknüpft werden, den Sie über das Element complexType namentlich definieren und dessen Inhalt Sie angeben. Komplexes Element mit Inhalt Dieser Elementtyp kann nur einen einfachen Inhalt und Attribute besitzen. Zu diesem Zweck wird bei der Definition das Element simpleContent eingesetzt, mit dem Sie den möglichen Inhalt des komplexen Elements definieren. <xs:element name=\"Elementname\"> <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:Datentyp\"> <xs:attribute name=\"Attributname\" type=\"xs:Datentyp\" /> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element> Hochschulversion Komplexe Elemente in Schema 8 © HERDT-Verlag 85 Über das Element extension haben Sie die Möglichkeit, ein Element, ausgehend von einem vorhandenen Typ, zu erweitern. Mit base legen Sie den Datentyp des Elements fest. Der Attributtyp wird direkt im Element attribute angegeben. Statt ein Element zu erweitern, können Sie es mit dem Element restriction auch einschränken. <Name kundennr=\"123\"> Herbert Hagedorn </Name> In diesem Beispiel stellt das Element ein einfaches Element dar, das eigentlich nur um das Attribut kundennr erweitert wurde. Da jedoch nur komplexe Elemente ein Attribut besitzen können, werden die einfachen Ele- mente als komplexe Elemente mit einem einfachen Inhalt (simpleContent) definiert. In diesem Fall wird das Element um das Attribut kundennr erweitert. Beispiel: kap08\\simplecontent.xsd     <xs:element name=\"Name\"> <xs:complexType> <xs:simpleContent> <xs:extension base=\"xs:string\"> <xs:attribute name=\"kundennr\" type=\"xs:positiveInteger\" use=\"required\"/> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:element>  Das Element Name wird über complexType als komplexes Element angelegt.  Über das Element simpleContent legen Sie fest, dass das Element einen einfachen Inhalt besitzt.  Das Element soll jedoch erweitert werden (extension) und dabei grundsätzlich vom Datentyp string sein.  Erweitert wird das Element um das Attribut kundennr, das aus einer positiven Zahl bestehen muss. Somit können komplexe Elemente mit Attributen auch einen Inhalt besitzen. Komplexe Elemente mit gemischtem Inhalt Unter einem gemischten Inhalt ist die gleichzeitige Verwendung von Inhalt und zusätzlichen Unterelementen zu verstehen. <Kommentar> Bestellt: <Datum>2014-09-27</Datum>. </Kommentar> Im Beispiel besitzt das Element Kommentar einen Inhalt und gleichzeitig ein mit Inhalt gefülltes Element. Zu diesem Zweck können Sie das Definitionselement complexType um das Attribut mixed erweitern. Über mixed legen Sie fest, ob das Element zusätzlich einen Inhalt besitzen darf (true). Standardmäßig hat das Attribut mixed den Wert false, sodass in dem Fall die Angabe entfallen kann. <xs:complexType mixed=\"true|false\" /> Die Definition für das XML-Element Kommentar gestaltet sich dementsprechend. Beispiel: kap08\\mixed.xsd    <xs:element name=\"Kommentar\"> <xs:complexType mixed=\"true\"> <xs:sequence> <xs:element name=\"Datum\" type=\"xs:date\"> </xs:sequence> </xs:complexType> </xs:element> Hochschulversion 8 XML 1.1 - Grundlagen 86 © HERDT-Verlag  Das Element Kommentar wird über complexType als Element mit gemischtem Inhalt angelegt.  Den Inhalt leiten Sie als neues Element innerhalb des komplexen Elements über das Schlüsselwort sequence ein.  Das zusätzliche Element muss vom Datentyp date sein. 8.3 Indikatoren Mit Indikatoren können Sie festlegen, wie die Elemente in XML-Instanzen genutzt werden sollen. Einige der nachfolgenden Indikatoren kennen Sie bereits aus den vorangegangenen Beispielen. Reihenfolge-Indikatoren: all, choice, sequence Vorkommens-Indikatoren: maxOccurs, minOccurs Gruppen-Indikatoren: group, attributeGroup Reihenfolge-Indikatoren Hiermit bestimmen Sie, in welcher Reihenfolge die angegebenen Elemente in der XML-Instanz auftreten müs- sen. sequence Dieser Indikator ist bereits in den Beispielen zur Anwendung gekommen und soll daher nur noch einmal kurz genannt werden. Das Indikator-Element sequence umschließt die Menge der Unterelemente des komplexen Elements. Die Reihenfolge der Unterelemente ist unbedingt einzuhalten. all Der Indikator all spezifiziert, dass die Unterelemente eines komplexen Elements in einer beliebigen Reihen- folge auftreten können. Jedes Element kann genau einmal auftreten.   <xs:element name=\"Adresse\"> <xs:complexType> <xs:all> <xs:element name=\"Vorname\" type=\"xs:string\"> <xs:element name=\"Nachname\" type=\"xs:string\"> <!-- ... --> </xs:all> </xs:complexType> </xs:element>  Das Element Adresse wird über complexType als komplexes Element angelegt.  Der Reihenfolge-Indikator all legt fest, dass die nachfolgenden Elemente in der XML-Instanz maximal einmal auftreten können. Ob das Element Vorname vor dem Element Nachname stehen muss oder umgekehrt, ist hierbei nicht von Bedeutung. choice Ein weiterer Indikator ist choice, mit dem Sie eine Auswahl von Elementen festlegen können. In einer XML- Instanz darf jedoch nur eines der angegebenen Elemente auftreten. Mehrere Elemente gleichzeitig sind nicht möglich.   <xs:element name=\"Person\"> <xs:complexType> <xs:choice> <xs:element name=\"Angestellter\" type=\"xs:string\"> <xs:element name=\"Arbeiter\" type=\"xs:string\"> Hochschulversion Komplexe Elemente in Schema 8 © HERDT-Verlag 87 <!-- ... --> </xs:choice> </xs:complexType> </xs:element>  Der Reihenfolge-Indikator choice legt fest, dass eines der nachfolgenden Elemente in der XML-Instanz auftreten muss.  Entweder das Element Angestellter oder das Element Arbeiter – oder eines der weiteren, wenn vorhanden – muss als Unterelement von Person erscheinen. Vorkommens-Indikatoren Diese Indikatoren kommen zum Einsatz, wenn festgelegt werden soll, wie oft ein Element angegeben wer- den kann. maxOccurs und minOccurs Diese beiden Indikatoren werden als Attribute direkt am Element angegeben. Mit minOccurs legen Sie fest, wie oft ein Element innerhalb eines Elements mindestens vorhanden sein muss. Mit maxOccurs legen Sie die maximale Obergrenze fest. Als Wert wird jeweils die Angabe einer positiven Zahl erwartet. Sollen keine Obergrenzen festgelegt werden, sodass theoretisch eine unbegrenzte Anzahl von Elementen auftreten kann, wird die Bezeichnung unbounded (unbegrenzt) verwendet. Für die Reihenfolge-Indikatoren und die nachfolgenden Gruppen-Indikatoren sind die Werte von maxOccurs und minOccurs standardmäßig immer 1. Dies bedeutet, wenn Sie weder minOccurs noch maxOccurs an- geben, wird immer genau ein Element erwartet. Beispiel: kap08\\maxOccurs.xml Ein gutes Beispiel für den Einsatz von Vorkommens-Indikatoren ist die XML-Datei mit der Musiksammlung, bei der innerhalb des Elements ALBUM das Element LIED mehrfach auftritt. <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <MUSIKSAMMLUNG xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"maxOccurs.xsd\"> <ALBUM> <AUTOR>Max Mustermann</AUTOR> <GRUPPE>a-ha</GRUPPE> <TITEL>Minor earth major sky</TITEL> <LIED>Minor earth major sky</LIED> <LIED>Little black</LIED> <LIED>Velvet</LIED> <LIED>Summer moved on</LIED> </ALBUM> </MUSIKSAMMLUNG> Beispiel: kap08\\maxOccurs.xsd Die Definition der entsprechenden Schema-Datei sieht folgendermaßen aus:    <?xml version=\"1.0\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"http://www.herdt.com\"> <xs:element name=\"MUSIKSAMMLUNG\"> <xs:complexType> <xs:sequence> <xs:element maxOccurs=\"unbounded\" ref=\"ALBUM\" /> Hochschulversion 8 XML 1.1 - Grundlagen 88 © HERDT-Verlag     </xs:sequence> </xs:complexType> </xs:element> <xs:element name=\"ALBUM\"> <xs:complexType> <xs:sequence> <xs:element name=\"AUTOR\" /> <xs:choice> <xs:element name=\"INTERPRET\" /> <xs:element name=\"GRUPPE\" /> </xs:choice> <xs:element name=\"TITEL\" /> <xs:element name=\"LIED\" minOccurs=\"1\" maxOccurs=\"unbounded\" /> </xs:sequence> </xs:complexType> </xs:element> </xs:schema>  Die Schema-Datei wird als XML-Dokument definiert.  Das Hauptelement MUSIKSAMMLUNG ist ein komplexes Element.  Es wird auf die Definition des Elements ALBUM referenziert. Da in der XML-Instanz der Musiksammlung beliebig viele Alben aufgenommen werden können, wird der Indikator maxOccurs mit dem Wert unbounded angegeben.  Dies ist die eigentliche Definition des komplexen Elements ALBUM.  Es enthält eine Sequenz von Elementen, deren Reihenfolge unbedingt eingehalten werden muss.  Eines der Unterelemente besteht aus einer Auswahl (choice) von Elementen. Entweder muss in der XML-Instanz als Unterelement von ALBUM das Element INTERPRET oder GRUPPE angegeben sein. Da kein Vorkommens-Indikator festgelegt ist, muss eines der Elemente vorkommen.  Anders hingegen sieht es bei dem Element LIED aus. Da auf einem Album in der Regel mehrere Lieder vorhanden sind, wird die Obergrenze auf eine unbegrenzte Menge gesetzt. Die zusätzliche Angabe von minOccurs=1, damit mindestens ein Lied angegeben wird, kann also theoretisch weggelassen werden. Gruppen-Indikatoren Mit diesen Indikatoren haben Sie die Möglichkeit, Elemente und Attribute in bestimmten Gruppen zu defi- nieren. Im weiteren Verlauf einer Schema-Datei können Sie diese Gruppen über eine Referenz ansprechen und somit mehrfach nutzen. group Elementgruppen werden über das Schlüsselwort group festgelegt. <xs:group name=\"Gruppenname\"> ... </xs:group> <xs:group ref=\"Gruppenname\" /> Innerhalb einer Elementgruppe muss ein Reihenfolge-Indikator all, choice oder sequence vorhanden sein. Der Unterschied zu den komplexen Typen ist, dass Elementgruppen nicht aus komplexen Typen bestehen können. Beispiel: kap08\\group.xsd In diesem Beispiel wird eine Elementgruppe Adressengruppe definiert, die eine festgelegte Reihenfolge von Elementen beinhaltet. Hochschulversion Komplexe Elemente in Schema 8 © HERDT-Verlag 89 <?xml version=\"1.0\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:group name=\"AdressenGruppe\"> <xs:sequence> <xs:element name=\"Strasse\" type=\"xs:string\" /> <xs:element name=\"Ort\" type=\"xs:string\" /> <xs:element name=\"PLZ\" type=\"xs:integer\" /> </xs:sequence> </xs:group> ... Nach der Festlegung der Gruppe können Sie in einer anderen Gruppe oder einem komplexen Element darauf verweisen und somit die Definition mehrfach nutzen. Erweitern Sie das Beispiel, indem Sie ein Hauptelement Bestellung festlegen, das als Elemente den Namen des Kunden sowie die Liefer- und die Rechnungs- anschrift beinhalten soll. Bei der Anschrift können Sie jeweils die Gruppe AdressenGruppe referenzieren. ... <xs:element name=\"Bestellung\" type=\"BestellungTyp\" /> <xs:complexType name=\"BestellungTyp\"> <xs:sequence> <xs:element name=\"Name\" type=\"xs:string\" /> <xs:element name=\"Lieferanschrift\"> <xs:complexType> <xs:group ref=\"AdressenGruppe\" /> </xs:complexType> </xs:element> <xs:element name=\"Rechnungsanschrift\"> <xs:complexType> <xs:group ref=\"AdressenGruppe\" /> </xs:complexType> </xs:element> </xs:sequence> </xs:complexType> attributeGroup Auch Attribute können Sie als Gruppe definieren und diese mehrfach referenzieren. Die Definition erfolgt über das Element attributeGroup. <xs:attributeGroup name=\"Gruppenname\"> ... </xs:attributeGroup> <xs:attributeGroup ref=\"Gruppenname\" /> Das folgende Beispiel definiert eine Attributgruppe mit dem Namen nameAttributGruppe, die dann für die Attribute eines komplexen Elements genutzt werden kann. <xs:attributeGroup name=\"nameAttributGruppe\"> <xs:attribute name=\"Vorname\" type=\"xs:string\" /> <xs:attribute name=\"Nachname\" type=\"xs:string\" /> </xs:attributeGroup> Hochschulversion 8 XML 1.1 - Grundlagen 90 © HERDT-Verlag 8.4 Schema erweitern Mit der Erweiterung des Schemas ist gemeint, dass Sie bei der Festlegung der Elemente einen Platzhalter einfügen können, der für ein beliebiges weiteres Element steht. Dies bedeutet: Sie können ein XML-Doku- ment mit Elementen erweitern, ohne dass diese in dieser speziellen Schema-Datei angegeben sind. Die Lösung hierfür bietet das Element any. any (Wildcard) Statt der eigentlichen Definition des Elements über xs:element geben Sie xs:any an. Beispiel: kap08\\personalie.xsd <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://www.herdt.com\"> <xs:element name=\"Personalie\"> <xs:complexType> <xs:sequence> <xs:element name=\"Name\" type=\"xs:string\" /> <xs:any minOccurs=\"0\" /> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> In dem Beispiel wird im Element Personalie das Unterelement Name festgelegt. xs:any steht für ein belie- biges weiteres Element. Mit minOccurs stellen Sie sicher, dass das beliebige Element nicht unbedingt ange- geben werden muss. Die Erweiterung der Schema-Datei erfolgt über die Definition einer weiteren Schema-Datei. Beispiel: kap08\\adresse.xsd In der späteren XML-Instanz sollen nach dem Element Name innerhalb des Hauptelements Personalie die Adressangaben folgen. Diese werden über das Element Adresse in einer separaten Schema-Datei definiert. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://www.herdt.com\" elementFormDefault=\"qualified\"> <xs:element name=\"Adresse\"> <xs:complexType> <xs:sequence> <xs:element name=\"Strasse\" type=\"xs:string\" /> <xs:element name=\"Ort\" type=\"xs:string\" /> <xs:element name=\"PLZ\" type=\"xs:integer\" minOccurs=\"5\" maxOccurs=\"5\" /> </xs:sequence> </xs:complexType> </xs:element> </xs:schema> Nach der Festlegung des Präfixes xs als XML-Schema-Namensraum wird über targetNamespace der Ziel- namensraum festgelegt, in dem die nachfolgende Definition gültig werden soll. Elemente ohne Präfix wer- den dem Namensraum http://www.herdt.com zugeordnet. Das Attribut elementFormDefault mit dem Wert qualified besagt, dass alle Elemente mit einem Präfix geschrieben werden müssen. Dem Element Adresse wird eine festgelegte Reihenfolge von drei Unterelementen zugewiesen. Hochschulversion Komplexe Elemente in Schema 8 © HERDT-Verlag 91 Beispiel: kap08\\any.xml Das Beispiel bindet beide Schema-Dateien ein und erweitert somit die Struktur der Daten, sodass innerhalb des Hauptelements Personalie das Unterelement Adresse verwendet werden kann.      <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <Personalie xmlns=\"http://www.herdt.com\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.herdt.com personalie.xsd http://www.herdt.com adresse.xsd\"> <Name>Heiko Schröder</Name> <Adresse> <Strasse>Musterstraße 123</Strasse> <Ort>Musterstadt</Ort> <PLZ>88888</PLZ> </Adresse> </Personalie>  Der standardmäßig zu verwendende Namensraum ist http://www.herdt.com.  Der Namensraum xsi wird für die XML-Instanz angegeben.  Im Namensraum xsi kommen die Definitionen der beiden Schema-Dateien personalie.xsd und adresse. xsd zur Anwendung.  Als Unterelement von Personalie wurde das Element Name in der Schema-Datei personalie.xsd defi- niert.  Durch die Festlegung von xs:any können beliebige Elemente folgen. In diesem Fall ist es das komplexe Element Adresse. Durch die Einbindung der Schema-Datei adresse.xsd, in der dieses Element definiert wurde, ist die Nutzung des Elements Adresse und der Unterelemente Strasse, Ort und PLZ erlaubt. anyAttribute Auf die gleiche Art und Weise können Sie einen Platzhalter für Attribute in der Schema-Datei unterbringen. Dazu definieren Sie den Platzhalter anyAttribute und eine zweite Schema-Datei mit der Definition der Attribute. <xs:element name=\"Elementname\"> <xs:complexType> <!-- ... --> <xs:anyAttribute /> </xs:complexType> </xs:element> In der XML-Instanz müssen Sie nur noch beide Schema-Dateien laden und können dann entsprechend das er- weiterte Attribut nutzen. 8.5 Schema 1.1 Neuerungen Die im Jahr 2012 veröffentliche Version XML Schema 1.1 bietet neben der Verbesserung einzelner bereits vorhandener Funktionen eine Reihe von Neuerungen, unter anderem: Zusicherungen bzw. Behauptungen (Assertions) durch das Element <assert> und die Fassette <assertion> Schemaweite Attribute Erhöhte Flexibilität bei der Weiterentwicklung eines Schemas mit den Elementen <openContent> bzw. <defaultOpenContent> Bedingte Typisierung in Form alternativer Datentypen in Abhängigkeit von Attributwerten Hochschulversion 8 XML 1.1 - Grundlagen 92 © HERDT-Verlag Zur Kennzeichnung der verwendeten Version gibt es den Version Control Namespace xmlns:vc=\"http://www.w3.org/2007/XMLSchema-versioning\". Innerhalb eines Schema können unterschiedliche Parser-Implementierungen berücksichtig werden. Durch die Auswertung der Attribute vc:minVersion bzw. vc:maxVersion ermittelt ein Parser, die für die Validierung des Dokuments zu verwendende Schema-Version. Gegenwärtig wird XML Schema 1.1 noch nicht von allen Programmen und Werkzeugen unterstützt. Vor seiner Anwendung ist daher gerade bei unternehmensübergreifenden Projekten eine Abklärung der Möglichkeit des Einsatzes notwendig. Zusicherungen Zusicherungen ermöglichen die Validierung von XML-Dokumenten mit ihren konkreten Werten. Dies erfolgt in Abhängigkeit von der Erfüllung von im Schema-Dokument festgelegten Regeln bzw. Bedingungen für die Ele- mente und Attribute. Formuliert werden die Regeln bzw. Bedingungen über XPath Ausdrücke (vgl. Kapitel 10). Die Umsetzung für komplexe Datentypen erfolgt mit dem Element <assert>, für simple Datentypen mit der Fassette <assertion>. Beispiel: kap08\\budget.xsd Das Beispiel zeigt die Anwendung des Elements <assert>. Über einen Vergleich wird sichergestellt, dass der Wert des Attributes minimal höchstens genauso groß wie der des Attributes maximal ist.   <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:herdt=\"http://www.herdt.com\" vc:minVersion=\"1.1\" xmlns:vc=\"http://www.w3.org/2007/XMLSchema-versioning\"> <xs:element name=\"Budget\"> <xs:complexType> <xs:sequence> <xs:element name=\"Bereich\" type=\"xs:string\"/> <xs:element name=\"Wert\" type=\"werttyp\"/> </xs:sequence> </xs:complexType> </xs:element> <xs:complexType name=\"werttyp\"> <xs:simpleContent> <xs:extension base=\"xs:integer\"> <xs:attribute name=\"minimal\" type=\"xs:integer\"/> <xs:attribute name=\"maximal\" type=\"xs:integer\"/> <xs:assert test=\"@minimal le @maximal\"/> </xs:extension> </xs:simpleContent> </xs:complexType> </xs:schema>  Das Attribut vc:minVersion gibt dem Parser vor, mit welcher Schema-Version das Dokument validiert werden soll.  Über das <xs:assert> Element wird bestimmt, dass der minimal angegebene Wert kleiner oder höchstens genauso groß (le = lower-equal) wie der bei maximal angegebene sein kann. Beispiel: kap08\\budget.xml Das Resultat der Validierung des zugehörigen XML-Dokuments hängt von den verwendeten Attributwerten ab. Hochschulversion Komplexe Elemente in Schema 8 © HERDT-Verlag 93  <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <Budget xsi:noNamespaceSchemaLocation=\"budget.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <Bereich>Verwaltung</Bereich> <Wert minimal=\"10000\" maximal=\"15000\">12000</Wert> </Budget>  Für den Wert werden als Minimalwert 10000 und als Maximalwert 15000 festgelegt. Der eigentliche Wert liegt in diesem Bereich. Die Validierung des Dokuments ergibt keinen Fehler. Schemaweite Attribute Durch die Zuordnung einer Attributgruppe über das <schema> Attribut defaultAttributes gelten die in der Gruppe enthaltenen Attribute für alle Elemente des Schemas, in dem die Attributdeklaration erfolgt.   <xs:schema ... defaultAttributes=\"StandardAttribute\"> <xs:attribute-group name=\" StandardAttribute \"> <!-- Deklaration der Attribute --> </xs:attribute-group> <!-- alle weiteren Deklarationen --> </xs:schema>  Die Zuordnung der Attributgruppe zum <schema> Attribut defaultAttributes.  Die Definition der zugeordneten Attributgruppe mit den einzelnen Attributen. Für einzelne Elemente des Schemas kann die Gültigkeit der Standardattribute durch das Setzen des Wertes false für das Attribut defaultAttributesApply ausgeschlossen werden. Flexibilität mittels offener Modelle Über die Elemente <xs:openContent> und <xs:defaultOpenContent> können Modelle in XML Schema 1.1 so gestaltet werden, dass komplexe Typen nicht komplett fixiert sind, sondern ergänzende, nicht festgelegte Elemente erlauben. Damit kann eine bestehende Schema-Datei flexibel und offen für sich verändernde XML- Dateien nutzen, ehe zu einem späteren Zeitpunkt ggf. eine Anpassung des XML Schemas erfolgt. Erfolgreiche Validierung des Dokuments im XML-Editor XMLSpy> Bei Eingabe eines größeren Minimal- als Maximalwertes meldet die Validierung einen Fehler Hochschulversion 8 XML 1.1 - Grundlagen 94 © HERDT-Verlag In dem bereits verwendeten Beispiel kap07/bestell.xsd kann das Element Bestellung beispielsweise so erweitert werden, dass es weitere Unterelemente erlaubt.   <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"> <xs:element name=\"Bestellung\"> <xs:complexType> <xs:openContent mode=\"interleave\"> <xs:any processContents=\"lax\" /> </xs:openContent> <xs:sequence> <xs:element name=\"Adresse\" type=\"BestellAdresse\" /> <xs:element name=\"Ware\" type=\"WarenTyp\" /> </xs:sequence> <!-- … --> </xs:complexType> </xs:element> …  Durch das Einfügen von openContent wird der komplexe Typ als offen für weitere Elemente markiert. Das Zuweisen von interleave zum Attribut mode sorgt dafür, dass diese Elemente zwischen den bereits vorhandenen Elementen angegeben werden können.  Das Attribut processContents bestimmt für einen Knoten vom Typ <xs:any> die Überprüfungsebene. Der Wert lax legt fest, dass die Überprüfung nur durchgeführt wird, wenn zugehörige Elemente gefunden werden. Ein komplett offenes Schema lässt sich durch den Einsatz von <xs:defaultOpenContent> als globale Komponente erreichen.  <xs:defaultOpenContent mode=\"interleave\" appliesToEmpty=\"false\"> <xs:any /> </xs:defaultOpenContent>  Das gesamte Schema wird als offen für beliebige Elemente gekennzeichnet. Der Wert des Attributes appliesToEmpty bestimmt dabei, ob zusätzliche Elemente auch in leeren Elementen zulässig sind. Bedingte Datentypen Bedingte Datentypen (Conditional Type Alternatives, CTA) ermöglichen es, für ein Element unterschiedliche Datentypen auszuwählen. Genau wie bei Zusicherungen werden XPath-Bedingungen ausgewertet, die einen Attributwert des Elements verwenden. Ergibt der Test true, wird der zugeordnete Datentyp verwendet. Für die Realisierung der bedingten Datentypen wurden in XML Schema 1.1 das Element <xs:alterantive> auf- sowie einige Änderungen am Element <xs:element> vorgenommen. Die prinzipielle Syntax lautet: <xs:alternative test=\"XPath-Ausdruck\" type=\"type\" /> Voraussetzung für die Zuordnung eines alternativen Typs ist, dass dieser von dem ursprünglich für das Element deklarierten Typ abgeleitet sein muss. Möglich ist ebenfalls die Zuordnung des gleichfalls neuen Typs xs:error. Wird dieser zugeordnet, wird das betreffende Element immer als ungültig validiert. Im Beispiel (Quelle: IBM) ist das Element title mit dem Basistyp xs:anyType deklariert. Daneben werden fünf alternative Typen deklariert. Bei der Überprüfung wird nach der Reihenfolge vorgegangen. Der Test, welcher zuerst den Wert true liefert, bestimmt den zu verwendenden Typ. Liefert keiner der ersten drei Tests den Wert true, wird geprüft, ob das zu testende Attribut vorhanden ist. Ist dies nicht der Fall, wird der Typ xs:error zugewiesen. Das Element ist damit als invalid gekennzeichnet. Ergibt kein Test true, wird der Default-Typ verwendet. Hochschulversion Komplexe Elemente in Schema 8 © HERDT-Verlag 95       <xs:element name=\"title\" type=\"xs:anyType\"> <xs:alternative test=\"@type='text'\" type=\"xs:string\"/> <xs:alternative test=\"@type='html'\" type=\"htmlContentType\"/> <xs:alternative test=\"@type='xhtml'\" type=\"xhtmlContentType\"/> <xs:alternative test=\"@type\" type=\"xs:error\"/> <xs:alternative type=\"xs:string\"/> </xs:element>  Deklaration des Elements mit dem Basistyp xs:anyType.  Deklaration des alternativen Typs xs:string für den Wert 'text' des Attributs type.  Deklaration des alternativen Typs htmlContentType für den Wert 'html' des Attributs type.  Deklaration des alternativen Typs xhtmlContentType für den Wert 'xtext' des Attributs type.  Zuweisung des Typs xs:error, wenn das Attribut nicht vorhanden ist.  Deklaration des Default-Typs. Die unterschiedlichen Varianten des Elementes title zeigen die Auswahl der verschiedenen Typen:     <title type=\"text\">Neuigkeiten</title> <title type=\"xhtml\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">Neue <xhtml:em> Neuigkeiten </xhtml:em>!</title> <title>Neuigkeiten</title> <title type=\"unbekannt\">Fehler!</title>  Die erste Alternative wird gewählt (xs:string).  Die dritte Alternative wird gewählt (xhtmlContentType).  Der Default-Typ wird gewählt (xs:string).  Die vierte Alternative wird gewählt (xs:error). Das Element ist damit invalid. 8.6 Übungen Übung 1: DTD in Schema-Definition umwandeln Übungsdatei: kap08\\kfz.dtd Ergebnisdateien: kap08\\kfz.xml, kap08\\kfz.xsd, kap09\\kfz2.xml, kap08\\kfz2.xsd,  Konvertieren Sie die DTD der Fahrzeugverwaltung in eine allgemeine XML-Schema-Syntax. Achten Sie darauf, dass Dezimalzahlen mit einem Punkt statt mit einem Komma notiert werden.  Schränken Sie die möglichen Daten ein, sodass nur positive Zahlenwerte möglich sind. In einem weiteren Schritt definieren Sie sinnvolle Maximalangaben, z. B. nicht mehr als 10.000 cm³ Hubraum usw. Übung 2: Schema-Datei definieren Übungsdatei: -- Ergebnisdateien: kap08\\buchhaendler.xml, kap08\\buch.xsd Ein Buchhändler möchte mit dem Lieferanten die Buchdaten per XML austauschen. Die Daten haben folgendes Format: Das Hauptelement Lager kann mindestens ein, dafür aber unendlich viele Elemente Buch haben. Buch selbst besteht aus den Elementen Autor, Titel, Verlag, Seiten, Erschei- nungsdatum, Bestellnummer und PreisEUR. Die Bestellnummer besteht aus zwei beliebi- gen Buchstaben, gefolgt von fünf Ziffern, wie z. B. AB12345. Der Preis soll mit zwei Nach- kommastellen angegeben werden. Erstellen Sie das dafür notwendige XML-Schema. . , Hochschulversion 9 XML 1.1 - Grundlagen 96 © HERDT-Verlag 9 Formatierungssprachen In diesem Kapitel erfahren Sie Grundlegendes über die Möglichkeiten von XSL wie Sie mit Stylesheets XML-Daten formatieren Voraussetzungen Kenntnisse in Cascading Style Sheets (CSS) 9.1 Übersicht der Sprachen <INTERPRET>Alan Parsons Project</INTERPRET> <TITEL>Ladyhawke</TITEL> Der verkürzte Auszug aus einem XML-Beispiel legt durch die Bezeichnung der Elemente fest, dass es sich bei dem eingeschlossenen Wert um eine Information bezüglich des Interpreten sowie eines Titels handelt. Die Angabe der Elemente gibt jedoch keine Auskunft darüber, wie die Information dargestellt werden soll. Um eine Formatierung der Daten zu ermöglichen, wird die Sprache XSL (Extensible Stylesheet Language = Erweiterbare Formatierungssprache) verwendet. Die Formatierung von Daten in der Meta-Auszeichnungssprache SGML erfolgt über die recht komplizierte und sehr umfangreiche Formatierungssprache DSSSL (Document Style Semantics and Specification Language). Diese Sprache ist eine reine Programmiersprache auf der Basis eines LISP-Dialekts. In HTML legen die Elemente fest, wie die jeweiligen Daten im Browser darzustellen sind. CSS (Cascading Style Sheets) erlaubt eine Formatierung der Informationen mithilfe von Vorlagen für die Browser, die CSS als Formatierungssprache unterstützen. Der Funktionsumfang von CSS hat sich bei der Formatie- rung von XML-Daten als eingeschränkt erwiesen. Es konn- ten nur einfache XML-Dokumente dargestellt werden. Im August 1997 wurde daher von Vertretern einiger Software- Firmen die Formatierungssprache XSL entwickelt und als Vorschlag beim W3-Konsortium eingereicht. Der Vorteil dieses Konzepts ist die Integration von DSSSL-Eigenschaf- ten sowie die Einbeziehung von HTML- und CSS-Objekten in die XML-Syntax. 9.2 Grundlagen von XSL Mit der Formatierungssprache XSL können vorhandene XML-Daten über entsprechende Prozessoren in andere Dokumentformate umgewandelt werden. Dabei legen Sie über Transformationsanweisungen die Formatierung und das Layout für die Darstellung fest. Ein Beispiel hierfür ist das Format SVG (Scalable Vector Graphics), dessen Dokumentinhalt ebenfalls auf einer XML-Struktur aufbaut. Ebenso können Sie mit XSL aus einem XML-Dokument ein formatiertes XML-Dokument erstellen. DSSSL HTML CSS XSL T E I L E Hochschulversion Formatierungssprachen 9 © HERDT-Verlag 97 semantische Auszeichnung XML physische Auszeichnung XSL XSL-Prozessoren HTML SVG XML Eine semantische Auszeichnung umschreibt mithilfe des Elementnamens die Bedeutung des Inhalts. <INTERPRET>Alan Parsons Project</INTERPRET> <TITEL>Ladyhawke</TITEL> Auch in HTML existiert eine Reihe semantischer Elemente. <H1>Alan Parsons Project</H1> <H2>Ladyhawke</H2> Da die HTML-Tags fest definiert sind, konnten die für deren Darstellung notwendigen Layoutinformationen fest in die Browser integriert werden. Damit weiß z. B. jeder Browser, dass der Inhalt eines h1-Elements fetter und größer als der eines p-Elements darzustellen ist. Über die browserseitigen Voreinstellungen hinaus- gehend kann der Autor eines HTML-Dokuments die Darstellung der einzelnen Elemente zusätzlich über ein Cascading Style Sheet (CSS) umformatieren. In XML werden Elemente verwendet, die dem Browser nicht bekannt sind. In diesem Fall müssen Sie dem Browser mitteilen, wie er das entsprechende Element darstellen soll. Diese physische Auszeichnung wird in XML über die Formatierungssprache XSL erreicht. Einmal erstellte Daten im XML-Format können über verschiedene XSL-Transformationen in andere Dokumentformate konvertiert werden. Mit XSL können Sie: XML-Daten in HTML oder ein anderes Textformat transformieren, XML-Daten filtern und sortieren, XML-Daten abhängig vom Wert formatieren. Die Extensible Stylesheet Language enthält verschiedene Komponenten. XSL Oberbegriff für die XSL-Transformation (XSLT), für XPath und XSL-FO XSLT - XSL-Transformation Sprache zur Beschreibung, wie ein XML-Dokument in ein anderes Doku- ment transformiert werden soll XPath - XML Path Language Ursprünglich eine Untersprache von XSLT zum Kennzeichnen von speziellen Teilen eines XML-Dokuments, wird jetzt separat weiterentwickelt XSL-FO Extensible Stylesheet Language - Formatting Objects beschreibt, wie Texte und grafische Elemente für den Druck und für die Darstellung am Bild- schirm angeordnet werden sollen. Warum gibt es noch eine Formatierungssprache? Obwohl CSS 2.1 als Standard verabschiedet wurde und für CSS3 bereits einige Module fertig sind, entwickelt das W3-Konsortium mit XSL parallel eine weitere Formatierungssprache. Auf die Frage nach dem Sinn dieser Entwicklung gibt das W3-Konsortium folgende Antwort: Das herausragendste Merkmal ist, dass CSS in HTML- Dokumenten verwendet werden kann. Auf der anderen Seite ist es mit XSL möglich, Dokumente mit XML- Daten in HTML- und CSS-Dokumente zu transformieren. Deshalb ergänzen sich die beiden Formatierungs- sprachen und können gemeinsam in Browsern benutzt werden. (Quelle: http://www.w3.org/Style) Hochschulversion 9 XML 1.1 - Grundlagen 98 © HERDT-Verlag Verwendung in … CSS XSL HTML ja nein XML ja ja XSLT nein ja Welche Formatierungssprache sollten Sie verwenden? Benutzen Sie CSS, wenn Sie können, und XSL, wenn Sie müssen (siehe http://www.w3.org/Style/CSS-vs-XSL). Der Grund hierfür ist die einfache Funktionsweise von CSS. Außerdem existieren mehr Programme zur Erstellung von CSS-Formaten als für XSL-Formate. Setzen Sie XSL ein, wenn Sie Daten sortieren, filtern oder ersetzen müssen. Beispielsweise erstellen Sie ein XML-Dokument und möchten daraus nur bestimmte Daten anzeigen lassen. Oder Sie möchten eine sortierte Liste der XML-Daten erstellen. Nutzen Sie XSL, wenn Sie die Inhalte mehrfach verwenden und vielleicht auch in einer anderen Reihenfolge anzeigen wollen bzw. in andere Formate transformieren möchten. Folgende Übersicht soll Ihnen die Auswahl der entsprechenden Formatierungssprache erleichtern. XML / HTML HTML XML CSS CSS     XSLT XSL-FO XSLT CSS A U S G A B E Software  Benutzen Sie zur Formatierung eines HTML-Dokuments CSS.  Möchten Sie alle Daten eines XML-Dokuments in der angegebenen Reihenfolge anzeigen, benutzen Sie ebenfalls die CSS.  Erstellen Sie über XSLT ein XML- oder HTML-Dokument, das Sie über die CSS formatieren können.  Ansonsten greifen Sie auf die XSL-Transformation zurück und erstellen XSL-FO-Dokumente für die neu geordneten Daten. Diese werden dann über eine spezielle Software z. B. in ein PDF-Dokument trans- formiert. 9.3 Einbinden von CSS Möchten Sie alle XML-Daten eines Dokuments in unver- änderter Reihenfolge ausgeben, formatieren Sie die einzel- nen Elemente über CSS. Beispiel: kap09\\musik.css Sie können Ihre bisher erstellte Musiksammlung mithilfe von CSS so formatieren, dass der Browser die Daten wie ein HTML-Dokument darstellt. Erstellen Sie dazu die folgende Stylesheet-Datei zur Formatierung Ihrer XML-Daten der Musiksammlung. ALBUM { font-family:Verdana,helvetica,sans-serif; color:#000; } INTERPRET, GRUPPE { font-size:14pt; font-weight:bold; color:#800000; } TITEL { font-size:12pt; font-weight:bold; color:#800000; } LIED, AUTOR { font-size:8pt; text-indent:10pt;} CSS Ausgabe XML Hochschulversion Formatierungssprachen 9 © HERDT-Verlag 99 Innerhalb der CSS-Datei werden nicht wie bisher die jeweiligen HTML-Tags oder Klassennamen angegeben, sondern die jeweiligen Namen der Elemente. Ähnlich wie in HTML werden auch die Stylesheets in XML in das aktuelle Dokument eingebunden. Hierfür verwenden Sie die entsprechende Processing Instruction (PI). <?xml-stylesheet type=\"text/css\" href=\"CSS-Datei\"?> Es ist darauf zu achten, dass das Einbinden der CSS-Datei in die XML-Datei vor dem Hauptelement erfolgen muss. Die Typangabe type=\"text/css\" teilt dem Browser mit, dass es sich hierbei um eine Stylesheet-Datei handelt. Beispiel: kap09\\musik-css.xml In die bereits bestehende Musiksammlung soll die CSS-Datei eingebunden werden, um die Daten für die Aus- gabe im Browser zu formatieren. <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <?xml-stylesheet type=\"text/css\" href=\"musik.css\"?> <MUSIKSAMMLUNG> <ALBUM> <INTERPRET>Moby</INTERPRET> <TITEL>Play</TITEL> <LIED>Honey</LIED> <LIED>Find my baby</LIED> <LIED>Porcelain</LIED> <!-- usw. --> </ALBUM> </MUSIKSAMMLUNG> Öffnen Sie diese Datei in Ihrem Browser. Der Browser formatiert die Daten so, wie Sie dies in den Stylesheets für das entsprechende Element angegeben ha- ben. Jedoch erscheinen alle Daten als Fließtext und werden hintereinander gesetzt. Dies ist kein Fehler des Browsers, denn bisher haben Sie dem Browser noch nicht mitgeteilt, dass Sie diese Elemente als Absätze formatieren möchten. In HTML erzwingen Sie einen neuen Absatz über das Element p oder das Element div. Einen Zeilenumbruch fügen Sie mit dem Element br ein. Damit in XML die Elemente als Absätze formatiert werden können, steht Ihnen die CSS-Eigenschaft display zur Verfügung. display:block|inline|list-item block Erzwingt einen Block und somit einen neuen Absatz inline Erzwingt die Anzeige im Textfluss und somit keinen neuen Absatz list-item Wie block, jedoch mit einem Aufzählungszeichen CSS-formatierte Ausgabe von XML-Daten Hochschulversion 9 XML 1.1 - Grundlagen 100 © HERDT-Verlag Beispiel: kap09\\musik2.css In der Auflistung der XML-Daten sollen der Name des Interpreten und der Titel des Albums in einer Zeile ste- hen. Jedes Lied soll als Aufzählung formatiert werden. Fügen Sie über die Stylesheet-Angabe display die Zeilenumbrüche ein. Damit die Alben voneinander getrennt dargestellt werden, setzen Sie einen unteren Abstand von 20 Pixel (margin-bottom:20px;). Die Box zur Darstellung der List-Marker wird unsichtbar, wenn sie sich außerhalb der Block-Box befindet. Über die Eigenschaft list-style-position kann sie entsprechend positioniert werden. ALBUM { display:block; margin-bottom:20px; font-family:Verdana,helvetica,sans-serif; color:#000; } INTERPRET, GRUPPE { font-size:14pt; font-weight:bold; color:#800000; } TITEL { font-size:12pt; font-weight:bold; color:#800000; } LIED, AUTOR { display:list-item; list-style-position: inside; font-size:8pt; text-indent:10pt; } Öffnen Sie die XML-Datei erneut in Ihrem Browser. Internet Explorer 11.0 Mozilla Firefox 33.0 Bei Verwendung von älteren Browsern kann es hier zu unterschiedlichen Darstellungen kommen. Dies ist ein grundlegendes Problem, mit dem Web-Autoren konfrontiert werden. Nicht jeder Browser stellt immer alle Stylesheet-Formatierungen so dar, wie es vom W3-Konsortium in der CSS-Spezifikation vorgegeben wird. Aktuell betrifft dies vor allem die neuen Module der CSS3-Spezifikation, die noch nicht alle in jedem Browser vollumfänglich unterstützt werden. Sollen XML-Daten unabhängig vom Browser identisch dargestellt werden, sind Sie gezwungen, immer den kleinsten gemeinsamen Nenner in Bezug auf die Darstellung der Formatierung zu finden. Dies erreichen Sie, wenn Sie verschiedene Attribute der CSS-Eigenschaften ausprobieren und in unterschiedlichen Browsern testen. Hochschulversion Formatierungssprachen 9 © HERDT-Verlag 101 9.4 Übung XML-Elemente mit CSS formatiert darstellen Übungsdatei: -- Ergebnisdateien: kap09\\seminar.xml, kap09\\seminar.css Erstellen Sie mithilfe der CSS für die XML-Daten des Seminars aus den vorherigen Übungen die nachfolgende Formatierung. Alle XML-Elemente sollen in der Schriftart Verdana angezeigt werden. Das komplette XML-Dokument soll einen blauen Rahmen erhalten. Das Element titel soll zentriert auf blauem Hintergrund angezeigt werden. Die Elemente ort und datum sollen fett hervorgehoben werden. Variieren Sie mit oberen (margin-top) und unteren (margin-bottom) Abständen. Die Vor- und Nachnamen der Anwesenden sollen komplett auf einer Zeile angezeigt werden. Realisieren Sie dies mit der CSS-Eigenschaft margin-left. Binden Sie die externe CSS-Datei in die XML-Datei ein. Das Ergebnis im Firefox Hochschulversion 10 XML 1.1 - Grundlagen 102 © HERDT-Verlag 10 XPath In diesem Kapitel erfahren Sie wie Sie mithilfe von XPath bestimmte Elemente selektieren können welche Rolle die Achsen, Knotenprüfungen und Prädikate spielen Voraussetzungen Kenntnisse des Aufbaus von XML-Dokumenten 10.1 XPath-Grundlagen Entwicklung XPath ist keine XML-Anwendung, sondern eine Beschreibungssprache für Ausdrücke mit einer eigenen Syntax. Sie ermöglicht, einzelne Teile eines XML-Dokuments zu selektieren, anzusprechen und auszuwerten. Die offizielle Empfehlung des W3C für XPath 1.0 finden Sie unter http://www.w3.org/TR/xpath/. Verwendung findet XPath sowohl in XML Schema (vgl. Kapitel 7 und 8) als auch in XSL und XSLT Dokumenten (vgl. Kapitel 11 und 12). Seit dem Jahr 2010 gibt es die Empfehlung des W3C für XPath 2.0 (http://www.w3.org/TR/xpath20/). Diese stellt eine Erweiterung der Version 1.0 dar, wird jedoch noch nicht von allen XML-Prozessoren unterstützt. Einen Überblick über einige Neuerungen enthält der entsprechende Abschnitt am Ende des Kapitels. XPath 2.0 ist die Grundlage von XSLT 2.0 und XQuery 1.0 (vgl. Kapitel 14) und wurde zeitgleich mit diesen Empfehlungen veröffentlicht. Seit dem April des Jahres 2014 liegt mit der Version XPath 3.0 (http://www.w3.org/TR/xpath-30/) eine weitere Empfehlung vor, welche neben Fehlerkorrekturen einige weitere Neuerungen, wie beispielsweise dynamische Funktionsaufrufe umfasst. Anwendung findet XPath 3.0 aktuell vor allem in XQuery 3.0 Prozessoren. Baumstrukturen XPath stellt ein XML-Dokument als einen Baum dar, der aus Knoten besteht. Dabei gibt es verschiedene Knotentypen: Wurzelknoten Elementknoten Attributknoten Textknoten Kommentarknoten Namensraumknoten Verarbeitungsanweisungsknoten Damit können Sie über festgelegte Kriterien ganz bestimmte Knoten eines XML-Dokuments selektieren und ausgeben. Zum besseren Verständnis der nachfolgenden XPath-Prinzipien wurde die XML-Struktur in eine Art Familie aufgeteilt. Dies macht die Erklärung der Eltern-Kind-Beziehungen der Elemente verständlicher. Hochschulversion XPath 10 © HERDT-Verlag 103 <STAMM> <GROSSELTERN> <ELTERN> <KIND> <ENKEL> <ELTERN> <ELTERN> <ELTERN> <ELTERN> <GROSSELTERN> <KIND> <KIND> <ENKEL> <ENKEL> <ENKEL> Die Anordnung der Komponenten des XML-Dokuments innerhalb der Baumstruktur erfolgt nach festen Regeln. Bei einem kompletten Durchlauf durchlaufen (traversieren, engl. to traverse) XML-Prozessoren den Baum entsprechend der Dokumentreihenfolge, wie sie im zugrundeliegenden XML-Dokument vorliegt. Dabei wird immer eine Tiefensuche angewendet. Bei der Tiefesuche werden immer zuerst die Teilbäume komplett durchlaufen: <STAMM> <GROSSELTERN> <ELTERN> <KIND> <ENKEL> <ELTERN> <ELTERN> <ELTERN> <ELTERN> <GROSSELTERN> <KIND> <KIND> <ENKEL> <ENKEL> <ENKEL> XPath-Datentypen Als Ergebnis eines XPath-Ausdrucks wird ein Objekt zurückgegeben, welches in XPath 1.0 einen von vier Datentypen besitzen kann: node-set Knotenmenge string Zeichenfolge number Fließkommazahl (nach IEEE 754) boolean boolscher Wert, entweder true oder false Für Umwandlungen zwischen den einzelnen Typen enthält die Empfehlung feste Regeln. Entitäten können von XPath nicht selektiert werden, da ein XPath-Ausdruck das vom Prozessor fertig geparste Dokument auswertet. Entitäten sind zu diesem Zeitpunkt jedoch schon durch ihre zugehörige Zeichenfolge ersetzt.                Hochschulversion 10 XML 1.1 - Grundlagen 104 © HERDT-Verlag 10.2 XML-Prinzipien Lokalisierungsstufen Eine Lokalisierung der unterschiedlichen Stufen innerhalb der XML-Struktur besteht aus drei Teilen: einer Achse (engl.: Axis Specifier) zum Navigieren in der XML-Baumstruktur, einer Knotenprüfung (engl.: Node Test), um über weitere Kriterien bestimmte Knoten zu selektieren, keinem oder mehreren Prädikaten, um die Auswahl der bisher selektierten Knoten genauer zu filtern. Die Angabe der Achse und die Knotenprüfung sind Pflichtangaben. Die Angabe des Prädikats ist optional. achse::knotenprüfung[prädikat] Die Achsen- und die Knotenprüfungsangabe werden durch zwei Doppelpunkte voneinander getrennt angegeben. Das Prädikat wird in eckige Klammern eingeschlossen. Achsen XPath bietet sehr umfangreiche Möglichkeiten zum Selektieren bestimmter XML-Knoten. Zum Navigieren in einem Dokumentenbaum nutzt XPath verschiedene Achsen. In der nachfolgenden Abbildung und Tabelle fin- den Sie alle zur Verfügung stehenden Achsen, mit denen Sie eine Menge von Knoten bezüglich ihrer Position im XML-Baum relativ zum gegebenen Kontext-Knoten  bestimmen können. <STAMM> <GROSSELTERN> <ELTERN> <KIND> <ENKEL> <ELTERN> <ELTERN> <ELTERN> <ELTERN> <GROSSELTERN> <KIND> <KIND> <ENKEL> <ENKEL> <ENKEL> Achse Erläuterung self  Das aktuelle Element wird selektiert (Kontext-Knoten). ancestor  Vorfahre; ein Vorfahre kann hierbei das Eltern-Element oder das Groß- eltern-Element sein, bis hin zur Wurzel. ancestor-or-self   Vorfahre oder aktueller Kontext-Knoten; die Achse enthält auch immer das Hauptelement. attribute Hiermit werden die Attribute des Kontext-Knotens bestimmt. child  Die Kind-Elemente des Kontext-Knotens werden angesprochen. descendant  Nachfahre; ein Nachfahre kann hierbei ein Kind oder das Kind eines Kindes (Enkel-Element) sein. descendant-or-self   Nachfahre oder aktuelles Element; ein Nachfahre kann hierbei ein Kind oder das Kind eines Kindes (Enkel-Element) sein. : : [ ]               Hochschulversion XPath 10 © HERDT-Verlag 105 Achse Erläuterung following  Nachfolgende Knoten mit deren Kindern; hierbei werden innerhalb des Do- kuments die nachfolgenden Knoten angesprochen, die sich auf derselben Ebene des Kontext-Knotens befinden, sowie deren entsprechende Kind- Elemente. Attribut- oder Namensraumknoten werden außer Acht gelassen. following-sibling  Nachfolgende Knoten der gleichen Ebene desselben Eltern-Knotens; ist der Kontext-Knoten ein Attribut- oder Namensraumknoten, ist die Anzahl der folgenden Geschwister gleich null. namespace Der Namensraum des Kontext-Knotens wird angesprochen. parent  Das Eltern-Element wird selektiert. preceding  Vorherige Knoten mit deren Kindern; hierbei werden innerhalb des Doku- ments die vorherigen Knoten des Kontext-Knotens angesprochen, wobei Attribut- oder Namensraumknoten außer Acht gelassen werden. preceding-sibling  Vorherige Geschwister desselben Eltern-Knotens; ist der Kontext-Knoten ein Attribut- oder Namensraumknoten, ist die Anzahl der vorherigen Ge- schwister gleich null. Die Achsen ancestor, descendant, following, preceding und self zerteilen ein Dokument. Sie über- schneiden sich niemals und enthalten zusammen alle Knoten eines Dokuments, ohne dass ein Knoten doppelt vorkommt, wobei die Attribut- und Namensraumknoten nicht beachtet werden. Selektierungspfad Zum Selektieren bestimmter Baumknoten werden bei den Elementnamen bestimmte Zeichen vorangestellt. Sie stellen die sogenannten Stufen zum Selektieren der Elemente dar. Die gekürzte Syntax eines Selektierungspfades (engl. Location Paths) lautet: Zeichen Bedeutung (kein Zeichen) Nachkomme eines Knotens @ Attribut des selektierten Elements / Hauptelement // Selektierter Knoten oder dessen Nachkomme . Selektierter Knoten .. Vorfahre des selektierten Knotens * Beliebige Knoten Die in den nachfolgenden Beispielen verwendeten Angaben xsl:for-each und xsl:value-of sind Elemente der Formatierungssprache XSL und werden erst im nächsten Kapitel näher erläutert. Nehmen Sie daher die jetzige Angabe erst einmal als gegeben hin. Beispiel: kap10\\xpath1.xsl Die Beispiele beziehen sich auf die bisher verwendete Musiksammlung. Es werden alle Lieder der Alben gesucht, die somit Kinder des Elements ALBUM sind. <xsl:for-each select=\"//child::ALBUM/child::LIED\"> <xsl:value-of select=\".\" /> </xsl:for-each> Es werden die Albumtitel selektiert, die über das Attribut stil eine Stilrichtung besitzen. Hochschulversion 10 XML 1.1 - Grundlagen 106 © HERDT-Verlag <xsl:for-each select=\"//TITEL/attribute::stil\"> <xsl:value-of select=\"./parent::TITEL\" /> </xsl:for-each> Es werden die Elemente mit der Bezeichnung TITEL gefunden, die zusätzlich ein Attribut stil mit dem Wert Pop besitzen. <xsl:for-each select=\"//TITEL[@stil='Pop']\"> <xsl:value-of select=\".\" /> </xsl:for-each> Es werden alle Jahrangaben der Alben ausgelesen, ausgehend vom Element TITEL, das ein Nachfahre des selektierten Elements ist. <xsl:for-each select=\"//TITEL/ancestor::*\"> <xsl:value-of select=\"./JAHR\" /> </xsl:for-each> Abkürzungen Die Angabe der Achse child:: kann weggelassen werden, da die Kind-Achse des selektierten Knotens standardmäßig immer angesprochen wird. Die Achse attribute zum Selektieren eines Attributknotens kann mit dem Zeichen abgekürzt werden (z. B. attribute::stil wird zu @stil). Zur besseren Veranschaulichung wird eine XML-Struktur aufgebaut, bei der jedes Element jeweils nur ein Unterelement besitzt.      <STAMM> <GROSSELTERN> <ELTERN> <KINDER attr=\"m\"> <ENKEL attr=\"w\"> </ENKEL> </KINDER> </ELTERN> </GROSSELTERN> </STAMM> Für die nachfolgenden Beispiele eines Selektierungspfades wird angenommen, dass das Element <ELTERN>  selektiert ist. Pfad Erklärung KINDER Der Nachkomme von ELTERN  ist KINDER . Das Element KINDER wird gefun- den. */ENKEL Mit * wird der Knoten  übersprungen, sodass der ENKEL  gefunden wird. /ELTERN/KINDER Das Hauptelement ist nicht das Element ELTERN, sodass die angegebenen Ele- mente nicht gefunden werden. //KINDER[@attr='m'] Der selektierte Knoten ist ELTERN  und gleichzeitig der direkte Vorfahre von Kinder . Da dieses Element auch noch das Attribut attr mit dem Wert m auf- weist, wird auch dieses Element angesprochen. ../ELTERN/KINDER Der Vorfahre des Knotens  ist GROSSELTERN. Die nachfolgenden Unterele- mente ELTERN und KINDER werden gefunden. ./ENKEL Der selektierte Knoten lautet ELTERN . Dieser besitzt keinen direkten Nach- kommen ENKEL. @ Hochschulversion XPath 10 © HERDT-Verlag 107 Knotenprüfung Nachdem Sie mit der Angabe der Achse die Richtung der Auswahl eines Knotens gewählt haben, können Sie mit der Knotenprüfung ein weiteres Kriterium zur Vorauswahl eines Elements angeben. Die Knotenprüfung trifft anhand der vorgegebenen Suchachse eine Auswahl der zu selektierenden Elemente. Die Angabe zur Prüfung kann hierbei der direkte Elementname sein. Beispiel: kap10\\xpath2.xsl Diese Angabe selektiert im gesamten Dokument alle Elementknoten mit dem Namen LIED. <xsl:for-each select=\"/descendant::LIED\"> <xsl:value-of select=\".\" /> </xsl:for-each> Das Zeichen kennzeichnet, dass alle Elemente unterhalb des selektierten Knotens ausgewählt werden sollen. Im folgenden Beispiel sind es alle Kinder des Elements ALBUM. <xsl:for-each select=\"//ALBUM/child::*\"> <xsl:value-of select=\".\" /> </xsl:for-each> Auch die Suche nach einem bestimmten Knotentyp ist möglich. Knotentypen Erläuterung node() Es werden die Knoten ausgewählt, die über die selektierte Achse erreichbar sind. Dabei werden auch die Namensraum- und Attribut- knoten einbezogen. comment() Einen Kommentar innerhalb einer XML-Struktur selektieren Sie mit diesem Knotentyp. Die Knoten werden auch Kommentarknoten ge- nannt. text() Diese Anweisung ermöglicht entlang der Achse das Selektieren von Knoten, die einen Inhalt (Text) haben. processing-instruction() Damit wählen Sie die Prozessoranweisungen der XML-Datei aus. Beispielsweise ist die Angabe von <?xml-stylesheet ...?> eine solche Anweisung. processing-instruction(\"xyz\") Mit der Angabe eines Namens können Sie spezielle Prozessoranwei- sungen der Form <?xyz ...?> auswählen. Beispiel: kap10\\xpath3.xsl Alle Kinder des Elements ALBUM, die keine leeren Elemente sind, werden ausgewählt. <xsl:for-each select=\"//ALBUM/child::*/text()\"> <xsl:value-of select=\".\" /> </xsl:for-each> Es werden alle Elemente INTERPRET des selektierten Knotens ausgewählt. <xsl:for-each select=\"/descendant-or-self::node()/child::INTERPRET\"> <xsl:value-of select=\".\" /> </xsl:for-each> * Hochschulversion 10 XML 1.1 - Grundlagen 108 © HERDT-Verlag Abkürzungen Den aktuellen Knoten self::node() können Sie mit bezeichnen. Für den übergeordneten Knoten parent::node() können Sie zwei Punkte angeben. Einen Knoten sowie alle seine Nachkommen wählen Sie mit den beiden Zeichen aus, statt der Angabe von /descendant-or-self::node(). Beispielsweise lässt sich die nachfolgende Angabe einfach abkürzen: Aus <xsl:for-each select=\"/descendant-or-self::node()/child::INTERPRET\"> </xsl:for-each> wird <xsl:for-each select=\"//INTERPRET\"> </xsl:for-each> Prädikate Für alle Knoten, die nach der Achsenbestimmung und der Knotenprüfung noch ausgewählt sind, können Sie spezielle Prädikate auswerten. Prädikate sind Ausdrücke, die einen Wert liefern und die selektierten Knoten weiter filtern. Neben dem Vergleich von Zeichenketten können die Filter auch logische und arithmetische Abfragen beinhalten. Abfragen Mögliche Operanden Logik or, and, !, <, >, <=, >=, =, != Arithmetik +, -, *, div, mod Da in XML die Zeichen und als Einleitung und Abschluss eines Tags betrachtet werden, müssen Sie die beiden Zeichen jeweils als Entity &lt; sowie &gt; angeben. Im folgenden Beispiel werden über die Abfrage des Knotentyps text() und den Logikausdruck or die Alben der Interpreten Moby und Philip Glass selektiert. <xsl:for-each select=\"//ALBUM/INTERPRET[text()='Moby' or text()='Philip Glass']\"> <xsl:value-of select=\"./parent::node()/TITEL\" /> </xsl:for-each> Funktionen XPath 1.0 umfasst eine Reihe von Funktionen. Analog zu den vorhandenen Datentypen gruppieren sich diese in die vier Bereiche node-set string boolean number In der nachfolgenden Tabelle sind zwei von XPath definierte Funktionen zum Filtern von Knoten aufgelistet. Sie dienen dazu, die Position eines bestimmten Knotens sowie die Gesamtanzahl der Knoten einer Ebene zu ermitteln. Eigenschaft Erläuterung last() Liefert die Position des letzten Knotens der Ebene und somit gleichzeitig die Anzahl der Knoten der entsprechenden Ebene position() Gibt die aktuelle Position des Knotens in der selektierten Ebene aus Hochschulversion XPath 10 © HERDT-Verlag 109 Beispiel: kap10\\xpath4.xsl Aus dem Dokument werden alle Elemente mit der Bezeichnung ALBUM selektiert und der Name des entspre- chenden Interpreten wird ausgegeben. Das letzte Element last() wird hierbei außer Acht gelassen. <xsl:for-each select=\"//ALBUM[position() != last()]\"> <br /><xsl:value-of select=\"./INTERPRET\" /> </xsl:for-each> Es wird, falls vorhanden, vom zweiten Element BILD des Oberelements ALBUM der Attributwert quelle auf- gelistet. <xsl:for-each select=\"//ALBUM/BILD[position() = 2]\"> <br /><xsl:value-of select=\"./@quelle\" /> </xsl:for-each> Von jedem Album werden die ersten drei Lieder selektiert und der Inhalt wird ausgegeben. <xsl:for-each select=\"//LIED[position() &lt;= 3]\"> <br /><xsl:value-of select=\".\" /> </xsl:for-each> Weitere Beispiele zur Selektierung von Elementen über XPath finden Sie auf der Informationsseite des W3- Konsortiums http://www.w3.org/TR/xpath, Abschnitt 2: Kapitel „Location Paths“. 10.3 XPath 2.0 Erweiterungen Die Empfehlung XPath 2.0 ist eine Erweiterung von XPath 1.0. Ein Prozessor für XPath 2.0 verarbeitet über einen Kompatibilitätsmodus auch Ausdrücke der Version 1.0. Wichtige Neuerungen der Version 2.0 sind das erweiterte Datenmodell neue Ausdruckskonstrukte neue Datentypen neue Operatoren die stark erweiterte Funktionsbibliothek Datenmodell Im Unterschied zur Version 1.0 umfasst das Datenmodell von XPath 2.0 neben den Baumstrukturen auch Einzelwerte (sogenannte atomic values) und Sequenzen bzw. Listen. Bei den Einzelwerten kann es sich um verschiedene Daten handeln, beispielsweise um Zeichenfolgen, Zahlen, logische Werte oder Datums- bzw.Zeitwerte. Sequenzen bestehen aus einer geordneten Folge von Bezügen auf Knoten und einzelnen Werten. Eine Schachtelung der Sequenzen ist dabei nicht möglich, sie sind immer flach. Aus der Erweiterung des Datenmodells ergeben sich viele Erweiterungen hinsichtlich der Operationen und Funktionen. So gibt es beispielsweise Möglichkeiten zur Erzeugung neuer Einzelwerte und Sequenzen. Im Gegensatz zu XPath 1.0, bei dem das Ergebnis eines Ausdrucks eine ungeordnete Knotenmenge ist, ergibt die Auswertung in der Version 2.0 eine Sequenz. Hochschulversion 10 XML 1.1 - Grundlagen 110 © HERDT-Verlag Ausdruckskonstrukte Mit der Erweiterung des Datenmodells um Sequenzen wird der effektive Umgang mit diesen notwendig. Der for-Ausdruck ermöglicht dies. Bei seiner Ausführung auf eine Sequenz wird die im Rückgabeausdruck angegebene Operation auf alle Datenelemente dieser angewendet. for $Bereichsvariable in <Bindungsseqenz> return <Rückgabeausdruck> Die Bereichvariable wird durch das Zeichen $ gekennzeichnet. Das Schlüsselwort in gibt die Bindungssequenz an. Die Bindungssequenz kann ein Zahlenbereich aber auch ein XPath Ausdruck zur Ermittlung von Knoten sein. Nach dem Schlüsselwort return steht der auszuwertende Ausdruck. So wird der Ausdruck for $i in 1 to 4 return $i*$i in die Sequenz 1, 4, 9, 16 ausgewertet. Um alle Kindknoten des aktuellen Knotens zu ermitteln, kann der Ausdruck for wie folgt eingesetzt werden: for $k in child::* return name($k) Eine weitere neue Möglichkeit der Ausdruckskonstrukte in XPath 2.0 stellen bedingte Ausdrücke mit dem Konstrukt if … then … else oder die Überprüfung auf das Vorhandensein von Knoten in Abhängigkeit von Bedingungen mit some oder every dar. Datentypen Das Modell der Datentypen in XPath 2.0 basiert auf dem XML-Schema. Dabei stehen die Datentypen zur Darstellung des eigentlichen XML Dokuments nicht im Vordergrund. Umfangreiche Neuerungen gibt es vor allem bei numerischen Datentypen (neben number stehen integer, decimal, float und double zur Verfügung), Datentypen für Datums- und Zeitwerte, der Möglichkeit der Erstellung benutzerdefinierter Datentypen. Eine vollständige Übersicht aller Datentypen befindet sich unter http://www.w3.org/TR/xpath-datamodel/: Hochschulversion XPath 10 © HERDT-Verlag 111 Operatoren Aus dem erweiterten Datenmodell ergab sich die Notwendigkeit der Bereitstellung neuer Operationen zu dessen Nutzung. Die Tabelle enthält einen Überblick ausgewählter Operationen: für den Vergleich von Knoten is vergleicht, ob die von zwei unterschiedlichen Ausdrücken gelieferten Knoten identisch sind <<, >> vergleichen die Knotenreihenfolge für die Kombination von Knotensequenzen union Vereinigung zweier Sequenzen (ohne Duplikate) intersect Vereinigung zweier Sequenzen (gegebenenfalls mit Duplikaten) except erzeugt Vereinigungssequenz mit allen Knoten der ersten Sequenz, die nicht in der zweiten enthalten sind Hochschulversion 10 XML 1.1 - Grundlagen 112 © HERDT-Verlag für die Arbeit mit ganzen Zahlen idiv Division von ganzen Zahlen to Angabe ganzzahliger Bereiche In der Version 2.0 stehen für Vergleichsoperationen alternative Operationen zur Verfügung: XPath 1.0 XPath 2.0 XPath 1.0 XPath 2.0 = eq <= le != ne > gt < lt >= ge Für die verschiedenartigen neuen Datentypen existiert ebenfalls eine Vielzahl neuer Operatoren, z. B. für den Umgang mit Datum und Zeit. Funktionen XPath 2.0 enthält eine sehr große Anzahl neuer Funktionen. Neben Funktionen, deren Existenz sich aus dem neuen Datenmodell ergibt, wie beispielsweise für den Umgang mit Sequenzen, sind dies auch viele Funktionen, die einen besseren Umgang mit den bereits in der Version 1.0 vorhandenen Datentypen ermöglichen. Dies betrifft zum Beispiel die Möglichkeiten der Zeichenkettenoperationen inlusive der Anwendung von regulären Ausdrücken. Eine komplette Liste der in XPath 2.0 vorhandenen Funktionen und Operatoren finden Sie hier: (http://www.w3.org/TR/xquery-operators/). 10.4 Übung Elemente mit XPath selektieren Übungsdateien: kap10\\musiksammlung.xml, kap10\\musiksammlung.dtd Ergebnisdateien: kap10\\uebung1.xml, kap10\\uebung1.xsl, kap10\\uebung2.xml, kap10\\uebung2.xsl, kap10\\uebung3.xml, kap10\\uebung3.xsl, kap10\\uebung4.xml, kap10\\uebung4.xsl Die vorgegebene Musiksammlung besitzt folgende Struktur: <MUSIKSAMMLUNG> <ALBUM> <AUTOR> </AUTOR> <INTERPRET> </INTERPRET> <!-- oder <GRUPPE> </GRUPPE> --> <TITEL stil=\"\" bewertung=\"\"> </TITEL> <GESAMTZEIT> </GESAMTZEIT> <LABEL> </LABEL> <JAHR> </JAHR> <BILD typ=\"\" quelle=\"\" /> <LIED> </LIED> </ALBUM> </MUSIKSAMMLUNG>  Geben Sie einen XPath-Ausdruck an, der die Namen aller Interpreten und Gruppen im XML- Dokument selektiert. Hochschulversion XPath 10 © HERDT-Verlag 113  Ermitteln Sie die Titel aller Alben, die vom Stil Klassik sind.  Ermitteln Sie zusätzlich die Namen der Autoren, die die klassischen Alben in die Sammlung aufgenommen haben.  Gesucht werden sollen die Alben, die vor dem Jahr 1990 erschienen sind. Hochschulversion 11 XML 1.1 - Grundlagen 114 © HERDT-Verlag 11 XSL und XSLT In diesem Kapitel erfahren Sie aus welchen Komponenten XSL besteht wie einzelne Elementinhalte mittels XSLT ausgelesen werden wie Sie durch HTML-Befehle in XSL-Dateien eine formatierte Ausgabe erhalten Voraussetzungen XML Kenntnisse Grundlegende HTML-Kenntnisse 11.1 Einführung in XSL XSL Komponenten XSL (eXtensible Stylesheet Language) erweitert die Möglichkeiten von XML. Es dient sowohl zur Transforma- tion von einem Datenformat in ein anderes als auch zur Präsentation der Daten. Für die Darstellung im Browser kann als Ausgabeformat HTML gewählt werden. Daneben bestehen Möglichkeiten, die Daten beispielsweise für die Darstellung in Form einer PDF- oder Postscript-Datei aufzubereiten. XSL ist eine Zusammenfassung mehrerer Empfehlungen des W3C. Ein Dokument mit einer kurzen Einordnung der Thematik und mit Verweisen auf die konkreten Empfehlungen der einzelnen Bestandteile und deren aktuelle Versionen ist im Internet auf den Seiten des W3C verfügbar (http://www.w3.org/Style/XSL/). XSL untergliedert sich in drei Komponenten: XSLT (XSL Transformation) wird für die Auswertung und Umwandlung eines XML Ausgangsdokuments in ein neues Dokument verwendet. Für den Umwandlungsprozess können Regeln definiert werden. Diese ermöglichen sowohl die Auswahl von einzelnen Elementen und Attributen zur Übernahme in das Zieldokument als auch die Bearbeitung der Struktur des zu erstellenden Dokuments, bis hin zu einer im Vergleich zum Ausgangsdokument völligen Neugestaltung dieser. Die Transformationsregeln werden in einem XSL Stylesheet festgelegt, welches dem zu bearbeitenden XML-Dokument zugeordnet wird. Dieses Stylesheet teilt dem verarbeitenden Prozessor mit, wie die logische Baumstruktur eines XML-Dokuments in eine repräsentative Struktur umgewandelt wird. Das XSL-Stylesheet selbst ist ebenfalls ein XML-Dokument und unterliegt damit den Regeln für deren Aufbau. Die Empfehlung des W3C zu XSLT finden Sie unter http://www.w3.org/TR/xslt20/. Aktuell ist die Version XSLT 2.0 aus dem Jahr 2007. XPath zur Selektion und zum Auswerten einzelner Teile eines XML Dokuments (vgl. Kapitel 10). XSL-FO ist die Formatierungssprache von XSL. Sie umfasst in einer XML-Syntax die wichtigsten Formatierungsanweisungen hinsichtlich Typographie und Layout zur Gestaltung von Dokumenten. Die Empfehlung des W3C zu XSL-FO 1.1 finden Sie unter http:// http://www.w3.org/TR/xsl/ (noch als Bestandteil der Empfehlung zu XSL) aus dem Jahr 2006. Des Weiteren gibt es einen Arbeitsentwurf für XSL-FO aus dem Jahr 2012 (http://www.w3.org/TR/xslfo20/). XSL XSL-FO XSLT XPath besteht aus Unterteilung von XSL Hochschulversion XSL und XSLT 11 © HERDT-Verlag 115 XSL-Phasen Die Bearbeitung eines XML-Dokuments mit XSL besteht aus zwei Phasen. BUCH AUTOR TITEL GENRE PREIS BESCHREIBUNG DATUM ISBN XSLT PHASE 1 PHASE 2 XML-Dokument XSL SVG PDF Postscript ... FO XHTML HTML WML Phase 1 Die erste Phase heißt Baumtransformation. In dieser Phase wird aus der XML-Baumstruktur unter Anwendung von XSLT und XPath eine weitere Baumstruktur erstellt. Wie die neue Struktur aufgebaut ist, wird durch Vorlagen bestimmt. Die Vorlagen (engl. Templates) bestehen aus verschiedenen Selektoren. Mit den Selektoren bestimmen Sie, welche Elemente angesprochen und in die neue Struktur übernommen werden sollen. Diese Struktur kann durch die Selektion der Daten sehr stark von der ursprünglichen Struktur abweichen. In der Transformationsphase werden die Formatierungen der Elemente noch nicht berücksichtigt. Mithilfe von XSLT, den Vorlagen und einem XSLT-Prozessor können auch die XSL-FO Formatierungsobjekte wie Seiten, Absätze, Tabellen und die Formatierungseigenschaften wie Einrückungen, Zeilenabstände, Farbe, erzeugt werden. Durch den Einsatz von HTML Befehlen in der .xsl Datei ist es möglich, als Ergebnis der Anwendung auf das XML-Dokument direkt ein HTML- oder XHTML-Dokument zu erzeugen. In diesem Fall entfällt die Phase zwei. Phase 2 In der Phase 2 werden Formatierungsobjekte in eine druckbare Darstellung umgewandelt. Dazu ist eine weitere Software, der XSL-FO Prozessor notwendig. Apache-FOP ist eine kostenlose Software, die dies leistet. Sie basiert auf Java und ist somit plattformunabhängig. Sie finden die Software unter http://xmlgraphics.apache.org/fop/. Mit Apache-FOP sind Sie in der Lage, mithilfe von XSL-FO verschiedene Ausgabeformate, wie z. B. PDF, SVG, PostScript und Text zu erzeugen. Apache-FOP wurde hauptsächlich für die PDF-Ausgabe entwickelt. Im Vergleich zur Formatierung eines Textes mit CSS ist XSL-FO deutlich komplexer. Daraus resultieren in der Anwendung sowohl an den Ersteller von XSL-Dokumenten als auch an die Entwickler von XSL-FO Prozessoren deutlich höhere Anforderungen, was eine Ursache für die noch nicht so weite Verbreitung von XSL-FO ist. Für die Darstellung der erzeugten XML-Dokumente in Kapitel 11 und 12 werden HTML-Anweisungen in die XSL-Dateien integriert. Der XSL-Prozess beschränkt sich hier immer nur auf die erste Phase. XSL als Namensraum Ein XSL-Stylesheet ist formal ein wohlgeformtes XML-Dokument mit einem festgelegten Namensraum. <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\"> Über das angelegte Präfix xmlns:xsl wird der Namensraum xsl definiert. Die Bezeichnung ist beliebig, es wird aber meistens das Kürzel xsl verwendet. XML-Elemente, die zu diesem Namensraum gehören, werden somit als Befehle interpretiert, die der XSLT-Prozessor verarbeiten soll. Alle anderen Tags, wie z. B. die be- kannten HTML-Tags, werden in den nachfolgenden Beispielen unverändert an die Ausgabe im Browser weitergeleitet. Im Umgangssprachgebrauch wird gelegentlich, obwohl dies nicht korrekt ist, XSLT mit XSL gleichgesetzt. Grund dafür ist u. a. einerseits die Verwendung des Namensraumes XSL bei der Anwendung von XSLT- Anweisungen und andererseits die Speicherform von XML-Dokumenten mit XSLT-Anweisungen als .xsl Dateien. Hochschulversion 11 XML 1.1 - Grundlagen 116 © HERDT-Verlag 11.2 Einbinden einer XSL-Datei Um den Inhalt eines XML-Dokuments über ein XSL-Stylesheet zu formatieren, fügen Sie unterhalb des XML- Prologs die Zeile für die Stylesheet-Deklaration ein. Die Vorlagen und Selektoren zum Auswählen bestimmter XML-Elemente werden in einer externen Datei definiert. Dem Dokument wird diese Datei, das externe Style- sheet, über eine Processing Instruction (PI) zugeordnet. <?xml-stylesheet type=\"text/xsl\" href=\"XSL-Datei\"?> Grundlegend erfolgt die Einbettung eines XSL-Stylesheets wie die Einbindung eines Cascading Stylesheets. Es muss lediglich als Wert des Attributs href der Name einer XSL-Datei und als Dateityp die Kennung text/xsl angegeben werden. <?xml-stylesheet type=\"text/xsl\" href=\"auswahl.xsl\"?> In diesem Beispiel wird in eine XML-Datei die XSL-Datei auswahl.xsl eingebunden, um die XML-Daten für die Ausgabe zu transformieren. 11.3 Templates Template anlegen Templates legen fest, welche Elemente einer XML-Struktur zur weiteren Verarbeitung genutzt werden sollen. Das XSL-Element zur Definition einer Vorlage lautet: <xsl:template match=\"Pattern\" name=\"foo\"> <!-- Aktionsteil --> </xsl:template> Diese Anweisung besagt, dass ein Element der Struktur selektiert werden soll, das dem angegebenen Muster (Pattern) entspricht. Der Aktionsteil legt fest, welche weiteren Arbeitsschritte folgen sollen. Die Elemente in XSL sind die Vorlagen, welche über die Anweisung xsl:template erkennbar sind. Jedes Template beschreibt, für welches Element es in dem XML-Dokument gültig ist. Dieses Element, das auch Knoten genannt wird, wird über das Attribut match bestimmt. Der XSLT-Prozessor liest dabei die XML- Baumstruktur ein und vergleicht jedes XML-Element mit dem Attributwert match. Existiert ein solches Element, wird es über die Funktionen des Aktionsteils in die neue XML-Struktur übernommen. Die Adressie- rung erfolgt dabei über XPath. Grundlegend kann diese Arbeitsweise folgendermaßen beschrieben werden: Wenn ein Element mit dem Namen, das zum Muster passt, im Dokument gefunden wird, dann führe den nachfolgenden Aktionsteil aus. Das Attribut name ist optional. Es legt eine eindeutige Bezeichnung für die Vorlage fest. Die Angabe von foo steht für einen zulässigen Namen. Templates in Templates Durch die Verschachtelung von XML-Elementen ist es notwendig, dass Sie innerhalb eines Templates auf andere Templates zugreifen können. Innerhalb des XSLT-Dokuments kann deshalb in andere Vorlagen verzweigt werden. Dies erreichen Sie im Aktionsteil einer Vorlage mit dem Aufruf des XSL-Elements xsl:apply-templates. <xsl:apply-templates select=\"Pattern\" /> Hochschulversion XSL und XSLT 11 © HERDT-Verlag 117 Der Befehl selektiert alle Kind-Elemente des im Suchmuster angegebenen Dokumentknotens. Das Attribut select ist optional. Falls es nicht angegeben ist, werden alle Elemente des gewählten Suchmusters extra- hiert. Der Befehl xsl:apply-templates ist immer nur unterhalb von xsl:template erlaubt. Beispiel: kap11\\tutorial.xml Legen Sie die nachfolgende XML-Struktur an und binden Sie die XSL-Datei tutorial.xsl ein, um die Elemente OBERELEMENT und SICHTBAR anzusprechen. Das Element UNSICHTBAR soll im nachfolgenden Beispiel außer Acht gelassen werden. <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <?xml-stylesheet type=\"text/xsl\" href=\"tutorial.xsl\"?> <OBERELEMENT> <SICHTBAR> Element, das angesprochen werden soll. </SICHTBAR> <UNSICHTBAR> Element, das NICHT angesprochen werden soll. </UNSICHTBAR> </OBERELEMENT> Beispiel: kap11\\tutorial.xsl Erstellen Sie die XSL-Datei, um die Daten der XML-Struktur zu selektieren und für jedes Element eine entspre- chende Meldung auszugeben.            <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"/\"> <html><head><title>XSL-Templates</title></head><body> <h3>Ansprechen einzelner XML-Elemente</h3> <xsl:apply-templates /> </body></html> </xsl:template> <xsl:template match=\"OBERELEMENT\"> <p>Die XML-Struktur enthält das Element OBERELEMENT.</p> <xsl:apply-templates select=\"SICHTBAR\" /> </xsl:template> <xsl:template match=\"UNSICHTBAR\"> <p>Die XML-Struktur enthält das Element UNSICHTBAR.</p> </xsl:template> <xsl:template match=\"SICHTBAR\"> <p>Die XML-Struktur enthält das Element SICHTBAR.</p> </xsl:template> </xsl:stylesheet>  Der Prolog eines XML-Dokuments wird angegeben, da es sich bei einer XSL-Datei ebenfalls um ein XML- Dokument handelt.  Die XSL-Datei wird als Stylesheet-Datei definiert und erhält zum eindeutigen Ansprechen der einzelnen Elemente den Namensraum xsl.  Über das erste Template wird das oberste Element der XML-Datei angesprochen.  Nach der Angabe einzelner HTML-Tags, die an den Browser weitergereicht werden, kontrolliert der XSLT-Prozessor, ob ein weiteres Element existiert. Findet er ein nächstes Element, verzweigt er in das Template, welches dem Namen des nächsten Elements entspricht. Der jeweilige Attributwert von match muss übereinstimmen. Das erste Element lautet OBERELEMENT, somit wird in das Template  verzweigt. Hochschulversion 11 XML 1.1 - Grundlagen 118 © HERDT-Verlag <OBERELEMENT> <SICHTBAR> Element, das angesprochen werden soll. </SICHTBAR> <UNSICHTBAR> Element, das NICHT angesprochen werden soll. </UNSICHTBAR> </OBERELEMENT>  Da der Attributwert mit dem Namen des nächsten Elements übereinstimmt, wird der umschlossene Aktionsteil ausgeführt.  Der Aktionsteil des Templates besteht darin, das HTML-Tag <p> an den Browser zu übergeben. Mit dem hinterlegten Inhalt wird bekannt gegeben, dass das gesuchte Element OBERELEMENT gefunden wurde.  Es wird auf das nächste Element verwiesen. Durch die Angabe des Attributs select muss das nächste Element SICHTBAR heißen. Existiert es, verzweigt der XSLT-Prozessor in das entsprechende Template .  In dieses Template wird verzweigt, wenn nach dem XML-Knoten UNSICHTBAR gesucht wird. In diesem Beispiel wird das Template jedoch nicht angesprochen, sodass an dieser Stelle keine Ausgabe erfolgt.  Dieses Template wird ausgeführt, wenn nach dem Element SICHTBAR gesucht wird. <OBERELEMENT> <SICHTBAR> Element, das angesprochen werden soll. </SICHTBAR> <UNSICHTBAR> Element, das NICHT angesprochen werden soll. </UNSICHTBAR> </OBERELEMENT>  Durch die Ausgabe von <p> wird gezeigt, dass das gesuchte Element SICHTBAR gefunden wurde.  Die Vorlage wird geschlossen. Der Prozessor kehrt über das Template  zur Stelle  zurück. Da keine weiteren Anweisungen folgen, wird die Transformation der Daten beendet. Spezielle Vorlage ansprechen Standardmäßig wird über die XSL-Anweisung <xsl:apply-templates /> die nächste Vorlage aufgerufen und ausgeführt. Mit der optionalen Vergabe eines Template-Namens über die Anweisung <xsl:template match=\"Pattern\" name=\"foo\"> haben Sie die Möglichkeit, gezielt eine bestimmte Vorlage aufzurufen. Das XSL-Element zum Ansprechen des Templates lautet: <xsl:call-template name=\"foo\" /> </xsl:call-template> Mit der zusätzlichen Angabe des Attributs name legen Sie fest, dass nicht die nächste, sondern eine unter diesem Namen angelegte Vorlage aufgerufen werden soll. Die Angabe von foo steht hier für einen zulässi- gen Namen. Beispiel: kap11\\call_template.xsl Das gezielte Ausführen von Vorlagen wird über die Funktion xsl:call-template gesteuert, indem mit dem Attribut name bezeichnete Vorlagen direkt aufgerufen werden.   <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"/\"> <html><head><title>call-template</title></head> <body> <xsl:call-template name=\"vorlage2\"> </xsl:call-template> </body></html> </xsl:template> Ausgabe der XML-Daten über die XSL- Transformation im Browser Hochschulversion XSL und XSLT 11 © HERDT-Verlag 119   <xsl:template match=\"OBERELEMENT\" name=\"vorlage1\"> <!-- Aktionsteil --> </xsl:template> <xsl:template match=\"ELEMENT\" name=\"vorlage2\"> <!-- Aktionsteil --> </xsl:template> </xsl:stylesheet>  Diese Anweisung ruft die Vorlage mit der Bezeichnung vorlage2 auf.  Der Aufruf des Templates wird abgeschlossen. Es kann auch die verkürzte Schreibweise für ein leeres Element verwendet werden (<xsl:call-template name=\"vorlage2\" />).  Dieses Template erhält den Namen vorlage1. Innerhalb dieses Beispiels wird es nicht aufgerufen.  Dies ist das Template vorlage2, das von  aufgerufen und ausgeführt wird. 11.4 Selektion mit Filter in XPath Der Mustervergleich von Elementen beruht auf der Sprache XPath. Sie stellt die verschiedenen Abfrage- mechanismen zur Verfügung und steuert somit den Zugriff auf die XML-Elemente. Mithilfe von XPath können Sie nicht nur den Namen eines Elements vergleichen, sondern auch speziellere Abfragen zu Element- kombinationen, Attributnamen und Attributwerten gestalten. Beispiel: kap11\\xpath.xml Für die Auflistung der möglichen Mustervergleiche wird die Struktur der erweiterten Musiksammlung herangezogen.        <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <MUSIKSAMMLUNG> <ALBUM typ=\"CD\"> <INTERPRET>Moby</INTERPRET> <TITEL stil=\"Pop\">Play</TITEL> <GESAMTZEIT>63:03</GESAMTZEIT> <LABEL>Mute Records Limited</LABEL> <ERSCHEINUNGSJAHR>1999</ERSCHEINUNGSJAHR> <LIED> <LIEDTITEL>Honey</LIEDTITEL> <TITELZEIT>3:28</TITELZEIT> </LIED> <LIED> <LIEDTITEL>Find my baby</LIEDTITEL> <TITELZEIT>3:59</TITELZEIT> </LIED> </ALBUM> <ALBUM typ=\"Vinyl\"> <!-- ... --> </ALBUM> </MUSIKSAMMLUNG> Hochschulversion 11 XML 1.1 - Grundlagen 120 © HERDT-Verlag <xsl:template match=\"...\"> findet ALBUM die Elemente <ALBUM> a   ALBUM/INTERPRET die Elemente <INTERPRET>, die direkte Unterknoten (Kind, Child) des Elements <ALBUM> sind  ALBUM//TITELZEIT alle Elemente <TITELZEIT>, die mittelbare oder unmittelbare Kinder des Elements <ALBUM> sind   ALBUM/LIED[1] das erste Element <LIED>, das ein Unterelement des Elements <ALBUM> ist . In eckigen Klammern wird die Nummer des Elements angegeben. //LIED die Elemente <LIED> in beliebiger Tiefe im Dokument .//LIED die Elemente <LIED> in beliebiger Tiefe von der vorherigen Selektion aus gesehen (nicht im ganzen Dokument) ALBUM/*/TITELZEIT die Elemente <TITELZEIT>, die einen Vorfahren vom Typ <ALBUM> haben  . Das Zeichen steht hierbei für ein beliebiges dazwischen befindliches Element. ALBUM/TITEL/@stil die Elemente <TITEL> mit dem Attribut stil, die gleichzeitig Kinder des Elements <ALBUM> sind  ALBUM/TITEL[@stil='Pop'] die Elemente <TITEL> mit dem Attribut stil und dem Attributwert Pop, die gleichzeitig Kinder des Elements <ALBUM> sind  ALBUM/INTERPRET|GRUPPE die Unterelemente <INTERPRET> oder <GRUPPE> des Elements <ALBUM>  11.5 Inhalte der Elemente ausgeben Mithilfe der Templates und der Filter von XPath haben Sie eine bestimmte XML-Struktur selektiert. Die ent- sprechenden Knoten des Baumes werden zwar selektiert, jedoch wird kein Wert eines Elements ausgegeben. Sie müssen dem XSL-Prozessor mitteilen, welche Daten der gewählten Struktur verwendet werden sollen. Der Befehl zum Einfügen eines Elementinhalts lautet: <xsl:value-of select=\"Pattern\" /> Der mit xsl:template selektierte Knoten der XML-Baumstruktur wird mit dem angegebenen Pattern vergli- chen. Existiert ein Element, auf das das Muster zutrifft, wird dessen Inhalt an das zu verarbeitende Programm weitergegeben. Beispiel: kap11\\tutorial2.xml <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <?xml-stylesheet type=\"text/xsl\" href=\"tutorial2.xsl\"?> <TEXT> <RED>XSL machts möglich...</RED> <BOLD>Die Daten werden fett dargestellt oder</BOLD> <ITALIC> kursiv, je nach angelegter Transformation.</ITALIC> </TEXT> Die XML-Datei besteht aus der Struktur mit dem Hauptelement TEXT und dessen drei Unterelementen RED, BOLD und ITALIC. Die eingebundene XSL-Datei tutorial2.xsl enthält die Befehle zum Auswählen der jeweili- gen Elemente. * Hochschulversion XSL und XSLT 11 © HERDT-Verlag 121 Beispiel: kap11\\tutorial2.xsl Das Beispiel zeigt Ihnen die Wirkungsweise des XSL-Stylesheets xsl:value-of. Als Ergebnis wird hier der Inhalt der Elemente RED und ITALIC ausgegeben.      <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template> <html><head><title>Elementinhalte ausgeben</title></head><body> <xsl:value-of select=\"//RED\" /> <br /> <xsl:value-of select=\"//ITALIC\" /> <br /> </body></html> </xsl:template> </xsl:stylesheet>  Der Namensraum xsl, der im gesamten Dokument Gültigkeit haben soll, wird definiert.  Wenn kein Pattern für die Selektion eines Elements angegeben ist, wird standardmäßig das Haupt- element der XML-Datei tutorial2.xml selektiert.  Der Inhalt des Elements RED, das sich unterhalb des selektierten Elements TEXT befindet, wird an das Programm, in diesem Fall an den Browser, weitergegeben.  Ebenso wird der Inhalt des Elements ITALIC ausgegeben.  Die Vorlage wird geschlossen und somit die Auswahl der Elemente beendet. Ergebnis der Datenselektion im Browser Zur Formatierung der Dateninhalte im Browser können Sie die üblichen HTML-Tags sowie Stylesheet-Anga- ben verwenden. Ebenso ist es möglich, die Reihenfolge der ausgegebenen XML-Daten zu beeinflussen, indem Sie die Elemente in unterschiedlicher Reihenfolge selektieren. Beispiel: kap11\\tutorial3.xsl       <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"/\"> <html><head><title>Elementinhalte ausgeben</title></head><body> <p><b><xsl:value-of select=\"//BOLD\" /></b></p> <p><i><xsl:value-of select=\"//ITALIC\" /></i></p> <h3 style=\"color:red\"><xsl:value-of select=\"//RED\" /></h3> </body></html> </xsl:template> </xsl:stylesheet>  Der Namensraum xsl, der im gesamten Dokument Gültigkeit haben soll, wird definiert.  Durch die Angabe des Pfads wird das Hauptelement TEXT der XML-Datei tutorial3.xml selektiert.  Der Inhalt des Elements BOLD, das sich unterhalb des selektierten Elements TEXT befindet, wird an den Browser weitergegeben. Durch die Angabe der HTML-Elemente P und B wird der Dateninhalt als fett formatierter Absatz angezeigt.  Der Inhalt des Unterelements ITALIC wird kursiv dargestellt.  Dem Dateninhalt des Elements RED wird eine Überschrift der dritten Ordnung zugewiesen, die über die Stylesheet-Angabe style=\"color:red\" in roter Farbe dargestellt wird.  Die Vorlage wird geschlossen und somit die Auswahl der Elemente beendet. / Hochschulversion 11 XML 1.1 - Grundlagen 122 © HERDT-Verlag Anzeige der formatierten Daten im Browser 11.6 Reihenfolge der Template-Aufrufe Anhand eines Beispiels sollen die Auswirkungen der verschiedenen Template-Aufrufe gezeigt werden. Beispiel: kap11\\test.xml Zur besseren Visualisierung der Ergebnisse werden die einzelnen Elemente mit Buchstaben und die Inhalte mit einer entsprechenden Zahl angegeben. So steht [b1] für das erste Element b, [b2] für das zweite Element b, [b1-c1] für das erste Element c, das ein Kind des ersten Elements b ist, usw. <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?> <?xml-stylesheet type=\"text/xsl\" href=\"test.xsl\"?> <a> <b> [b1] </b> <bc> <c> [b1-c1] </c> <c> [b1-c2] </c> </bc> <b> [b2] </b> <d> [d1] </d> <d> [d2] </d> </a> Beispiel: kap11\\test.xsl Mit dieser XSL-Datei sollen verschiedene Templates ausgeführt und somit verschiedene Elemente ausgegeben werden.     <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"a\"> <html><head><title>Template-Test</title></head> <body> <xsl:apply-templates /> </body></html> </xsl:template> <xsl:template match=\"b\"> <p>b = <xsl:value-of select=\".\" /> </p> <xsl:apply-templates select=\"c\" /> </xsl:template> <xsl:template match=\"bc\"> <p>bc = <xsl:value-of select=\".\" /> </p> <xsl:apply-templates /> Hochschulversion XSL und XSLT 11 © HERDT-Verlag 123  </xsl:template> <xsl:template match=\"c\"> <p>c = <xsl:value-of select=\".\" /> </p> </xsl:template> </xsl:stylesheet>  Das Hauptelement a der XML-Datei wird selektiert.  Mit apply-templates wird in die anderen Vorlagen verzweigt. Wenn Sie diesen Aufruf nicht angeben, werden die anderen Vorlagen übersprungen. Im weiteren Verlauf soll dieser Aufruf abgewandelt und das entsprechende Ergebnis sichtbar gemacht werden.  Dies ist das erste Template, mit dem die Unterelemente b selektiert werden, ausgehend vom aktuellen Element. Die Inhalte der Elemente werden ausgegeben und es wird in das nächste Template c verzweigt.  Dieses Template selektiert das Element bc und gibt dessen Inhalt aus. Da in der bereits festgelegten XML-Datei zwei Unterelemente c festgelegt sind, werden deren Inhalte ausgegeben.  Mit dem Template werden die Unterelemente nochmals separat selektiert und deren Inhalte einzeln ausgegeben. Durch den nicht namentlich angegebenen Template-Aufruf in Zeile  werden sämtliche Unterelemente von dem Element a aufgelistet. Es werden zum Schluss die Inhalte der beiden Elemente d ausgegeben, obwohl diese nicht speziell über ein Template angesprochen werden. In der nachfolgenden Tabelle wird die jeweilige Ausgabe im Browser dargestellt, wenn Sie den Template- Aufruf in Zeile  ändern. Template-Aufruf Ausgabe im Browser <xsl:apply-templates select=\"b\" /> b = [b1] b = [b2] Die Unterelemente b werden selektiert und deren Inhalte ausgegeben. Es werden auch noch die anderen Templates aufgerufen. Da die aktuellen Elemente b jedoch keine weiteren Unterelemente besitzen, wird nicht in diese Templates verzweigt. Template-Aufruf Ausgabe im Browser <xsl:apply-templates select=\"bc\" /> bc = [b1-c1] [b1-c2] c = [b1-c1] c = [b1-c2] Ausgehend vom Hauptelement a werden die Unterelemente bc selektiert und die Werte ausgegeben. Danach wird das nächste Template aufgerufen. Da das Element bc die Unterelemente c besitzt, wird dieses Template ausgeführt. Template-Aufruf Ausgabe im Browser <xsl:apply-templates select=\"c\" /> --nichts-- Da sich im Hauptelement kein direktes Unterelement c befindet, wird nichts ausgegeben. Template-Aufruf Ausgabe im Browser <xsl:apply-templates select=\"*/c\" /> c = [b1-c1] c = [b1-c2] Ausgabe der XSL- Anweisungen Hochschulversion 11 XML 1.1 - Grundlagen 124 © HERDT-Verlag Die Angabe des Zeichens steht für ein beliebiges Oberelement von c. Die Inhalte der beiden Elemente c werden ausgegeben, weil bc als Unterelement von a die Unterelemente c besitzt. 11.7 Übungen Übung 1: Theoretische Frage zu XSL Übungsdatei: -- Ergebnisdatei: kap11\\uebung1-3.html  Nennen Sie die Processing Instruction zum Einbinden einer XSL-Datei in eine XML-Datei.  Erklären Sie, wie ein XSL-Namensraum innerhalb der XSL-Datei erstellt wird.  Nachfolgend sind verschiedene Selektionsfilter aufgelistet. Erläutern Sie, welche Elemente hiermit selektiert werden. //ELEMENT1 .//ELEMENT2 ELEMENT1/ELEMENT2[1] ELEMENT1/ELEMENT2[@attribut1] Übung 2: Daten transformieren und formatieren Übungsdateien: kap11\\ms.dtd, kap11\\uebung4.xml Ergebnisdatei: kap11\\uebung4.xsl Erstellen Sie mithilfe der XSL-Transformation die nachfolgende HTML-Ansicht, indem Sie die entsprechenden Daten aus der bereits bestehenden Musiksammlung auslesen. Übung 3: Daten transformieren und formatieren Übungsdateien: kap11\\kfz.dtd, kap11\\uebung5.xml Ergebnisdatei: kap11\\uebung5.xsl Lassen Sie sich aus der Fahrzeugverwaltung mithilfe von XSL die Hersteller mit ihren jeweili- gen Fahrzeugmodellen auflisten. Stellen Sie die jeweiligen Daten Modell, Hubraum und Leis- tung übersichtlich in einer HTML-Tabelle dar. * Hochschulversion XSL und XSLT 11 © HERDT-Verlag 125 Hochschulversion 12 XML 1.1 - Grundlagen 126 © HERDT-Verlag 12 XSLT-Elemente In diesem Kapitel erfahren Sie wie Sie zur Mehrfachauswahl von Elementen Schleifen durchführen können wie Elemente auf bestimmte Eigenschaften getestet werden können wie Sie auf verschiedene Rückgabewerte reagieren können Voraussetzungen Grundlegender Aufbau von XSLT-Befehlen 12.1 Schleifen und Fallunterscheidungen Bisher konnten Sie mit dem Aktionsteil <xsl:value-of select=\"Pattern\"> jeweils nur ein Element inner- halb einer Vorlage ansprechen. Um mehrere Elemente mit gleichem Namen zu selektieren, benötigen Sie die Schleifenfunktion. Diese führt einen Aktionsteil so lange aus, bis der angegebene Mustervergleich nicht mehr übereinstimmt. Dies ist beispielsweise nützlich, wenn Sie in der Musiksammlung alle vorhandenen Interpreten auslesen möchten. 12.2 Schleifenbildung Die Schleife xsl:for-each ermöglicht es, einen ganzen Knotensatz innerhalb einer einzigen Regel zu verarbeiten. <xsl:for-each select=\"Pattern\"> <!-- Aktionen --> </xsl:for-each> xsl:for-each weist den Parser an, nach allen Elementen zu suchen, die mit dem Wert des Attributs select übereinstimmen. Beispiel Aus einer XML-Struktur sollen die Elemente ELEMENT1 selektiert und verschiedene Aktionen ausgeführt werden.    <xsl:for-each select=\"//ELEMENT1\"> <!-- Aktionsteil --> </xsl:for-each>  Diese Anweisung sucht nach dem ELEMENT1.  Nach dem Auffinden des gesuchten Elements wird der Aktionsteil ausgeführt.  Die Schleife wird beendet. Der Prozessor springt zurück zum Anfang der Schleife . Es wird erneut ge- prüft, ob ein weiteres Element ELEMENT1 vorhanden ist. Ist dies der Fall, wird die Schleife wiederholt ausgeführt. Dies geschieht so lange, bis kein Element mehr gefunden wurde. Die Schleife wird daraufhin verlassen. Hochschulversion XSLT-Elemente 12 © HERDT-Verlag 127 Beispiel: kap12\\for-each1.xsl Die nachfolgenden Beispiele werden mit den Daten der Musiksammlung realisiert. Es sollen in einer Schleife alle Lieder eines Albums ausgegeben werden.  <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"/\"> <html> <head><title>Liedübersicht</title></head> <body>  <xsl:for-each select=\"//ALBUM\">  <xsl:value-of select=\"./INTERPRET|./GRUPPE\" />  <xsl:value-of select=\"./TITEL\" />  <xsl:for-each select=\"./LIED\">  <xsl:value-of select=\".\" />  </xsl:for-each>  </xsl:for-each> </body> </html> </xsl:template> </xsl:stylesheet>  Innerhalb des Templates wird nach dem Element ALBUM gesucht, das sich direkt unterhalb des Wurzel- elements befinden muss. Ist es vorhanden, wird Punkt  ausgeführt, ansonsten wird zu Punkt  ver- zweigt und die Transformation beendet.  Mithilfe des Oder-Operators werden die Inhalte der Elemente INTERPRET oder GRUPPE ausgegeben.  Ebenso wird der Inhalt des Elements TITEL an das Programm übergeben.  Eine weitere Schleife wird geöffnet, in der am aktuellen Knoten nach dem Element LIED gesucht wird.  Ist ein weiteres Element vorhanden, wird sein Inhalt an das Programm weitergegeben.  Die Schleife zum Selektieren der Elemente LIED wird beendet und es wird zum Punkt  zurückgekehrt.  Die in Punkt  geöffnete Schleife wird beendet und wieder zum Anfang verzweigt. Dies geschieht so lange, bis kein Element ALBUM mehr gefunden wird. Beispiel: kap12\\for-each1.xml Die festgelegte XSL-Datei wird in die XML-Datei der Musiksammlung eingebunden, um somit die Selektie- rung der einzelnen Daten zu ermöglichen.   <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <?xml-stylesheet type=\"text/xsl\" href=\"for-each1.xsl\"?> <MUSIKSAMMLUNG> <!-- ... --> </MUSIKSAMMLUNG>  Nach dem Prolog wird die XSL-Datei über die Processing Instruction <?xml-stylesheet…?> eingebun- den und auf die Daten der XML-Datei angewendet.  Hier beginnt die Auflistung der einzelnen Elemente. Öffnen Sie die Musiksammlung in Ihrem Browser. Der Interpret, der Name des Albums sowie die jeweiligen Titel werden im Browser wie in der folgenden Abbildung angezeigt. Diese Darstellung ist jedoch keine zufriedenstellende Lösung, weil die Übersicht der Daten verloren geht. | Hochschulversion 12 XML 1.1 - Grundlagen 128 © HERDT-Verlag Anzeige der selektierten Daten im Browser Beispiel: kap12\\for-each2.xsl Eine mögliche visuelle Gestaltung der Daten kann beispielsweise mithilfe einer Tabelle in HTML realisiert werden. In die entsprechenden Zellen werden dann die XSL-Befehle zum Selektieren der Daten eingefügt. <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"/\"> <html> <head> <title>Liedübersicht</title> <style type=\"text/css\"> table { border:3px solid #000; width:400px;} td { border:1px dotted #000; padding:3px; } .bg { background-color: #DDD;} .big { font-size:16pt; font-weight:bold; } </style> </head> <body> <table> <tr valign=\"top\" class=\"bg\"> <td><span class=\"big\">Musiksammlung - Auflistung der Lieder</span></td> </tr> <xsl:for-each select=\"//ALBUM\"> <tr><td style=\"color:red; font-weight:bold;\"> <xsl:value-of select=\"./INTERPRET|./GRUPPE\" /> - <xsl:value-of select=\"./TITEL\" /> <br /> </td></tr> <tr valign=\"top\"> <td> <xsl:for-each select=\"./LIED\"> <xsl:value-of select=\".\" /> <br /> </xsl:for-each> </td> </tr> </xsl:for-each> </table> </body> </html> </xsl:template> </xsl:stylesheet> Hochschulversion XSLT-Elemente 12 © HERDT-Verlag 129 Formatierte Anzeige der selektierten Daten im Browser 12.3 Elemente sortieren Standardmäßig werden die Elemente in der Reihenfolge ihres Auftretens ausgegeben. Mit dem XSLT-Element xsl:sort haben Sie die Möglichkeit, die Sortierung der XML-Elemente zu beeinflussen. Dieses XSLT-Element kann als Kind-Element von for-each und apply-templates verwendet werden. <xsl:sort select=\"Pattern\" [order=\"\" data-type=\"\" case-order=\"\"]> xsl:sort weist den Parser an, die mit select angegebenen Elemente zu sortieren. Die übrigen Attri- bute sind optional. Über das Attribut order geben Sie die Sortierreihenfolge an. Der Standardwert ascending erzwingt eine aufsteigende und der Wert descending eine absteigende Sortierung. Das Attribut data-type legt den Datentyp fest. Mit dem Wert text (Standardwert) und dem Wert number können Sie die Sortierreihenfolge bei Zahlenwerten ändern. Wenn Sie als Datentyp den Wert text festgelegt haben, können Sie mit case-order die Einordnung der Buchstaben beeinflussen. Der Wert upper-first gibt an, dass auftretende Großbuchstaben vor den entsprechenden Kleinbuchstaben einsortiert werden sollen. Mit dem Standardwert lower-first wäre es umgekehrt. Erweitern Sie die bisherige Datei for-each2.xsl und speichern Sie diese unter dem Namen sort.xsl. Beispiel: kap12\\sort.xsl Die Interpreten sollen alphabetisch absteigend sortiert werden. Die Lieder jedes Interpreten sollen hingegen alphabetisch aufsteigend sortiert werden. Die eingefügten Zeilen sind im Beispiel farblich hervorgehoben.   <!-- ... --> <xsl:for-each select=\"//ALBUM\"> <xsl:sort select=\"./INTERPRET|./GRUPPE\" order=\"descending\" /> <tr><td style=\"color:red; font-weight:bold;\"> <xsl:value-of select=\"./INTERPRET|./GRUPPE\" /> - <xsl:value-of select=\"./TITEL\" /> <br /> </td></tr> <tr valign=\"top\"> <td> <xsl:for-each select=\"./LIED\"> <xsl:sort select=\".\" data-type=\"text\" case-order=\"upper-first\" /> <xsl:value-of select=\".\" /> <br /> Hochschulversion 12 XML 1.1 - Grundlagen 130 © HERDT-Verlag </xsl:for-each> </td></tr> </xsl:for-each> <!-- ... -->  Innerhalb des Elements ALBUM werden die Elemente INTERPRET oder GRUPPE sortiert. Die alphabetische Sortierung wird über das Attribut order umgekehrt.  Nach dem Selektieren der Elemente LIED sollen diese über den Standardwert aufsteigend sortiert wer- den. Den Datentyp und die veränderte Einordnung von groß- und kleingeschriebenen Buchstaben pas- sen Sie über data-type und case-order an. Der Wert upper-first hat zur Folge, dass große Buchstaben vor den kleinen einsortiert werden, z. B. A, a, B, b, C, c usw. Binden Sie die Datei sort.xsl in die Datei for-each2.xml ein, damit die Sortierung der Daten durchgeführt werden kann. Speichern Sie die Datei unter dem Namen sort.xml und laden Sie sie in Ihren Browser. 12.4 Einfache Fallunterscheidung Mit einer einfachen Fallunterscheidung haben Sie die Möglichkeit, ein Element daraufhin zu testen, ob es selbst oder dessen Attribute bestimmte Bedingungen erfüllen. Sie können ein Element auf dessen Inhalt überprüfen, indem Sie den Inhalt hinter dem Elementnamen in ein- fachen Anführungszeichen angeben. <xsl:if test=\"Elementname='Inhalt'\"> </xsl:if> Soll ein Attribut auf einen bestimmten Wert überprüft werden, geben Sie hinter dem Namen des Elements das entsprechende Attribut und in einfachen Anführungszeichen dessen Wert an. Beachten Sie, dass ein Attribut mithilfe des Zeichens angesprochen wird. <xsl:if test=\"Elementname/@Attributname='Wert'\"> </xsl:if> Element finden Es soll kontrolliert werden, ob innerhalb des aktuellen Knotens das Element INTERPRET mit dem Inhalt Moby existiert.    <xsl:if test=\"INTERPRET='Moby'\"> <!-- Aktionsteil --> </xsl:if>  Mit dieser Abfrage wird im aktuellen Knoten nach dem Interpreten Moby gesucht.  Wurde ein Element mit dem gesuchten Interpreten gefunden, wird der Aktionsteil ausgeführt.  Die Fallunterscheidung wird beendet. Attributwert finden In diesem Beispiel wird getestet, ob im aktuellen Knoten ein Element TITEL existiert, das zusätzlich ein Attri- but stil mit dem Wert Pop bzw. p besitzt.    <xsl:if test=\"TITEL/@stil='Pop' or TITEL/@stil='p'\"> <!-- Aktionsteil --> </xsl:if> ' @ Hochschulversion XSLT-Elemente 12 © HERDT-Verlag 131  Mit dieser Abfrage wird im aktuellen Knoten nach einem Album gesucht, das in die Stilrichtung Pop eingeordnet wurde. Die Suche können Sie mit dem Schlüsselwort or verknüpfen. Es wird im aktuellen Knoten nach dem Element und dessen Attribut gesucht.  Wurde ein Attribut stil mit dem Wert Pop oder p gefunden, wird der Aktionsteil ausgeführt.  Die Fallunterscheidung wird beendet. Beispiel: kap12\\if.xsl In dem nächsten Beispiel sollen nur die Alben ausgegeben werden, die der Stilrichtung Pop zugeordnet werden können.         <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"/\"> <html> <head> <title>Pop-Alben</title> </head> <body> <h2>Musiksammlung - Auflisten der Pop-Alben</h2> <div> <xsl:for-each select=\"//ALBUM\"> <xsl:sort select=\"./INTERPRET|./GRUPPE\" /> <xsl:if test=\"TITEL/@stil='Pop' or TITEL/@stil='p'\"> <xsl:value-of select=\"./INTERPRET|./GRUPPE\" /> - <xsl:value-of select=\"./TITEL\" /> <br /> </xsl:if> </xsl:for-each> </div> </body> </html> </xsl:template> </xsl:stylesheet>  Die Vorlage wird eingeleitet und das Hauptelement selektiert.  Mit einer Schleife werden alle Alben durchsucht.  Die Ausgabe soll nach dem Namen des Interpreten bzw. der Gruppe sortiert werden.  Jedes Element TITEL innerhalb des Elements ALBUM wird geprüft, ob es das Attribut stil mit dem Wert Pop oder p enthält.  Der Wert des Elements INTERPRET wird an das Programm übergeben.  Ebenso wird der Inhalt des Elements TITEL zurückgegeben.  Die Fallunterscheidung wird beendet.  Die Schleife zum Durchsuchen der Elemente ALBUM wird geschlossen. Beispiel: kap12\\if.xml Nach der Einbindung der XSL-Datei in die bisherige Musiksammlung werden nur die Alben aufgelistet, die dem Musikstil Pop zugeordnet worden sind. Ausgabe von Daten nach einer einfachen Fallunterscheidung Hochschulversion 12 XML 1.1 - Grundlagen 132 © HERDT-Verlag In XSLT gibt es keine Fallunterscheidung in der Form if-else. Hierfür müssen Sie die nachfolgende, komple- xe Fallunterscheidung choose-when-otherwise einsetzen. 12.5 Komplexe Fallunterscheidung Die einfache Fallunterscheidung ermöglicht es Ihnen, eine Aktion nur dann auszuführen, wenn das Ergebnis des Tests wahr (true) ist. In komplexeren Fallunterscheidungen haben Sie zusätzlich die Möglichkeit, auch den Fall zu betrachten, dass das Ergebnis der Prüfung falsch (false) ist. Beispielsweise wäre es möglich, die Daten, die einem Mustervergleich entsprechen, in einer anderen Farbe darzustellen. <xsl:choose> <xsl:when test=\"Elementname='Inhalt'\"> <!-- Aktionsteil --> </xsl:when> <xsl:otherwise> <!-- alternativer Aktionsteil --> </xsl:otherwise> </xsl:choose> oder <xsl:choose> <xsl:when test=\"Elementname/@Attributname='Wert'\"> <!-- Aktionsteil --> </xsl:when> <xsl:otherwise> <!-- alternativer Aktionsteil --> </xsl:otherwise> </xsl:choose> Das XSLT-Element xsl:choose (deutsch: wählen) leitet eine komplexe Fallunterscheidung ein. Nachfolgend wird über xsl:when (deutsch: wenn) die erste Fallunterscheidung eingeleitet. Hierbei wird getestet, ob die angegebene Prüfung des Elements erfolgreich ist. Sollte dies der Fall sein, wird der Aktionsteil ausgeführt. Ansonsten springt der Prozessor zu der Stelle, an welcher der alternative Zweig xsl:otherwise (deutsch: ansonsten) beginnt. Es werden die Aktionen ausgeführt, die von xsl:otherwise umschlossen werden. Sie können beliebig viele Fallunterscheidungen definieren. Zu diesem Zweck geben Sie für jeden gewünsch- ten Mustervergleich das XSLT-Element xsl:when an. Der Wert, der geprüft werden soll, wird in einfache Anführungszeichen gesetzt. Sie können jedoch auch Werte als Zahlen behandeln. In diesem Fall geben Sie die Zahl ohne die einfachen Anführungszeichen an. Um Zahlen zu vergleichen, verwenden Sie die Zeichen , und . Da die beiden letzten Zeichen jedoch als Einleitung und Abschluss eines Elements betrachtet werden, müssen sie als Entities &gt; (greater than) und &lt; (lower than) angegeben werden. Es wird immer nur eine Möglichkeit bearbeitet. Wenn ein Mustervergleich zutrifft, wird die Aktion ausge- führt und die Anweisung xsl:choose verlassen. Die restlichen Unterscheidungen werden nicht beachtet. Es kann also immer nur ein möglicher Aktionsteil innerhalb einer Fallunterscheidung ausgeführt werden. Beispiel In diesem Beispiel wird die grundlegende Anwendung einer komplexen Fallunterscheidung beschrieben. Zum besseren Verständnis werden die Mustervergleiche mit einer möglichen Abfrage zum Namen einer Person und deren Alter durchgeführt.   <xsl:choose> <xsl:when test=\"//PERSON/NAME='Meier'\"> <!-- Aktionsteil --> Hochschulversion XSLT-Elemente 12 © HERDT-Verlag 133       </xsl:when> <xsl:when test=\"//PERSON/ALTER &gt; 65\"> <!-- Aktionsteil --> </xsl:when> <xsl:otherwise> <!-- alternativer Aktionsteil --> </xsl:otherwise> </xsl:choose>  Die komplexe Fallunterscheidung wird eingeleitet.  Im ersten Fall wird kontrolliert, ob es in der XML-Struktur eine Person mit dem Namen Meier gibt. Der folgende Aktionsteil wird bei Übereinstimmung ausgeführt.  Die Ausführung des ersten Aktionsteils wird beendet und die Anweisung xsl:choose wird verlassen. Der Prozessor verzweigt zur Stelle .  Trifft der erste Fall  nicht zu, wird kontrolliert, ob das Alter der Person größer als 65 ist. Liefert der Mustervergleich das Ergebnis true, wird dieser Aktionsteil ausgeführt.  Der zweite Aktionsteil wird beendet. Der Prozessor springt zur Stelle .  Trifft kein Mustervergleich zu, wird dieser alternative Aktionsteil ausgeführt.  Die Anweisung xsl:otherwise wird beendet.  Die Fallunterscheidung ist abgeschlossen. Beispiel: kap12\\choose.xsl In dem nachfolgenden Beispiel werden die einzelnen Alben der Musiksammlung je nach Bewertung unter- schiedlich farbig hinterlegt. Dabei erhalten Alben mit einer Bewertung von 4 und 5 einen hellgrünen und Alben mit einer geringeren Bewertung einen hellroten Hintergrund. Ist keine Bewertung hinterlegt, bleibt der Hintergrund weiß.      <?xml version=\"1.0\" encoding=\"iso-8859-1\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> <xsl:template match=\"/\"> <html><head> <title>Komplexe Fallunterscheidung</title> <style type=\"text/css\"> div { border:1px solid white; padding:3px; } </style> </head> <body> <h2>Musiksammlung - Bewertungen auswerten</h2> <xsl:for-each select=\"//ALBUM\"> <xsl:sort select=\"TITEL/@bewertung\" order=\"descending\"/> <xsl:choose> <xsl:when test=\"TITEL/@bewertung &gt; 3\"> <div style=\"background-color:#90EE90;\"> <b><xsl:value-of select=\"INTERPRET|GRUPPE\" /> - <xsl:value-of select=\"TITEL\" /> <br /></b> Bewertung: <xsl:value-of select=\"TITEL/@bewertung\" /> </div> </xsl:when> <xsl:when test=\"TITEL/@bewertung &gt;= 0\"> <div style=\"background-color:#FF6347;\"> <b><xsl:value-of select=\"INTERPRET|GRUPPE\" /> - <xsl:value-of select=\"TITEL\" /> <br /></b> Bewertung: <xsl:value-of select=\"TITEL/@bewertung\" /> </div> </xsl:when> Hochschulversion 12 XML 1.1 - Grundlagen 134 © HERDT-Verlag    <xsl:otherwise> <div> <b><xsl:value-of select=\"INTERPRET|GRUPPE\" /> - <xsl:value-of select=\"TITEL\" /> <br /></b> Bewertung: - </div> </xsl:otherwise> </xsl:choose> </xsl:for-each> </body></html> </xsl:template> </xsl:stylesheet>  Die Vorlage zum Ansprechen von Elementen einer XML-Struktur wird eingeleitet.  Die Fallunterscheidung wird mit <xsl:choose> gestartet und ist bis zum schließenden Element  gültig.  Mit xsl:when wird die erste Fallunterscheidung durchgeführt. Hier wird getestet, ob der Wert des Attri- buts bewertung innerhalb des Elements TITEL größer als 3 ist (&gt;). Trifft dies zu, werden die Aktio- nen zur Formatierung der Ausgabe durchgeführt. In diesem Fall werden die Elemente mit einer hell- grünen Farbe hinterlegt.  Die erste Fallunterscheidung wird beendet.  Der zweite Mustervergleich testet, ob eine Bewertung >= 0 vorliegt. Der Hintergrund wird rötlich eingefärbt.  Wenn keiner der vorherigen Mustervergleiche übereinstimmt, wird der alternative Fall xsl:otherwise eingeleitet.  Die komplexe Fallunterscheidung xsl:choose wird beendet.  Die Vorlage wird beendet. Nach Bewertung sortierte Anzeige der Alben Hochschulversion XSLT-Elemente 12 © HERDT-Verlag 135 12.6 Übungen Übung 1: Daten selektieren und ausgeben Übungsdateien: kap12\\ms.dtd, kap12\\uebung1.xml Ergebnisdatei: kap12\\uebung1.xsl Stellen Sie die Daten der Musiksammlung in einer Tabelle dar. Der Interpret und der Albumtitel sollen dabei aufsteigend sortiert angezeigt werden. Wählen Sie dazu den Inter- preten und den Titel des Albums und listen Sie alle enthaltenen Lieder auf. Nach Interpreten sortierte Ausgabe mit den Liedern des jeweiligen Albums Übung 2: Mit Fallunterscheidungen arbeiten Übungsdateien: kap12\\ms.dtd, kap12\\uebung2.xml Ergebnisdatei: kap12\\uebung2.xsl Geben Sie alle Alben mit den Informationen zu den Interpreten aus. Stellen Sie über die Fall- unterscheidung <xsl:choose> die Stilrichtung der jeweiligen Alben dar. Übung 3: Mit Schleifen arbeiten Übungsdateien: kap12\\kfz.dtd, kap12\\uebung3.xml Ergebnisdatei: kap12\\uebung3.xsl Erstellen Sie über XSL-Schleifen eine formatierte Ausgabe der Daten aus der Fahrzeugverwaltung. Achten Sie darauf, auch die Attributwerte der Elemente als Maßeinheiten auszuge- ben. Formatierte Ausgabe der technischen Daten Hochschulversion 13 XML 1.1 - Grundlagen 136 © HERDT-Verlag 13 Links in XML In diesem Kapitel erfahren Sie wie Sie einfache Links in XML verwenden wie erweiterte Links erstellt und genutzt werden Voraussetzungen Erstellen von Namensräumen 13.1 Einführung in XLink HTML bietet die Möglichkeit, zwischen verschiedenen Dokumenten oder innerhalb eines Dokuments zu verzweigen. Die vorhandene Lösung ist mit einigen Einschränkungen verbunden: HTML-Hyperlinks sind statisch, d. h., wenn sie einmal erstellt worden sind, können sie nicht ohne Änderung des Quelltextes geändert werden. Ein Link in HTML kann immer nur ein Ziel besitzen, die Angabe mehrerer Zieladressen ist nicht möglich. HTML-Hyperlinks führen immer vom Link im Quelldokument zum angegebenen Ziel, sie besitzen also nur diese eine Richtung. In HTML können nur die Elemente <a> und – mit Einschränkungen <img> als Ausgangspunkt eines Links genutzt werden. Das Ziel von XLink (eXtended Linking Language) ist, eine Sprache ohne die genannten Einschränkungen bereitzustellen. Seit Juni 2010 gibt es eine Empfehlung für XLink, welche im Jahr 2011 nochmals leicht überarbeitet wurde (vgl. http://www.w3.org/TR/xlink11). XLink gibt Ihnen die Möglichkeit, Verweise dynamisch so zu verändern, dass sie Verbindungen zwischen ver- schiedenen XML-Dokumenten oder Elementen herstellen. Die nachfolgend aufgeführten Beispiele können mit den zum Zeitpunkt der Bucherstellung (Oktober 2014) aktuellen Browsern nur sehr eingeschränkt angezeigt werden, da die XLink-Funktionen kaum in den Browsern implementiert sind. Lediglich der Firefox unterstützt XLink rudimentär. Die gezeigten Beispiele beziehen sich auf die vorgegebene Spezifikation des W3-Konsortiums und werden vermutlich mit den Browsern der nächsten Generation genutzt werden können. Mit XPointer gibt es eine XPath-Erweiterung, die anstelle auf ein ganzes Dokument genau wie bei Ankern in HTML auf einzelne Dokumentteile verweist. Unter dem Link http://www.w3.org/TR/#tr_XPointer finden Sie die Empfehlungen des W3C aus dem Jahr 2003 zu diesem Thema. Gegenwärtig wird XPointer (mit Ausnahme des Amaya-Browsers (vgl. http://www.w3.org/Amaya/, einer Referenzanwendung des W3C) von keinem Browser unterstützt, jedoch von anderen XML-Sprachen verwendet. 13.2 XLink Verweise innerhalb eines Dokuments werden interne Verknüpfungen genannt. Ein Beispiel in HTML ist die Sprungmarke, die innerhalb einer Webseite zu einer bestimmten Stelle führt. In XML werden die internen Verweise mit XPath realisiert. Hochschulversion Links in XML 13 © HERDT-Verlag 137 Eine weitere Art von Links sind externe Verknüpfungen, die Grafiken einbinden oder auf andere Webseiten verweisen. In XML werden die externen Verweise mittels XLink realisiert. XLink ist ein Teil der eXtended Linking Language und wird verwendet, um Verknüpfungen zwischen verschiedenen Ressourcen zu erstellen und zu beschreiben. Diese Verknüpfungen sind mit den Hyperlinks in HTML vergleichbar, besitzen jedoch erweiterte Funktionen. Namensraum festlegen Zum Anlegen eines XLinks werden Namensräume für die entsprechenden Elemente angelegt. Zur Namens- raum-Definition wird standardmäßig die URI http://www.w3.org/1999/xlink benutzt: Es gibt zwei Möglichkeiten, ein XLink-Element zu erstellen. Entweder Sie definieren den Namensraum direkt am Element <ELEMENT xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:type=\"simple\" xlink:href=\"datei.xml\"> Inhalt des Elements </ELEMENT> oder Sie legen einen Bereich fest, in dem der Namensraum verwendet werden soll. <xlink:simple xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"datei.xml\"> <ELEMENT>Inhalt des Elements</ELEMENT> </xlink:simple> Attribute Zur speziellen Definition eines XLinks stehen Ihnen verschiedene Attribute zur Verfügung. Attribut Bedeutung type Bezeichnet beliebige XML-Elemente, die wie XLink-Elemente behandelt werden. Dieses Attribut kann die Werte simple, extended, locator, arc, resource oder title annehmen. href Stellt eine Adresse oder eine externe Ressource dar. Die Werte müssen URI-Referen- zen (relative oder absolute URLs) sein. Besitzt das Attribut type den Wert locator, muss das Attribut href angegeben werden. role Das Attribut bezeichnet die Quelle, von der aus verlinkt wird. arcrole Hiermit legen Sie eine Bemerkung zu einem XLink-Element an. title Dieses Attribut beschreibt für den Nutzer die Funktion eines Elements. show Das Attribut legt die Art der Anzeige des Links fest. Der Attributwert embed stellt im Dokument die eingebundene Zielressource, z. B. ein Bild, sofort dar. Der Wert new zeigt das Ziel (z. B. ein Bild) in einem neuen Fenster an. Der Wert replace er- setzt die aktuell angezeigte Ressource mit der Zielressource des Links. actuate Legt die Art der Aktivierung des Links fest. Gültige Werte sind: onLoad, onRequest, other und none. label, from, to Hiermit legen Sie eine eindeutige Bezeichnung für ein XLink-Element fest, auf das Sie über die Angabe von from und to direkt verweisen können. Ein Element ist dann ein XLink-Element, wenn es … mindestens ein Attribut type mit einem gültigen Wert besitzt, die für den Attributtyp erforderlichen weiteren Attribute enthält. Hochschulversion 13 XML 1.1 - Grundlagen 138 © HERDT-Verlag Der Elementtyp und seine Attribute Die nachfolgende Tabelle stellt die optionalen Angaben (o) und Pflichtangaben (x) entsprechend dem gewählten Elementtyp in der Übersicht dar (Quelle: http://www.w3.org/TR/xlink). simple extended locator arc resource title type x x x x x x href o - x - - - role o o o - o - arcrole o - - o - - title o o o o o - show o - - o - - actuate o - - o - - label - - o - o - from - - - o - - to - - - o - - Die Angaben besagen: x Pflichtangabe: Sie müssen das Attribut angeben. o Optional: Ihnen ist es freigestellt, ob Sie dieses Attribut angeben. - Keine Angabe: Dieses Attribut kann in Verbindung mit dem Elementtyp nicht genutzt werden. 13.3 Einfache Links Ein einfacher Link (engl. simple link) besteht aus dem lokalen oder dem externen Verweisziel. XLink definiert kein neues Element innerhalb eines XML-Dokuments, sondern legt globale Attribute fest. Dies bedeutet, dass jedes XML-Element, das diese globalen Attribute verwendet, auch ein XLink-Element darstellen kann. einfach Sprungmarke zu externem Verweisziel lokaler Verweis Die Document Type Definition eines einfachen Links in XLink lautet (Quelle: http://www.w3.org/TR/xlink): <!ELEMENT ElementName ANY> <!ATTLIST ElementName xlink:type (simple) #FIXED \"simple\" xlink:href CDATA #IMPLIED xlink:role CDATA #IMPLIED xlink:arcrole CDATA #IMPLIED xlink:title CDATA #IMPLIED xlink:show (new|replace|embed|other|none) #IMPLIED xlink:actuate (onLoad|onRequest|other|none) #IMPLIED> Hochschulversion Links in XML 13 © HERDT-Verlag 139 Beispiel: kap13\\xlink_a.xml Im Folgenden wird das HTML-Element a durch einen XLink nachgebildet.       <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <?xml-stylesheet type=\"text/css\" href=\"link.css\"?> <xlink:simple xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <a xlink:type=\"simple\" xlink:actuate=\"onRequest\" xlink:show=\"replace\" xlink:href=\"xlink_arc.xml\"> Zur anderen Seite </a> </xlink:simple>  Zur Gestaltung der Seite wird eine einfache CSS-Datei eingebunden.  Für das Element a wird ein einfacher Link definiert.  Dieser soll erst auf Anfrage (onRequest) ausgelöst werden.  Nach dem Auslösen soll der derzeitige Inhalt durch den neuen Inhalt ersetzt werden.  Der Link verweist auf die Datei xlink_arc.xml.  Der Link wird mit dem angegebenen Text dargestellt.  Die Definition des Links wird beendet. Von den bekannten Browsern unter Windows (Firefox, Internet Explorer, Google, Opera) unterstützt aktuell nur der Firefox die Umsetzung von XLink-Befehlen. Dies gilt allerdings auch nur für einfache Links wie in dem Beispiel. Des Weiteren funktioniert der Link nur beim gleichzeitigen Betätigen der S- oder der H-Taste während des Ausführens des Mausklicks. Dabei bewirkt – unabhängig vom Wert des Attributs xlink:show – die Taste H das Öffnen der Zielseite in einem neuen Browserfenster und die Taste S das Öffnen der Zielseite in einem zusätzlichen (verdeckten) Register. Beispiel: kap13\\xlink_img.xml Ein Link, der bereits beim Laden der Seite in das Dokument eingebunden werden soll, lässt sich ebenfalls rea- lisieren. Daher ist es auch möglich, mit XLink das HTML-Element img zu realisieren, denn Bilder sind Objekte, die bereits beim Laden der Seite eingebunden werden.       <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <xlink:simple xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <img xlink:type=\"simple\" xlink:actuate=\"onLoad\" xlink:show=\"embed\" xlink:href=\"bild.gif\"> Ein eingebettetes Bild </img> </xlink:simple> Darstellung im Firefox nach gleichzeitigem Betätigen von S und Klick auf den Link Hochschulversion 13 XML 1.1 - Grundlagen 140 © HERDT-Verlag  Das Element img wird als einfacher Link definiert.  Dieser soll bereits beim Laden des Dokuments (onLoad) ausgelöst werden.  Das Bild soll in das Dokument eingebettet werden (embed).  Der Link verweist auf die angegebene Datei bild.gif.  Die Grafik erhält die angegebene Bildunterschrift.  Die Festlegung des eingebetteten Links wird beendet. 13.4 Erweiterte und multidirektionale Links Erweiterte Links können mehr als zwei Verweisziele haben und somit komplizierte Verbindungen zwischen beliebig vielen Ressourcen herstellen. Keiner der Endpunkte eines erweiterten Links muss dabei ein Teil des Dokuments sein, in dem der Link definiert wird. Die Linien in der Abbildung stellen die Verbindungen eines erweiterten Links zu verschiedenen externen Verweiszielen (externe Ressourcen) dar. Diese Beziehungen besitzen jedoch keine Richtung und werden durch sogenannte traversal rules (deutsch: Verbindungsregeln) bestimmt. Ohne diese Verbin- dungen hätten die Ressourcen keinerlei Beziehung untereinander, sie könnten beispielsweise fünf getrennte Dokumente sein. Auch ein Element vom Typ extended ist in der Lage, einen XLink zu definieren. Alle nachfolgenden XLink- Elemente (locator, arc usw.) geben lediglich weitere Informationen zum Link an und werden innerhalb eines extended-Elements notiert. Treten solche Elemente nicht innerhalb eines extended-Elements auf, werden sie ignoriert. (Quelle: http://www.w3.org/TR/xlink) <!ELEMENT ElementName ((title|resource|locator|arc)*)> <!ATTLIST ElementName xmlns:xlink CDATA #FIXED \"http://www.w3.org/1999/xlink\" xlink:type (extended) #FIXED \"extended\" xlink:role CDATA #IMPLIED xlink:title CDATA #IMPLIED> Die Definition des Namensraumes, in dem die weiteren XLink-Elemente eingefügt werden, lautet wie folgt: <xlink:extended xmlns:link=\"http://www.w3.org/1999/xlink\"> <!-- weitere Kindknoten --> </xlink:extended> Der erweiterte Link kann, wie bereits erwähnt, weitere Elemente enthalten. Elementtyp Erläuterung locator Der Elementtyp adressiert das externe Verweisziel, das innerhalb des erweiterten Links ver- wendet wird. arc arc bestimmt die Art und Weise, wie ein XLink benutzt wird. Die Angabe besteht aus einer Quelle und dem Ziel. title Dieser Typ ermöglicht es, für den Menschen lesbare Informationen zu einem Link zur Ver- fügung zu stellen. resource Dieses Element liefert die lokale Ressource, die am Link beteiligt ist. Sprungmarke zum externen Verweisziel erweitert Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Hochschulversion Links in XML 13 © HERDT-Verlag 141 Elementtyp locator Innerhalb des extended-Links wird das locator-Element festgelegt. Es beinhaltet über das href-Attribut die notwendige Information für die einzubindende Ressource. Über das Attribut label wird diesem Element ein Bezeichner zugewiesen. Durch die Mehrfachangabe dieses Elements innerhalb eines extended-Elements werden Mehrfachverweise erstellt (Quelle: http://www.w3.org/TR/xlink). <!ELEMENT ElementName (title*)> <!ATTLIST ElementName xlink:type (locator) #FIXED \"locator\" xlink:href CDATA #REQUIRED xlink:role CDATA #IMPLIED xlink:title CDATA #IMPLIED xlink:label NMTOKEN #IMPLIED> Beispiel: kap13\\xlink_locator.xml Innerhalb des erweiterten XLinks wird einer Sprungmarke href eine Bezeichnung label zugewiesen. In dem nachfolgenden Beispiel sind den Links keine Werte zugewiesen worden. Die drei Leerzeichen stehen für eine beliebige URI. Sprungmarke zum externen Verweisziel erweitert Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel label=Z3 label=Z4 label=Z5label=Z2 label=Z1 <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <xlink:extended xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z1\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z2\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z3\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z4\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z5\" /> </xlink:extended> Elementtyp resource Dieses Element legt die lokale Ressource fest, die auf ein spezielles XML-Element verweist und die innerhalb des erweiterten Links als Unterelement erscheinen soll. Ein vollständiges Unterelement mit seinem gesamten Inhalt wird als lokale Ressource bezeichnet. Im Grunde kann dies jede adressierbare Informationseinheit sein, z. B. eine XML-Datei, eine Grafik, ein Wert oder Ähnliches. Die W3-Spezifikation des resource-Elements lautet (Quelle: http://www.w3.org/TR/xlink): <!ELEMENT ElementName ANY> <!ATTLIST ElementName xlink:type (resource) #FIXED \"resource\" xlink:role CDATA #IMPLIED xlink:title CDATA #IMPLIED xlink:label NMTOKEN #IMPLIED> Hochschulversion 13 XML 1.1 - Grundlagen 142 © HERDT-Verlag Beispiel: kap13\\xlink_resource.xml Sprungmarke zum externen Verweisziel erweitert Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel label=Z3 label=Z4 label=Z5 label=Z2 label=Z1 lokaler Verweis Die Abbildung stellt einen erweiterten Link mit fünf externen und einem lokalen Verweisziel dar. Der lokale Verweis kann beispielsweise einen lokal gespeicherten Wert enthalten.    <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <xlink:extended xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z1\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z2\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z3\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z4\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z5\" /> <was xlink:type=\"resource\" xlink:label=\"wert\">lokale Ressource</was> <was xlink:type=\"resource\" xlink:label=\"pic\">/images/bild.jpg</was> </xlink:extended>  Innerhalb des erweiterten XLinks werden den Sprungmarken href die Bezeichnungen label zugewiesen.  Als lokale Ressource wird der Verweis hinzugefügt, der den Bezeichner wert mit dem Text lokale Ressource enthält.  Der zweite Verweis pic besitzt den Inhalt /images/bild.jpg, der beispielsweise zum Anzeigen eines Bildes genutzt werden kann. Elementtyp arc Das Element arc (deutsch: Bogen) definiert die Richtung und das Verhalten eines Links innerhalb einer Res- source. Dabei werden die Richtungen durch die Angaben der mit locator definierten Bezeichner festgelegt (Quelle: http://www.w3.org/TR/xlink). <!ELEMENT ElementName (title*)> <!ATTLIST ElementName xlink:type (arc) #FIXED \"arc\" xlink:arcrole CDATA #IMPLIED xlink:title CDATA #IMPLIED xlink:show (new|replace|embed|other|none) #IMPLIED xlink:actuate (onLoad|onRequest|other|none) #IMPLIED xlink:from NMTOKEN #IMPLIED xlink:to NMTOKEN #IMPLIED> Hochschulversion Links in XML 13 © HERDT-Verlag 143 Beispiel: kap13\\xlink_arc.xml Mit dem XLink-Element arc, welches ebenfalls innerhalb des extended-Elements angegeben werden muss, definieren Sie die Verbindungsregel, mit der von einer zur anderen Ressource verwiesen wird. Werden mehrere Verbindungsregeln angegeben, welche die gleichen Ressourcen beschreiben, bei denen jedoch der Quell- und der Ziellink vertauscht sind, wird dieser Link als multidirektional bezeichnet.   <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <xlink:extended xmlns:xlink=\"http://www.w3.org/1999/xlink\"> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z1\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z2\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z3\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z4\" /> <wo xlink:type=\"locator\" xlink:href=\"...\" xlink:label=\"Z5\" /> <was xlink:type=\"resource\" xlink:label=\"wert\">lokale Ressource</was> <was xlink:type=\"resource\" xlink:label=\"pic\">/images/bild.jpg</was> <wie xlink:type=\"arc\" xlink:from=\"Z2\" xlink:to=\"Z3\" /> <wie xlink:type=\"arc\" xlink:from=\"Z2\" xlink:to=\"Z1\" /> <wie xlink:type=\"arc\" xlink:from=\"Z5\" xlink:to=\"Z3\" /> <wie xlink:type=\"arc\" xlink:from=\"Z5\" xlink:to=\"Z1\" /> <wie xlink:type=\"arc\" xlink:from=\"Z5\" xlink:to=\"Z4\" /> <wie xlink:type=\"arc\" xlink:from=\"Z4\" xlink:to=\"Z3\" /> </xlink:extended>  Mit dem arc-Element wird festgelegt, dass die bereits mit locator angelegten Sprungmarken mit der Bezeichnung Z2 und Z3 verbunden werden.  Hier wird der Link von Z5 nach Z3 festgelegt. Elementtyp title Die XLink-Elemente extended, locator und arc können ein Attribut title besitzen. Zusätzlich können die- se Elemente auch mehrere Elemente des Elementtyps title enthalten. Dies ist beispielsweise nützlich, wenn für den Menschen lesbare Hinweise zu einem Link notwendig sind. Ein wichtiger Aspekt ist hierbei die Ver- wendung von mehrsprachigen Hinweisen, da verschiedensprachige Texte eingefügt werden können. Dieses Element besitzt in XLink keine weiteren Attribute. <!ELEMENT ElementName ANY> <!ATTLIST ElementName xlink:type (title) #FIXED \"title\" xlink:lang CDATA #IMPLIED> label=Z5 Sprungmarke zum externen Verweisziel erweitert Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel Sprungmarke zum externen Verweisziel label=Z3 label=Z4 label=Z2 label=Z1 Hochschulversion 13 XML 1.1 - Grundlagen 144 © HERDT-Verlag 13.5 XBase Eine Zielsetzung bei der Definition von XLink war, die in HTML enthaltenen Verknüpfungsmöglichkeiten vollständig abzubilden. Mit der Einführung von HTML 4.01 ergab sich daraus die Anforderung, das in dieser Version neue Element <base> zur Spezifizierung einer Basisadresse von URIs entsprechend in XLink nachzubilden. Im Ergebnis wurde mit XBase eine Spezifikation geschaffen, die diese Anforderung umsetzt. Sie stellt das Attribut xml:base zur Verfügung. Der dem Attribut zugewiesene Wert wird bei der Dokumentverarbeitung als Basisadresse interpretiert. Die gesamte als Linkziel verwendete URI ergibt sich damit aus dieser Basis- adresse in Verbindung mit dem im Attribut xlink:href angegebenen Wert. In Anlehnung an das Beispiel kap13\\xlink_a.xml würde aus <a xml:base=\"http://www.herdt.com/files\" xlink:type=\"simple\" xlink:href=\"xlink_arc.xml\"> Zur anderen Seite </a> die folgende URI entstehen: http://www.herdt.com/files/ xlink_arc.xml Hochschulversion Links in XML 13 © HERDT-Verlag 145 Hochschulversion 14 XML 1.1 - Grundlagen 146 © HERDT-Verlag 14 XQuery In diesem Kapitel erfahren Sie wie Sie Daten mit XQuery selektieren wie Sie mit XPath Ausdrücke in XQuery nutzen was FLWOR Ausdrücke sind und wie sie diese anwenden welche erweiterten Möglichkeiten XQuery bietet Voraussetzungen Kenntnisse im Aufbau eines XML-Dokuments XPath Kenntnisse 14.1 XQuery-Grundlagen Entwicklung Die Mengen an in XML gespeicherten Daten werden immer größer. Wesentliche Ursachen dafür sind z.B.: die sich aus dem XML-Format ergebenden Möglichkeiten zum Datenaustausch zwischen Unternehmen, die effektive Bereitstellung von Daten zur Darstellung auf Webseiten und deren Verarbeitung in Webshops, die Erweiterung von relationalen Datenbanksystemen um Möglichkeiten zur Speicherung von Daten im XML-Format, die Umstellung von vielen Anwenderprogrammen, zum Beispiel der Office Programme von Microsoft, auf XML als Datenformat für erstellte Dokumente. Mit der zunehmenden Datenmenge entstand der Bedarf nach einer effektiven und allgemeinverwendbaren Abfragesprache analog zu SQL (Structured Query Language) für die Auswertung von relationalen Datenbanken. Im Jahr 2007 veröffentlichte das W3C die Empfehlung XQuery 1.0, um dieser Anforderung nachzukommen. Während die Version 2.0 aus dem Jahr 2010 sich im Wesentlichen auf Fehlerkorrekturen beschränkte, liegt mit der aktuellen Version 3.0 vom April 2014 (http://www.w3.org/TR/xquery-30/) eine Version vor, die einige Spracherweiterungen enthält. Dabei handelt es sich unter anderem um Erweiterungen bei den sogenannten FLWOR-Ausdrücken (vgl. Abschnitt 14.3) sowie um programmtechnische Erweiterungen wie beispielsweise die Unterstützung dynamischer Funktionsaufrufe, die Verwendung privater Funktionen und die Einführung von in vielen Programmiersprachen typischen try/catch Ausdrücken. Datenmodell und Syntax Bei XQuery handelt es sich um eine Erweiterung von XPath 2.0. Genau wie XPath ist auch XQuery keine XML- Anwendung, sondern besitzt eine eigene Syntax. Mit der Empfehlung XQueryX des W3C (http://www.w3.org/TR/xqueryx/) existiert eine Variante zur Formu- lierung von XQuery-Abfragen in Form eines XML-Dokuments. Beide Abfragetechniken basieren auf demselben Datenmodell (vgl. Abschnitt 10.3). XPath 2.0 ist eine Teil- menge von XQuery 1.0. Jeder gültige XPath 2.0 Ausdruck ist zugleich ein gültiger XQuery 1.0 Ausdruck. Alle Möglichkeiten von XPath 2.0 zur Datenselektion können in XQuery genutzt werden. Hochschulversion XQuery 14 © HERDT-Verlag 147 Syntaktisch handelt es sich bei XQuery um eine funktionale Sprache, deren einzelne Ausdrücke ausgewertet werden. Die Ausdrücke können geschachtelt sein, sodass ein Ausdruck weitere Ausdrücke beinhalten kann. Für Schlüsselwörter wird die Kleinschreibung genutzt, es existieren jedoch (mit Ausnahme einiger Funktions- namen) keine reservierten Schlüsselwörter. XQuery-Abfragen bestehen aus Modulen. Es wird zwischen zwei Modultypen unterschieden: dem Hauptmodul sowie den Bibliotheksmodulen. Das Hauptmodul ist in zwei Bereiche eingeteilt, den Prolog für Einstellungen und Deklarationen und den Query-Body, welcher die eigentliche Abfrage als Ausdruck enthält. Hauptmodul Prolog (Deklarationen und Importklauseln werden jeweils mit einem Semikolon abgeschlossen) Teil 1: Einstellungen für Setter für den XQuery-Prozessor (Steuerung der Abfrage) Namensraumdeklarationen Importklauseln (für Deklarationen und Schemas) Teil 2: Deklaration von Variablen, Funktionen und Optionen Query-Body Abfrageausdruck Bibliotheksmodule bestehen aus einer Moduldeklaration und dem Prolog. Alle Module können eine einleitende Versionsdeklaration enthalten. In dieser können Sie eine Deklaration der Codierung vornehmen: xquery version \"1.0\" encoding \"utf-8\"; Ob und wie diese berücksichtigt wird, ist jedoch von der Implementierung des jeweiligen XQuery-Prozessors abhängig. XQuery-Ausdrücke können Variablen enthalten. Diesen kann – entgegen dem eigentlichen Wortsinn und im Unterschied zu anderen Programmiersprachen – in einem XQuery-Ausdruck nur einmal ein Wert zugewiesen werden. Eine nachträgliche Änderung ist nicht möglich. Anwendung finden Variablen deshalb in erster Linie als Referenz auf einen ihnen zugewiesenen Code. Sie dienen somit der besseren Lesbarkeit und Übersichtlich- keit der Ausdrücke. Abfrageausdrücke Abfrageausdrücke beziehen sich auf ein Datenmodell, welches zum Zeitpunkt der Abfrage bekannt sein muss. Mögliche Abfrageziele sind zum einen lokale oder über eine URL zugängliche XML-Dokumente. Die Zuordnung der Abfrageziele erfolgt dabei über die Funktionen doc() bzw. collection(). Zum anderen ist XQuery vom Ansatz her so konzipiert, dass Abfrageausdrücke auch zur Abfrage anderer Datenquellen, wie einer die Speicherung von XML-Daten unterstützenden Datenbank oder den Inhalt einer Webseite, genutzt werden können. Der Abfrageausdruck besteht aus einer beliebigen Anzahl von Einzelausdrücken. Jeder Einzelausdruck wird mit einem Komma abgeschlossen. Die Abfolge der Einzelausdrücke wird auch als Sequenz bezeichnet. Sequenzen werden in Klammern eingeschlossen. Einzelausdrücke besitzen verschiedene Formen. Dabei können im Unterschied zu den reinen Abfragemöglichkeiten in XPath 2.0 mit einem XQuery-Ausdruck auch neue Elemente einer Datenstruktur erzeugt werden: ; Hochschulversion 14 XML 1.1 - Grundlagen 148 © HERDT-Verlag Ausdruck Beispiele Hinweis Literale \"Produkt von 2 * 2\", \"aktuelle Zeit\" Arithmetische Ausdrücke 2*2 Funktionen true(), count (...), current-time() Konstruktoren <a x=\"1\"/>, element a { attribute x { 1 } } XPath 2.0-Ausdruck doc(\"musiksammlung.xml\")//GRUPPE vgl. Abschnitt 14.2 FLWOR-Ausdruck let $doc := doc(\"musiksammlung.xml\") for $x in $doc//ALBUM where $x/JAHR < 1989 order by $x/INTERPRET return <ALBUM> { $x/INTERPRET } </ALBUM> vgl. Abschnitt 14.3 Implementierungen Die Auswertung der Ausdrücke erfolgt durch den XQuery-Prozessor. Mit der zunehmenden Verbreitung von XQuery wächst auch die Anzahl von verfügbaren Implementierungen: Viele professionelle XML-Werkzeuge, wie beispielsweise von Altavo (http://www.altavo.com) und DataDirect (http://www.xquery.com) besitzen mittlerweile eine XQuery-Komponente. Für die Integration in Java-Anwendungen existiert die XQuery API for Java (XQJ, siehe https://jcp.org/en/jsr/detail?id=225), welche analog zur JDBC API für die Auswertung relationaler Datenbanken für XML-Dokumentbestände genutzt werden kann. Das .Net Framework von Microsoft enthält Klassen in dem speziellen Namensraum System.Xml.XPath zur Arbeit mit XPath und XQuery-Ausdrücken. Der Datenbankstandard SQL enthält eine Erweiterung mit dem Datentyp XML. Dieser wird in zunehmenden Maße von den einzelnen Datenbanksystemen unterstützt, beispielsweise von IBM DB2 9.5 und von PostgreSQL (vgl. HERDT-Buch SQL - Grundlagen und Datenbankdesign, Anhang A „SQL/XML“). Auf Grund der Leistungsfähigkeit von XQuery, beispielsweise der Datenauswertung unterschiedlicher Quellen (vgl. Abschnitt 17.4) und der Zusammenführung der ermittelten Daten, ist zukünftig eine weiter zunehmende Unterstützung und Bedeutung von XQuery zu erwarten. Dies ergibt sich auch aus den zunehmenden Anforderungen der Verwaltung großer Datenmengen (Stichwort: Big Data). Die Datenmengen liegen oft im XML-Format vor. Auf der Webseite des W3C zum Thema (http://www.w3.org/XML/Query/) finden Sie Hinweise auf verfügbare Implementierungen und Testumgebungen. 14.2 XPath basierte XQuery-Abfragen Zur Datenselektion können Sie in XQuery XPath 2.0 Ausdrücke verwenden. In Verbindung mit den in XQuery vorhandenen vordefinierten Funktionen ermöglicht dies kurze Abfragen. Hochschulversion XQuery 14 © HERDT-Verlag 149 Beispiel kap14/xquery1_xsl.xql Im Beispiel werden mit einem XPath-Ausdruck alle Gruppen in der Musiksammlung ermittelt und als Unter- elemente in den neuen Wurzelknoten GRUPPEN eingefügt. Das Ergebnis enthält eine Sequenz ausgewählter Elemente des Ausgangsdokuments.     xquery version \"1.0\"; <GRUPPEN> { doc(\"musiksammlung.xml\")//GRUPPE } </GRUPPEN>  Die optionale Versionsdeklaration des Dokuments.  Die selektierten Elemente sollen in ein XML-Fragment mit dem Wurzelknoten Gruppen eingefügt werden. Dieses wird hier definiert. Die Definition stellt einen gültigen XQuery-Ausdruck dar und wird in die Ausgabe so wie definiert übernommen.  Die geschweiften Klammern schließen den Ausdruck zur Selektion der Daten ein.  Das auszuwertende XML-Dokument wird über die XQuery- Funktion doc() geöffnet. Im direkten Anschluss auf den Funktionsaufruf folgt ein XPath-Ausdruck, der die zu selektierenden Elemente – im Beispiel den Inhalt des Elements GRUPPE aller Alben, die das Element besitzen – bestimmt. Die beiden // vor dem zu selektierenden Element geben an, dass sich dieses auf einer, vom Wurzelknoten aus gesehen, beliebigen Hierarchieebene befinden kann. Einige XML-Umgebungen unterstützen die direkte Auswertung von XPath- und XQuery-Ausdrücken. Die Abbildung zeigt die direkte Auswertung des im Beispiel verwendeten XQuery-Ausdrucks in Altova XMLSpy. Auswertung eines XML-Ausdrucks auf die aktuelle Datei in Altova XMLSpy Ergebnis in der Browserdarstellung Hochschulversion 14 XML 1.1 - Grundlagen 150 © HERDT-Verlag 14.3 Abfragen mit FLWOR-Ausdrücken Bestandteile von FLWOR Ausdrücken Ohne gute Kenntnisse in XPath 2.0 sind die darauf basierenden Abfragen bei zunehmender Komplexität der Selektion nicht immer leicht lesbar und sofort verständlich. Alternativ bietet XQuery mit den sogenannten FLWOR-Ausdrücken eine zweite Möglichkeit zur Datenselektion. Die Aussprache von FLWOR entspricht dem englischen Flower (Blume). Der Name der Ausdrücke FLWOR resultiert aus den Anfangsbuchstaben der Klauseln, aus denen sich ein typischer nach dieser Syntax gebildeter Ausdruck zusammensetzt. F for dient der Ausführung einer Iteration auf eine Sequenz L let definiert eine in dem Ausdruck gültige Variable W where formuliert die Bedingung der Knotenauswahl O order by legt die Sortierung der Ergebnisse fest R return bestimmt das vom Ausdruck gelieferte Ergebnis Die FLWOR-Syntax hat starke Ähnlichkeit mit der SQL-Syntax (Structured Query Language) zur Abfrage von relationalen Datenbanken. Für die einzelnen Klauseln gelten folgende Regeln: Klausel Regeln Häufigkeit im Ausdruck for Operation wird auf alle Elemente der Sequenz ausgeführt mindestens eine for oder eine let Klausel pro Ausdruck let Variablennamen müssen immer mit dem Zeichen $ beginnen Wertzuweisung erfolgt über den Operator := where steht nach allen for oder let Klauseln die Verknüpfung mehrerer Bedingungen über die logischen Operatoren and bzw. or zur Strukturierung der Bedingungen können Klammern verwendet werden optional maximal eine Klausel pro Ausdruck order by die Sortierreihenfolge kann über die Schlüsselwörter ascending (aufsteigend, Standardwert) und descending (absteigend) gesteuert werden fehlt die order by Klausel, wird das Ergebnis entsprechend der Reihenfolge der Sequenz in der for Klausel geliefert optional return steht immer am Ende des FLWOR-Ausdrucks liefert eine Einheit oder eine Sequenz mindestens einmal im Ausdruck Ausdrücke in einer Anweisung können verschachtelt werden. So kann eine for Klausel eine innere for Klausel enthalten: for $i in ('a', 'b' ) for $j in (1, 2 ) return element { $i } { $j } Als Ergebnis liefert der Ausdruck <a>1</a> <a>2</a> <b>1</b> <b>2</>. Hochschulversion XQuery 14 © HERDT-Verlag 151 Das Ergebnis eines Ausdrucks kann wiederum Bestandteil eines anderen Ausdrucks sein. Zum Beispiel berechnet der Ausdruck avg( for $i in (1 to 4) return $i * $i ) den Durchschnitt (7,5) auf Basis der Sequenz, die von dem in den Funktionsklammern stehenden FLWOR- Ausdruck geliefert wird. Beispiel kap14/xquery2_xsl.xql Im Beispiel werden mit einem FLWOR-Ausdruck alle Einzelinterpreten ermittelt, deren Album vor dem Jahr 1989 erschienen und damit mindestens 25 Jahre alt ist. Als Ergebnis wird eine XML-Struktur erstellt, welche unter dem neuen Wurzelelement EINZELINTERPRETEN_OLDIES alle Alben mit den Elementen INTERPRET, TITEL und JAHR enthält.          xquery version \"1.0\"; <EINZELINTERPRETEN_OLDIES> { let $doc := doc(\"musiksammlung.xml\") for $x in $doc//ALBUM where $x/JAHR < 1989 order by $x/INTERPRET return <ALBUM> { $x/INTERPRET } { $x/TITEL } { $x/JAHR } </ALBUM> } </EINZELINTERPRETEN_OLDIES>  Die Definition des Wurzelknotens EINZELINTERPRETEN_OLDIES für das zu erstellenden XML- Fragment.  Der Variablen $doc wird über die Funktion doc das XML-Dokument musiksammlung.xml als Datenmodell zugewiesen.  Die Iteration wird über alle Knoten ALBUM des festgelegten Datenmodells ausgeführt. Über die Variable $x kann auf den im Durchlauf aktuellen Knoten zugegriffen werden.  Als Bedingung für zu selektierende Knoten wird bestimmt, dass der Inhalt des Elements JAHR kleiner als 1989 sein muss.  Die Ausgabe der Ergebnisknoten soll sortiert nach dem Inhalt des Elements INTERPRET erfolgen.  -  Das Ergebnis des Ausdrucks wird in der return Klausel bestimmt. Für jeden gefundenen Wert soll ein Element ALBUM mit den Unterelementen INTERPRET, TITEL und JAHR geliefert werden. Der Zugriff auf den Inhalt der Unterknoten erfolgt unter Verwendung des in der Variablen $x gespeicherten aktuellen Knotens. Ergebnis in der Browserdarstellung Hochschulversion 14 XML 1.1 - Grundlagen 152 © HERDT-Verlag 14.4 Gestaltung der Ausgabe der Auswertungsergebnisse Eine XQuery-Abfrage muss im Ergebnis nicht zwangsläufig ein XML-Fragment liefern. Je nach verwendetem XQuery-Prozessor kann dieser auf Anweisung hin auch reines Textdokument oder ein HTML- bzw. XHTML- Dokument erzeugen. Festgelegt wird dies über die Serialisierungsmethode des Prozessors. Um im Programm XMLSpy diese Einstellung vorzunehmen, gehen Sie wie folgt vor: Öffnen Sie über Extras - Optionen das Dialogfenster Optionen. Wechseln Sie auf das Register XQuery . Wählen Sie unter Serialisierungs- methode die gewünschte Einstellung html, text, xhtml oder xml . Bestätigen Sie die Einstellung mit Übernehmen  und schließen das Dialogfenster über OK . Beispiel kap14/xquery3_xsl.xql Das Beispiel aus dem letzten Abschnitt wird um eine HTML-Grundstruktur und um Tags zur Erzeugung einer Liste ergänzt. Die Ausführung der Abfrage erzeugt ein gültiges HTML-Dokument.   xquery version \"1.0\"; <html encoding=\"utf-8\"> <head> <title>EINZELINTERPRETEN OLDIES</title> </head> <body> <ul> { let $doc := doc(\"musiksammlung.xml\") for $x in $doc//ALBUM where $x/JAHR < 1989 order by $x/INTERPRET return <li> Interpret: {data( $x/INTERPRET )}, Titel: {data( $x/TITEL )}, Jahr: {data( $x/JAHR )},</li> } </ul> </body> </html>  Die benötigten HTML-Tags werden an den notwendigen Stellen in die XQuery-Abfrage eingefügt. Die verwendete HTML-Grundstruktur ist nicht zwingend notwendig. Die Ausgabe könnte sich auch lediglich auf den Bereich der Listentags <ul> und <li> beschränken.  Die Funktion data() bewirkt, dass lediglich der Inhalt der Knoten und nicht die Knoten selbst im Ergebnis geliefert werden. Darstellung des Ergebnisses im Browser    Hochschulversion XQuery 14 © HERDT-Verlag 153 14.5 Auswertung verbundener Dokumente Eine besondere Stärke von XQuery besteht darin, mehrere Datenquellen bei einer Auswertung heranzu- ziehen. Dabei können über Vergleichsoperationen miteinander verbundene Inhalte kombiniert und so im Rückgabeergebnis Teile der unterschiedlichen Datenquellen gemeinsam geliefert werden. Eine weitere Möglichkeit zur Auswertung mehrerer Datenquellen stellt die Funktion collection() dar, der eine Liste von mehreren Datenquellen übergeben werden kann. Beispiel kap14/labels.xml und kap14/labels.dtd Zur Demonstration wird zusätzlich zur Musiksammlung ein XML-Dokument labels.xml, welches auf der DTD labels.dtd basiert, verwendet. <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"no\"?> <!DOCTYPE LABELS SYSTEM \"labels.dtd\" > <LABELS> <LABEL> <NAME>Mute Records Limited</NAME> <MAINOFFICE>Detroit</MAINOFFICE> <WEB>www.muterec.com</WEB> </LABEL> <LABEL> … </LABEL> … </LABELS> <!ELEMENT LABELS (LABEL+)> <!ELEMENT LABEL (NAME, MAINOFFICE, WEB)> <!ELEMENT NAME (#PCDATA)> <!ELEMENT MAINOFFICE (#PCDATA)> <!ELEMENT WEB (#PCDATA)> Beispiel kap14/xquery4_xsl.xql In der XQuery-Abfrage werden zum Inhalt des Knotens LABEL von jedem Album die zugehörigen Zusatz- informationen aus der Datei labels.xml ermittelt.       xquery version \"1.0\"; <LABELLISTE> { for $a in doc(\"musiksammlung.xml\")//ALBUM order by $a//LABEL return <COMPANY> { $a/LABEL, for $b in doc(\"labels.xml\")//LABEL[NAME=$a/LABEL] return <DETAILS> {$b/MAINOFFICE} {$b/WEB} </DETAILS> } </COMPANY> } </LABELLISTE> Hochschulversion 14 XML 1.1 - Grundlagen 154 © HERDT-Verlag  In der äußeren for Schleife wird die Musiksammlung musiksammlung.xml geöffnet. Für alle Knoten des Elements ALBUM wird der mit return definierte Ausdruck ermittelt. Der Zugriff auf den aktuellen Knoten kann über die Variablen $a erfolgen.  Die Ausgabe erfolgt aufsteigend sortiert nach dem Inhalt des Elements LABEL.  Unterhalb des Wurzelknotens LABELLISTE des Ergebnisses wird im Rückgabewert das Unterelement COMPANY definiert.  Für den aktuellen Knoten in der Iteration werden der Tag LABEL und sein Inhalt ausgegeben.  In der inneren for Schleife wird die Datei labels.xml geöffnet. Der Inhalt des Knotens Name wird jeweils mit dem aktuellen Knoten LABEL der Musiksammlung verglichen. Der Vergleich erfolgt dabei über den kompletten Namen, da die Entity in musiksammlung.xml zum Zeitpunkt der Durchführung der XQuery- Abfrage bereits aufgelöst ist. Für den aktuellen Knoten der Iteration der inneren for Schleife wird die Variablen $b definiert.  Der Rückgabewert der inneren for Schleife setzt sich aus dem Unterelement DETAILS sowie den Tags MAINOFFICE und WEB sowie deren aktuellen Inhalten zusammen. Darstellung des Ergebnisses mit den verknüpften Informationen im Browser Hochschulversion XQuery 14 © HERDT-Verlag 155 14.6 Übungen Übung 1: Mit FLWOR-Ausdrücken arbeiten Übungsdatei: kap14/kfz.dtd, kap14/uebung1.xml Ergebnisdatei: kap14/uebung1.xql  Ermitteln Sie mit einem FLWOR-Ausdruck in einer XQuery-Abfrage alle Fahrzeuge, deren Höchstgeschwindigkeit mindestens 250 km/h beträgt.  Geben Sie für alle ermittelten Fahrzeuge den Hersteller und die Modellbezeichnung aus. Die Ausgabe soll nach dem Hersteller in absteigender Sortierung erfolgen. Ergebnisdarstellung im Browser Hochschulversion 15 XML 1.1 - Grundlagen 156 © HERDT-Verlag 15 DOM und SAX In diesem Kapitel erfahren Sie wie Sie ein DOM-Objekt anlegen und damit auf die XML-Struktur zugreifen welcher Unterschied zwischen DOM und SAX besteht wie Sie über JavaScript Daten eines XML-Dokuments auslesen wozu Dateninseln genutzt werden Voraussetzungen Kenntnisse in JavaScript 15.1 DOM Mit der Entwicklung von XML hat das W3-Konsortium das Document Object Model, kurz DOM, verabschie- det. Dieses Objektmodell bildet die Struktur eines XML-Dokuments im Arbeitsspeicher ab und erlaubt den Zugriff auf die Elementstruktur eines XML-Dokuments über eine API-Schnittstelle (API = Application Program- ming Interface). Über bestimmte Methoden und Eigenschaften können somit die einzelnen Elemente, Attri- bute und Inhalte angesprochen werden. Dazu muss die Anwendung in einer objektorientierten Programmier- oder Skriptsprache verfasst sein, beispielsweise in C++, Java, Delphi, VBScript, Perl, PHP oder JavaScript. Über diese Schnittstelle haben Sie die Möglichkeit, die Daten eines XML-Dokuments in einer Anwendung zu ver- arbeiten oder zu verändern. In diesem Abschnitt lernen Sie, wie Sie mithilfe von JavaScript in den aktuellen Browsern direkt auf einzelne XML-Daten zugreifen und diese verändern können. Dieses Modell kann bei- spielsweise über Java oder PHP auf ähnliche Weise verwendet werden. Der Nachteil von DOM gegenüber dem später in diesem Kapitel erläuterten Modell SAX ist, dass bei umfang- reichen XML-Dokumenten das Erzeugen des Dokumentenbaums sehr zeitintensiv sein kann. Zudem besteht ein hoher Bedarf an Arbeitsspeicher, da die gesamte XML-Struktur während der Bearbeitung im Speicher gehalten werden muss. HTML und DOM Eine HTML-Datei kann als XML-Dokument betrachtet werden, da sie eine XML-ähnliche Struktur der verschie- denen Elemente besitzt. Daher kann auch das DOM auf HTML-Dokumente angewandt werden, solange die Browser die entsprechenden JavaScript-Anweisungen zum Ansprechen des DOMs verarbeiten können. Sie können die Elemente, die Attribute und den Inhalt jeder HTML-Datei auslesen und löschen, aber auch neue Elemente erstellen und in das Dokument einfügen. Somit haben Sie die Möglichkeit, Dokumente dyna- misch zu generieren, ohne dass der Browser erneut eine Verbindung zum Webserver herstellen muss. Dies ist möglich, da das DOM den Zugriff auf jedes Element eines XML-Dokuments erlaubt. Die Technik der dynamischen Änderung von Webseiten, ohne dass dabei eine Kommunikation mit dem Server erfolgen muss, wird als Ajax (Asynchrones JavaScript und XML) bezeichnet. Ajax beruht auf den vier Komponenten JavaScript, CSS, DOM und dem XMLHttpRequest-Objekt (vgl. den folgenden Abschnitt). Obwohl in Ajax-Anwendungen auf Grund der immer noch nicht vorhandenen einheitlichen XML- Unterstützung der einzelnen Browser aktuell in stärkerem Maße JSON (JavaScript Object Notation) statt XML für die Darstellung der Daten zum Einsatz kommt, ist XML dennoch weiterhin ein wichtiger Bestandteil von Ajax. Hochschulversion DOM und SAX 15 © HERDT-Verlag 157 15.2 Erzeugen eines XML-DOM Das Erzeugen eines XML-DOM-Objekts erfolgt über zwei verschiedene Wege. Der erste ist das Erzeugen eines Document Object Models über die API XMLHttpRequest. Erzeugen des Objekts über XMLHttpRequest XMLHttpRequest ist eine API zum Laden von Daten über das HTTP-Protokoll. Die Art der Daten ist hierbei egal. Es kann sich um reinen Text oder formatierte XML-Elemente handeln. Um mit dem Browser per JavaScript auf ein XML-Objekt zuzugreifen, muss dieses Objekt als Instanz von XMLHttpRequest angelegt werden. <script type=\"text/javascript\"> ObjektName = new XMLHttpRequest(); </script> Zum Laden und Verarbeiten der Daten sind zwei Methoden notwendig. open(Methode, URL[, Asynchron, Benutzername, Passwort]) send(Zeichenkette) Mit der Methode open laden Sie die zu verarbeitenden Daten. Über den Parameter Methode geben Sie die Art und Weise des Datenzugriffs über HTTP an. Meist wird die Methode GET oder POST verwendet. Mit URL geben Sie ein Skript oder eine Datei an, die vom Server geladen werden soll. Lokale XML-Dateien lassen sich aus Sicherheitsgründen im Browser nicht über die Methode open laden. Es ist zwingend notwendig, dass die XML- und HTML-Dateien auf einem Webserver abgelegt werden. Mit Ausnahme des Mozilla Firefox funktionieren deshalb die Beispiele des folgenden Abschnitts bei einer lokalen Ausführung nicht. Wenn Sie einen anderen Browser nutzen, laden Sie die Beispieldateien auf einen Ihnen verfügbaren freizugänglichen Webserver. Alternativ können Sie auch einen lokalen Webserver nutzen. Eine Möglichkeit zu dessen Einrichtung bietet die Installation von XAMPP, einer Web-Entwicklungsumgebung (https://www.apachefriends.org/de/index.html). Der optionale Wert von Asynchron legt fest, ob das Skript weiter ausgeführt werden soll, solange noch keine Daten zurückgeliefert worden sind (true), oder ob der Browser so lange warten soll, bis alle Daten in das Objekt geladen worden sind (false). In unseren Beispielen ist es sinnvoll, auf die komplette Datenrück- gabe zu warten. Wenn notwendig können der Benutzername und das Passwort für den Zugriff auf die URL hinterlegt werden. Mit der Methode send wird das Laden der Daten gestartet. responseText() responseXML() Je nachdem, welche Datenstruktur von dem aufgerufenen Skript erwartet wird, können Sie die Daten dem Objekt über die Methode responseText als Text übergeben. Mit responseXML wird die XML-Struktur dem Objekt als Document Object Model übergeben, auf das Sie mit den nachfolgenden Methoden und Eigen- schaften zugreifen können. Browserweiche zum Erzeugen des Objekts Das XMLHttpRequest wird von allen aktuellen Browsern unterstützt. Damit auch immer noch verwendete ältere Browser wie der Internet Explorer in den Versionen 6 und 7 das entsprechende Objekt erzeugen können und mit den nachfolgenden Eigenschaften und Methoden auf die einzelnen Elemente zugegriffen werden kann, wird eine sogenannte Browserweiche verwendet. Hochschulversion 15 XML 1.1 - Grundlagen 158 © HERDT-Verlag Beispiel: kap15\\loadxmldoc.js       function loadXMLDoc(filename) { if (window.XMLHttpRequest) { xhttp=new XMLHttpRequest(); } else { xhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } xhttp.open(\"GET\", filename, false); xhttp.send(); return xhttp.responseXML; }  Die Browserweiche wird als JavaScript-Funktion loadXMLDoc hinterlegt.  Mit window.XMLHttpRequest wird überprüft, ob der aktuell verwendete Browser diese API und deren Methoden kennt. Ist dies der Fall, wird das XML-Objekt über diese Methode erzeugt. Dieser Zweig wird von den aktuellen Browsern ausgeführt. Das Objekt xhttp wird erstellt.  Ältere Versionen des Internet Explorers benötigen das entsprechende ActiveX-Objekt.  Hier werden die Parameter zum Senden der Anfrage festgelegt. Die Daten sollen über die Methode GET übertragen werden. Die Variable filename, deren Wert mit der Funktion loadXMLDoc übergeben wird, beinhaltet die URL des aufzurufenden Skripts oder der XML-Datei. Die Datenübertragung soll nicht asynchron erfolgen (false). Der Browser soll auf die Rückmeldung des Servers warten.  Die Methode send startet die Datenabfrage.  Die Rückgabe der Daten wird im XML-Format erwartet und entsprechend im Objekt xhttp abgelegt und als Ergebnis der Funktion zurückgeliefert. 15.3 Ansprechen der Knotenelemente Das DOM ist ein Modell, das die Verbindung der verschiedenen Objekte mit anderen Objekten eines Doku- ments anzeigt. Im DOM stellt jeder Knoten ein Objekt in der Baumstruktur des Dokuments dar. So besteht beispielsweise die HTML-Angabe <div>Inhalt des Blocks</div> aus zwei Knoten, dem umschließenden Element div und dem Text \"Inhalt des Blocks\". Da sich der Text- knoten innerhalb des Elements div befindet, wird er auch als Kind-Knoten (child node) des Elements div be- zeichnet. Das umschließende Element wird Eltern-Knoten (parent node) genannt. <div> Inhalt des Blocks </div> Befindet sich innerhalb des Elements div ein weiteres Element, wie beispielsweise <div>Inhalt <i>des Blocks</i></div> enthält das Element div zwei Kind-Knoten, das Wort Inhalt sowie das Element i. Der Text \"des Blocks\" ist nun nicht mehr das Kind des Elements div, sondern das Kind des Elements i. <div> Inhalt <i> des Blocks </i> </div> Hochschulversion DOM und SAX 15 © HERDT-Verlag 159 Außerdem gibt es noch die Attributknoten (attribute nodes). Diese entstehen, wenn bei einem Element ein Attribut angegeben wird. <div style=\"text-align:center;\">Inhalt <i>des Blocks</i></div> Das Element div enthält nun drei Knoten, denn das Attribut style wird als Attributknoten betrachtet. <div style=\"text-align:center;\"> Inhalt <i> des Blocks </i> </div> Knoten durchlaufen Nach dem Festlegen des XML-Objekts benötigen Sie die Methoden und Eigenschaften zum Ansprechen der einzelnen Knotenpunkte und deren Inhalte. Die nachfolgende Tabelle stellt die Methoden und Eigenschaften des W3C DOM Level 3 dar, mit denen Sie in der DOM-Baumstruktur die Elemente durchlaufen können. Methode/Eigenschaft Erläuterung childNodes Alle Unterknoten (Kind-Knoten) des selektierten Knotens werden ausgelesen. parentNode Der übergeordnete Knoten (Eltern-Knoten) des selektierten Knotens wird angesprochen. hasChildNodes Damit können Sie prüfen, ob der selektierte Knoten weitere Unterknoten besitzt. firstChild Der erste untergeordnete Knoten wird selektiert. lastChild Der letzte untergeordnete Knoten wird selektiert. previousSibling nextSibling Hiermit erhalten Sie den vorherigen bzw. folgenden Schwester- Knoten des selektierten Knotens. getAttribute(\"Name\") Diese Eigenschaft liefert vom selektierten Knoten den Wert des mit Name angegebenen Attributs. Attributes() Der Attributwert eines selektierten Knotens wird über den Index ausgelesen (0 = erster Attributwert; 1 = zweiter Attributwert; 2 = dritter Attributwert usw.). nodeType Diese Eigenschaft liefert die Art des selektierten Knotens als Zahl zurück. Die wichtigsten sind: 1 = Elementknoten, 2 = Attributknoten, 3 = Textknoten. nodeName nodeValue Der Name bzw. der Wert oder Inhalt eines selektierten Knotens wird ausgegeben. tagName Hiermit erhalten Sie den Namen des Elements. textNode text Mit textNode ermitteln Sie den Inhalt eines selektierten Elements. Die Methode text ist die entsprechende Methode für den Internet Explorer und entspricht dem veralteten W3C DOM Level 2. Hochschulversion 15 XML 1.1 - Grundlagen 160 © HERDT-Verlag Zusätzlich haben Sie die Möglichkeit, über zwei Methoden bestimmte Elemente direkt anzusprechen. Methode Erläuterung getElementById(\"id\") Diese Methode liefert ein spezielles Element, das mit dem Attribut id eine eindeutige Kennung aufweist. getElementsByTagName(\"name\") Hiermit erhalten Sie alle Elementknoten, die dem gesuchten Namen entsprechen, als Array. Die einzelnen Knoten sprechen Sie über den Index an, z. B. getElementsByTagName(\"table\")[0]. Beispiel: kap15\\knoten.html Die Datenstruktur einer XML-Datei wird als Objekt erstellt. Über die Methoden und Eigenschaften des Objekts können die einzelnen XML-Knoten angesprochen werden.         <html lang=\"de\"> <head> <title>Musiksammlung</title> <script type=\"text/javascript\" src=\"loadxmldoc.js\"></script> </head> <body> <script type=\"text/javascript\"> XMLObjekt = loadXMLDoc(\"musiksammlung.xml\"); Knoten = XMLObjekt.firstChild; document.write('Hauptelement: ' + Knoten.nodeName + '<br \\/>'); KnotenElement = XMLObjekt.getElementsByTagName('TITEL')[0]; document.write('Knotenelement: ' + KnotenElement.nodeName + '<br \\/>'); document.write('Attribut ' + KnotenElement.attributes[0].nodeName + ' mit Wert ' + KnotenElement.attributes[0].nodeValue + '<br \\/>'); document.write('Attribut ' + KnotenElement.attributes[1].nodeName + ' mit Wert ' + KnotenElement.attributes[1].nodeValue + '<br \\/>'); </script> </body> </html>  Die JavaScript-Datei loadxmldoc.js mit der Funktion zum Laden der XML-Struktur wird geladen.  Dem Objekt XMLObjekt werden über die JavaScript-Funktion loadXMLDoc() die XML-Daten der Datei musiksammlung.xml übergeben.  Der Variablen Knoten wird das erste Kind der XML-Struktur zugewiesen.  Der Name des Knotens wird über die Eigenschaft nodeName im Browser ausgegeben.  Des Weiteren werden mit der Methode getElementsByTagName im Objekt XMLObjekt die Knoten mit dem Namen TITEL selektiert. Über die Angabe des Index 0 wird der Variablen KnotenElement der erste Knoten zugewiesen.  Der Name des Knotens wird ausgegeben. In dem Fall lautet er TITEL.  Über die Eigenschaft attributes erhalten Sie Zugriff auf alle Attribute des selektierten Knotens. Über die Angabe von attributes[0] sprechen Sie das erste Attribut an und können dessen Namen und Wert über die entsprechenden Eigenschaften ausgeben lassen.  Den Namen und Wert des zweiten Attributs erhalten Sie durch die Angabe des nächsten Index attributes[1]. Die Methoden beim Zugriff auf die Elemente einer XML-Struktur müssen Sie nicht zwingend in einer Variab- len speichern (Knoten = XMLObjekt.firstChild;). Sie können auch die Eigenschaft eines Elements direkt aufrufen, z. B. XMLObjekt.firstChild.nodeName. Zur Veranschaulichung des Aufrufs der Eigenschaften werden die Methoden noch einmal in Tabellenform dargestellt. In der entsprechenden Spalte finden Sie den Teil der XML-Struktur, der durch die Methode oder Eigenschaft angesprochen wird. Hochschulversion DOM und SAX 15 © HERDT-Verlag 161 firstChild childNodes attributes nodeValue <HAUPTELEMENT> <ELEMENT1 attr=\"xyz\"> Inhalt1 </ELEMENT1> <ELEMENT2 attr=\"uvw\"> Inhalt2 </ELEMENT2> </HAUPTELEMENT> Um beispielsweise den Inhalt des Elements ELEMENT2 auszulesen, verwenden Sie die Anweisung XMLObjekt.childNodes[1].nodeValue;. Den Attributwert des ersten Elements Element1 erhalten Sie, wenn Sie die Anweisung XMLObjekt.childNodes[0].attributes[0].nodeValue; verwenden. Beispiel: kap15\\person.xml Die folgende XML-Struktur wird als Beispiel verwendet. Sie enthält zwei Elemente mit dem Attribut geschlecht und unterschiedlichen Attributwerten.   <?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?> <DATEN> <PERSON geschlecht=\"männlich\">Max Mustermann</PERSON> <PERSON geschlecht=\"weiblich\">Sabine Salzmann</PERSON> </DATEN>  In der XML-Datei wird das Hauptelement DATEN definiert.  Die beiden Elemente PERSON enthalten das Attribut zum Bestimmen des Geschlechts sowie den Namen der entsprechenden Person. Beispiel: kap15\\DOM.html In dem nachfolgenden Beispiel sollen die Daten und Attributwerte der einzelnen Elemente der XML-Datei angesprochen und im Browser angezeigt werden.       <html lang=\"de\"> <head> <title>Musiksammlung</title> <script type=\"text/javascript\" src=\"loadxmldoc.js\"></script> </head> <body> <script type=\"text/javascript\"> XMLObjekt = loadXMLDoc(\"person.xml\"); xml_daten = XMLObjekt.getElementsByTagName('PERSON')[0]; document.write('<p><strong>') document.write(xml_daten.childNodes[0].nodeValue + '<\\/strong><br \\/>'); document.write(xml_daten.attributes[0].nodeName + ' = ' + xml_daten.attributes[0].nodeValue); xml_daten = XMLObjekt.getElementsByTagName('PERSON')[1]; document.write('<p><strong>') document.write(xml_daten.childNodes[0].nodeValue + '<\\/strong><br \\/>'); document.write(xml_daten.attributes[0].nodeName + ' = ' + xml_daten.attributes[0].nodeValue); </script> </body> </html> Hochschulversion 15 XML 1.1 - Grundlagen 162 © HERDT-Verlag  Die JavaScript-Datei loadxmldoc.js wird geladen.  Die zuvor erstellte XML-Datei person.xml wird in das Objekt geladen.  Mit getElementsByTagName wird auf den ersten Knoten mit dem Namen PERSON zugegriffen.  Über die JavaScript-Methode document.write() werden im Browser der Wert des Knotens sowie der Name und Wert des ersten Attributs ausgegeben.  Auf das nächste Element PERSON erhalten Sie Zugriff über die Angabe des Index [1].  Auch hier werden der Knoteninhalt sowie der Attributsname und dessen Wert angezeigt. Knoten automatisiert auslesen Damit Sie alle Unterelemente eines XML-Dokuments ansprechen können, muss eine Schleife verwendet werden. Diese Schleife wird dann so lange durchlaufen, bis alle Unterelemente ausgelesen sind. Oberste Ebene 1. Ebene 2. Ebene <MUSIKSAMMLUNG> <ALBUM> </ALBUM> <AUTOR></AUTOR> <INTERPRET></INTERPRET> <TITEL stil=\"\" bewertung=\"\"></TITEL> <GESAMTZEIT></GESAMTZEIT> <LABEL></LABEL> <JAHR></JAHR> <BILD typ=\"\" quelle=\"\" /> <LIED></LIED> </MUSIKSAMMLUNG> <ALBUM> </ALBUM> <AUTOR></AUTOR> <INTERPRET></INTERPRET> <TITEL stil=\"\" bewertung=\"\"></TITEL> <GESAMTZEIT></GESAMTZEIT> <LABEL></LABEL> <JAHR></JAHR> <BILD typ=\"\" quelle=\"\" /> <LIED></LIED> Diese Tabelle stellt die grundlegende Struktur der Musiksammlung dar. Die erste Ebene kann sich beliebig oft wiederholen, wobei auch die zweite Ebene dementsprechend oft angelegt wird. Die Anzahl der Schleifendurchläufe richtet sich nach der Anzahl der Elemente einer Ebene. So soll die Menge der Elemente der ersten und zweiten Ebene bestimmt werden. Es wird das erste Element der ersten Ebene selektiert und alle Unterelemente (zweite Ebene) werden ausgegeben. Danach werden das zweite Element der ersten Ebene und seine Unterelemente angesprochen, dann das dritte Element usw. Die Anzahl der Elemente einer Ebene wird über die Eigenschaft length ermittelt: selektierterKnoten.length Bei der Abfrage, wie viele Unterknoten ein Element besitzt, müssen Sie beachten, dass immer auch der Textknoten mitgezählt wird. Es sollen die Inhalte aller Elemente ausgegeben werden. Dazu sind die folgenden Schritte notwendig: Selektieren der obersten Ebene; Anzahl der Elemente der ersten Ebene ermitteln (childNodes.length); Schleife durchlaufen, in der alle Elemente der obersten Ebene ausgelesen werden; innerhalb der Schleife die Anzahl der Elemente der zweiten Ebene ermitteln (Kind(i).childNodes.length); weitere Schleife bilden, um die Inhalte aller Elemente der zweiten Ebene auszulesen. Ausgabe der XML-Daten im Browser Hochschulversion DOM und SAX 15 © HERDT-Verlag 163 Damit Sie die Inhalte der Elemente ausgeben können, müssen Sie in der Datei loadxmldoc.js eine weitere Funktion hinterlegen. Diese ist notwendig, weil in den Browsern, die den W3C DOM Level 3 unterstützen, die Inhalte der Elemente über textContent angesprochen werden. In den Browsern, die nur den W3C DOM Level 2 unterstützen, benötigen Sie die Eigenschaft text. Beispiel: kap15\\loadxmldoc.js    function getNodeText(xmlNode) { if (xmlNode != null) { // W3C DOM Level 3 if (typeof xmlNode.textContent != 'undefined') { return(xmlNode.textContent); } // W3C DOM Level 2 else if (typeof xmlNode.text != 'undefined') { return(xmlNode.text); } } }  Die Funktion wird getNodeText genannt und erwartet als Parameter den ausgewählten XML-Knoten, der innerhalb der Funktion über den Namen xmlNode angesprochen werden kann.  Ist dem Browser die Knoten-Eigenschaft textContent bekannt und liefert er somit nicht den Wert undefined zurück, dann wird der entsprechende Wert zurückgeliefert.  Ansonsten wird, wenn der Knoten xmlNode die Eigenschaft text besitzt, dessen Wert zurückgeliefert. Beispiel: kap15\\musik1.html       <script type=\"text/javascript\"> XMLObjekt = loadXMLDoc(\"musiksammlung.xml\"); Kind = XMLObjekt.getElementsByTagName('ALBUM'); document.write('<br \\/>Anzahl der Knoten: ' + Kind.length); /* Schleife für die 1.Ebene */ for (i=0; i < Kind.length; i++) { document.write('<br \\/><b>Anzahl der unteren Knoten in Knoten['+ i +']: ' + Kind[i].childNodes.length + '<\\/b>'); /* Schleife für die 2.Ebene */ for (j=0; j < Kind[i].childNodes.length; j++) { if (Kind[i].childNodes[j].nodeType == 1) { document.write('<br \\/>Inhalt des Knotens['+ i +','+ j +']: ' + Kind[i].childNodes[j].nodeName + ' - ' + getNodeText(Kind[i].childNodes[j])); } } } </script>  Die Elemente der XML-Datei musiksammlung.xml werden in das Objekt geladen.  Die Variable Kind enthält die Kind-Knoten der Elemente ALBUM. Dies ist notwendig, damit auf die weiteren Unterelemente zugegriffen werden kann. Wie viele Elemente vorhanden sind, wird über die Eigenschaft length angezeigt.  Die for-Schleife wird initialisiert und für alle Elemente der ersten Ebene (Kind.length) durchlaufen. Ausgegeben wird hierbei die Anzahl der jeweiligen Unterknoten. Hier werden Sie feststellen, dass alle Browser doppelt so viele wie der Internet Explorer ausgeben. Dies ist darauf zurückzuführen, dass der Internet Explorer nur die tatsächlichen Knoten zählt, die anderen Browser aber auch die Whitespace- Zeichen, z. B. Zeilenumbrüche, zählen.  In einer zweiten Schleife werden genau diese jeweiligen Unterknoten näher untersucht. Hochschulversion 15 XML 1.1 - Grundlagen 164 © HERDT-Verlag  Um auf das tatsächliche Knotenelement zugreifen zu können, fügen Sie eine Abfrage ein, ob es sich um einen Elementknoten (Knotentyp vom Wert 1) handelt.  Ist dies der Fall, können Sie den Namen des Knotens über die Eigenschaften nodeName ausgeben lassen. Den Inhalt lassen Sie über die definierte JavaScript-Funktion getNodeText() ermitteln, indem Sie den entsprechenden Knoten übergeben. Als Ergebnis erhalten Sie die Anzahl der Knoten der ersten Ebene, die Anzahl der jeweiligen Unterelemente sowie die Bezeichnung jedes einzelnen Elements und dessen Inhalt. Anzeige der gefundenen Knoten Knoten gezielt ansprechen Die Möglichkeit, per Skript durch das Dokument zu laufen und jedes Element einzeln anzusprechen, ist um- ständlich. Daher haben Sie auch die Möglichkeit, ein Element direkt anzusprechen, ohne vorher dessen über- geordnete Elemente durchlaufen zu müssen. Beispiel: kap15\\musik2.html Die Interpreten und Gruppen, die in der Datei musiksammlung.xml hinterlegt sind, sollen mit ihren bisher aufgenommenen Alben in einer übersichtlichen Tabelle aufgelistet werden. In der Spalte Bemerkung soll die jeweilige Anzahl der Lieder des Albums angezeigt werden. Folgende Schritte sind beim Selektieren der Daten notwendig: Ermitteln der Anzahl der Elemente der ersten Ebene; Schleife festlegen, in der alle Elemente der ersten Ebene durchlaufen werden; Ausgeben der Elemente INTERPRET bzw. GRUPPE und TITEL aus der zweiten Ebene; Ermitteln der Anzahl der Elemente LIED im jeweiligen ALBUM.        <body> <h2>Musiksammlung</h2> <p>Datenumfang: <span id=\"counter\"></span> Einträge</p> <div id =\"tabelle\"></div> <script type=\"text/javascript\"> XMLObjekt = loadXMLDoc(\"musiksammlung.xml\"); counter.innerHTML = XMLObjekt.getElementsByTagName('ALBUM').length; output = '<table><tr class=\"firstline\"><td><b>Interpret</b></td> <td><b>Album</b></td><td><b>Bemerkung</b></td></tr>'; Album = XMLObjekt.getElementsByTagName('ALBUM'); for (i=0; i < Album.length; i++) { output = output + '<tr>'; Hochschulversion DOM und SAX 15 © HERDT-Verlag 165         output = output + '<td>'; Interpret = Album[i].getElementsByTagName('INTERPRET'); if (Interpret.length == 0) { Interpret = Album[i].getElementsByTagName('GRUPPE'); } output = output + getNodeText(Interpret[0]); output = output + '</td>'; output = output + '<td>'; Titel = Album[i].getElementsByTagName('TITEL'); output = output + getNodeText(Titel[0]); output = output + '</td>'; output = output + '<td>'; Lieder = Album[i].getElementsByTagName('LIED'); output = output + 'Lieder:' + Lieder.length; output = output + '</td>'; output = output + '</tr>'; }; output = output + '</table>'; tabelle.innerHTML = output;</script> </body>  Die Stellen zur Ausgabe von Werten werden definiert. Die Elemente span und table, die beide mit einer jeweiligen ID versehen werden, sollen per JavaScript mit Daten gefüllt werden.  Die Elemente der XML-Datei musiksammlung.xml werden in das Objekt geladen.  Die Anzahl der Elemente ALBUM im XML-Dokument wird über die Suche nach dem Elementnamen (getElementsByTagName) ermittelt und über die Eigenschaft innerHTML an dem HTML-Tag ausgegeben, das mit der ID counter definiert wurde.  Es folgt der Aufbau der Tabelle, in der die Informationen angezeigt werden sollen. Zur besseren Übersicht werden diese Informationen in der Variablen output abgelegt.  Der Variablen Album wird das Objekt mit den gefundenen Alben zugewiesen. Das Ergebnis ist hierbei ein Array mit der entsprechenden Anzahl der Alben.  Mit der for-Schleife soll das Ansprechen der einzelnen Indizes des Arrays Album ermöglicht werden.  HTML-Anweisungen zum Aufbau der Tabelle werden in das Dokument geschrieben.  In der ersten Spalte der Tabelle wird der Name des Interpreten ausgegeben. Mit der Zählvariablen i ist es möglich, das jeweilige Element des Objekts Album anzusprechen. Hat die Variable i den Wert 0, wird das erste Album der Liste angesprochen, ist der Wert 1, das zweite Album usw. Die Methode getElementsByTagName liefert den Unterknoten des selektierten Albums, der den Namen des Interpreten enthält.  Sollte innerhalb des selektierten Albums kein Element INTERPRET vorhanden sein, wird nach dem Element GRUPPE gesucht und das Objekt der Variablen Interpret zugewiesen.  Da innerhalb des Elements ALBUM das Element INTERPRET bzw. GRUPPE nur einmal vorkommt, kann dessen Inhalt direkt über den Index 0 angesprochen werden. Die Funktion getNodeText() ist die selbst erstellte JavaScript-Funktion, die über die Datei loadxmldoc.js eingebunden ist.  Um den Titel des Albums herauszufiltern, wird innerhalb des Elements ALBUM nach den möglichen Elementen TITEL gesucht und diese in der Variablen Titel abgelegt. Der Knotentext des Elements TITEL wird über die JavaScript-Funktion ausgegeben.  Auch hier wird nach möglichen Elementen innerhalb des Elements ALBUM gesucht. In diesem Fall nach den Elementen LIED.  Statt des Namens eines jeden einzelnen Liedes wird über die Eigenschaft length die Anzahl der Lieder in die Variable output geschrieben.  Solange noch nicht alle Alben des XML-Dokuments ausgegeben sind, kehrt der Interpreter zurück zur Stelle  und führt die for-Schleife für das nächste Element ALBUM aus.  Ganz am Ende des Skripts wird der Inhalt der Variablen output an dem Element mit der ID tabelle als HTML-Text ausgegeben. Hochschulversion 15 XML 1.1 - Grundlagen 166 © HERDT-Verlag Formatierte Ausgabe der Musiksammlung Daten separieren In diesem Abschnitt wird ein Beispiel vorgestellt, bei dem spezielle Informationen erst dann angezeigt werden, wenn diese mithilfe von JavaScript-Anweisungen angefordert werden. Beispiel: kap15\\loadxmldoc.js In diesem Abschnitt wird bei Alben der Musiksammlung ein Hyperlink hinterlegt. Erst bei einem Klick auf den Namen des Albums soll sich ein weiteres Fenster öffnen, in dem die Daten des Albums aufgelistet werden. Dazu erstellen Sie die nachfolgende JavaScript-Funktion, die Sie in der Datei loadxmldoc.js einfügen.                 function OeffneInfoFenster(AlbumName) { Fenster = open(\"\", \"Individuell\", \"resizable=yes, screenX=0, screenY=0, height=400, width=300\"); Fenster.focus(); with (Fenster) { document.write('<html><head><title>'+ AlbumName +'<\\/title>'); document.write('<link type=\"text\\/css\" rel=\"stylesheet\" href=\"musik_link.css\" \\/>'); document.write('<\\/head>'); document.write('<body>'); document.write('<table border=\"1\" cellpadding=\"3\">'); Titel = XMLObjekt.getElementsByTagName('TITEL'); i = -1; if (Titel.length > 0) do { i++; if (getNodeText(Titel[i]) == AlbumName) { Album = Titel[i].parentNode; for (j = 0; j < Album.childNodes.length; j++) { if (Album.childNodes[j].nodeType == 1) { document.write('<tr>'); document.write('<td>' + Album.childNodes[j].nodeName + ': <\\/td>'); if (getNodeText(Album.childNodes[j]) != '') { document.write('<td>'+getNodeText(Album.childNodes[j])+'<\\/td>'); } else { document.write('<td>- Keine Angabe -<\\/td>'); } document.write('<\\/tr>'); } } } } while (getNodeText(Titel[i]) != AlbumName); document.write('<\\/table>'); document.write('<\\/body><\\/html>'); return Hochschulversion DOM und SAX 15 © HERDT-Verlag 167 } } </script>  Die JavaScript-Funktion OeffneInfoFenster muss mit einem Wert aufgerufen werden, der innerhalb der Funktion über die Variable AlbumName angesprochen werden kann. Dieser Wert soll den Titel des Albums enthalten.  Es wird ein neues Fenster mit einer Höhe von 400 Pixeln und einer Breite von 300 Pixeln geöffnet. Dieses Fenster kann über das Objekt Fenster angesprochen werden.  Die Anweisung with sorgt dafür, dass sich die in geschweiften Klammern stehenden Anweisungen auf das geöffnete Fenster beziehen.  Mit document.write werden das Grundgerüst und der Beginn der HTML-Tabelle in das Dokument des neuen Fensters eingefügt.  Der Variablen Titel wird das Objekt mit den gefundenen Elementen TITEL zugewiesen.  Die Variable i wird mit dem Wert -1 initialisiert und im weiteren Verlauf als Zählvariable zum Anspre- chen der verschiedenen Elemente TITEL verwendet.  Mit der Methode Titel.length kann die Anzahl der gefundenen Elemente TITEL abgefragt werden. Die if-Anweisung überprüft, ob überhaupt ein Element mit der Bezeichnung TITEL im XML-Dokument gefunden wurde und somit die Anzahl größer null ist.  Diese Anweisung leitet die fußgesteuerte Wiederholung do while ein. Dies bedeutet, dass die Schleife durchlaufen wird, solange die Bedingung  erfüllt ist.  Die Zählvariable i wird erhöht.  Mithilfe der Funktion getNodeText() wird getestet, ob das angesprochene Element TITEL den an die Funktion übergebenen Namen des Albums enthält und somit angezeigt werden soll.  Der Variablen Album wird der dem selektierten Element TITEL übergeordnete Eltern-Knoten zugeord- net.  Innerhalb dieser for-Schleife sollen alle Daten des selektierten Albums ausgegeben werden. Somit wird die Schleife so oft durchlaufen, bis die Anzahl Album.childNodes.length erreicht ist.  Nach der Abfrage des Knotentyps 1 und der Ausgabe des Knotennamens wird ausgewertet, ob der Kind- Knoten des Albums einen Inhalt besitzt (!= ''). Ist dies der Fall, wird der Text des Kind-Knotens aus- gegeben.  Besitzt das Element keinen Inhalt, wird als Alternative der Text - Keine Angabe - in das Dokument eingefügt.  Diese Zeile stellt den Fuß der Wiederholung do while dar. Wenn der Inhalt des selektierten Knotens TITEL nicht mit dem übergebenen Wert AlbumName übereinstimmt, wird die Schleife und somit die Datenausgabe beendet.  Die JavaScript-Funktion wird verlassen. Beispiel: kap15\\musiklink.html In diesem Beispiel wird bei den Namen der Alben ein Hyperlink hinterlegt, über den der Inhalt des jeweiligen Albums angezeigt werden kann. Ersetzen Sie dazu den Quelltext aus dem Beispiel musik2.html output = output + '<td>'; Titel = Album[i].getElementsByTagName('TITEL'); output = output + getNodeText(Titel[0]); output = output + '</td>'; durch die nachfolgenden Zeilen.    output = output + '<td>'; Titel = Album[i].getElementsByTagName('TITEL'); TitelText = getNodeText(Titel[0]); output = output + '<a href=\"javascript:OeffneInfoFenster(\\'' + TitelText + '\\')\">' + TitelText +'</a>'; output = output + '</td>'; Hochschulversion 15 XML 1.1 - Grundlagen 168 © HERDT-Verlag  Der Variablen Titel werden die Elemente TITEL zugeordnet.  Die Variable TitelText erhält als Wert den Inhalt des ersten Elements von Titel, also den Titel des selektierten Albums.  Die Definition eines Hyperlinks wird eingeleitet und in der Variablen output übergeben. Wird dieser Verweis vom Anwender ausgewählt, soll die JavaScript-Funktion OeffneInfoFenster() mit dem Wert von TitelText ausgeführt werden. Als sichtbarer Teil des Hyperlinks wird der Titel des selektierten Albums ausgegeben. Ausgabe von weiteren Daten nach dem Auslösen des Hyperlinks 15.4 SAX Die zweite Art, auf ein XML-Dokument zuzugreifen, ist die Verwendung von SAX (Kurzform für Simple API for XML). Dies ist ein ereignisgesteuerter Mechanismus zum Lesen der einzelnen XML-Elemente. Dabei wird nicht wie beim DOM ein Objektmodell des XML-Dokuments aufgebaut, sondern es werden Ereignisse aus- gelöst, auf die der Programmierer reagieren kann. Das XML-Dokument wird geparst, und die entsprechenden Ereignisse werden ausgelöst, wenn im Dokument Folgendes gefunden wird: der Anfang eines Elements (Anfangs-Tag) der Inhalt eines Elements das Ende eines Elements (Ende-Tag) Kommentare Entity-Definitionen Fehler oder Warnungen Ein SAX-Parser kann je nach Anforderung diese Ereignisse erzeugen. Der Nachteil dieses Parsers ist jedoch, dass ein Ereignis nur einmal erzeugt wird und somit nach dem Parsen nicht mehr auf die Elemente zuge- griffen werden kann. Dies bedeutet beispielsweise, dass für weitere Zugriffe die Struktur des XML- Dokuments intern gespeichert werden muss oder der SAX-Parser erneut das XML-Dokument durchläuft. Beispiel <ZITAT> Sein oder nicht sein, das ist hier die Frage. </ZITAT> Der Parser löst die folgenden Ereignisse aus: Anfang des Elements <ZITAT> Inhalt des Elements \"Sein oder...\" Ende des Elements </ZITAT> Hochschulversion DOM und SAX 15 © HERDT-Verlag 169 Wenn ein Ereignis eintritt, wird die entsprechende Methode, die das Ereignis verarbeitet im Programm (welches den SAX-Parser nutzt) aufgerufen. Diese Methode wird auch als EventHandler bezeichnet. Beispiels- weise könnte beim Auffinden des Elements ZITAT der nachfolgende Text in roter und kursiver Schriftforma- tierung auf dem Bildschirm angezeigt werden. Der Zugriff auf die XML-Daten wird überwiegend über das Document Object Model (DOM) realisiert. Da die Struktur des XML-Dokuments als Dokumentenbaum im Speicher gehalten wird, können Sie jederzeit auf die einzelnen Elemente zugreifen. SAX wird vorwiegend zum einmaligen Einlesen eines XML-Dokuments genutzt, ist dafür schnell und benötigt keinen Speicher für die Repräsentation des XML-Dokuments. 15.5 XML-Datenblöcke in HTML5 Befindet sich XML-Quelltext innerhalb einer HTML-Seite, wird dies als Dateninsel (engl. Data Island) bezeich- net. Eine Dateninsel ermöglichte Ihnen bisher, XML direkt in HTML zu integrieren, ohne die entsprechenden Daten durch ein Skript oder eine XSL-Anweisung laden zu müssen. Der Nachteil war bisher, dass Dateninseln nur vom Internet Explorer unterstützt wurden. Mit Einführung von HTML5 ist es möglich, sogenannte Datenblöcke in HTML-Code unterzubringen, wie z. B. XML. Interner Datenblock Ein XML-Datenblock wird über das Tag script und die Angabe, dass es sich um XML-Daten handelt, eingeleitet. <script id=\"\" type=\"application/xml\"> XML Daten </script> Über das Attribut id weisen Sie dem Datenblock eine eindeutige Kennung zu, mit der Sie später auf die Daten zugreifen können. Das Attribut type bestimmt, dass es sich nachfolgend um XML-Daten handelt. Die XML-Daten geben Sie direkt zwischen den script-Tags an. Innerhalb eines HTML-Dokuments können Sie auch mehrere XML-Datenblöcke einbinden. Dabei ist zu beach- ten, dass jeder Datenblock eine eindeutige Kennung id besitzt, mit der die jeweiligen Daten angesprochen werden können. Beispiel: kap15\\datenblock1.html In dem HTML-Dokument werden die bisherigen XML-Daten als Datenblock eingebunden.    <!DOCTYPE html> <html> <head> <title>XML Datenblock</title> <script type=\"text/javascript\" src=\"loadxmldoc.js\"></script> <link type=\"text/css\" rel=\"stylesheet\" href=\"musik_link.css\"> <script id=\"musiksammlung\" type=\"application/xml\"> <!DOCTYPE MUSIKSAMMLUNG SYSTEM \"musikstil.dtd\" [ <!ENTITY MRL \"Mute Records Limited\"> <!ENTITY IRL \"Island Records Limited\"> <!ENTITY JR \"Jarrett Records\"> <!ENTITY WR \"WEA Records\"> <!ENTITY PCD \"Pilz Compact Disc\"> <!ENTITY hs \"Heiko Schröder\"> <!ENTITY mm \"Max Mustermann\"> ]> <MUSIKSAMMLUNG> Hochschulversion 15 XML 1.1 - Grundlagen 170 © HERDT-Verlag  <ALBUM> <!-- alle weiteren XML-Elemente --> </ALBUM> </MUSIKSAMMLUNG> </script> </head>  Der Inhalt der HTML-Datei wird über die Dokumenttyp-Definition als HTML5 definiert.  Der Datenblock wird über script und die Angabe von application/xml als XML definiert. Zur Iden- tifikation erhält der Datenblock die eindeutige Kennung musiksammlung.  Hier geben Sie den Inhalt der bisher eingebundenen Datei musiksammlung.xml inklusive der Entitäten- Definition an.  Mit </script> schließen Sie den XML-Datenblock. Die XML-Daten werden zwar in den Browser geladen, jedoch nicht angezeigt. XML-Daten auslesen Mithilfe von JavaScript können Sie die Informationen des Datenblocks auslesen und auswerten. Dabei wird der Datenblock als Objekt über die festgelegte Kennung id angesprochen. Um auf die Daten zugreifen zu können, müssen Sie den Inhalt des XML-Datenblocks über dessen ID ansprechen und den Inhalt einer Variable übergeben. xmlSource = document.getElementById(\"id\").textContent; parser = new DOMParser(); Objekt = parser.parseFromString(xmlSource, \"application/xml\"); Die Browser stellen über DOMParser() eine API zur Verfügung, mit der eine Zeichenkette anhand einer festgelegten Spezifikation geparst und das Ergebnis an ein Objekt übergeben werden kann. Beispiel: kap15\\datenblock2.html Fügen Sie in die HTML-Datei datenblock1.html die nachfolgende, bereits bekannte JavaScript-Anweisung zum Auflisten der Interpreten, Alben und Bemerkungen ein.       <!-- ... --> <h2>Musiksammlung</h2> <p>Datenumfang: <span id=\"counter\"></span> Einträge</p> <div id=\"tabelle\"></div> <script type=\"text/javascript\"> xmlSource = document.getElementById(\"musiksammlung\").textContent; parser = new DOMParser(); XMLObjekt = parser.parseFromString(xmlSource, \"application/xml\"); Album = XMLObjekt.getElementsByTagName('ALBUM'); document.getElementById('counter').innerHTML = Album.length; output = '<table><tr class=\"firstline\">'; output = output + '<td><b>Interpret</b></td>' + '<td><b>Album</b></td><td><b>Bemerkung</b></td></tr>' for (i=0; i < Album.length; i++) { output = output + '<tr>'; output = output + '<td>'; Interpret = Album[i].getElementsByTagName('INTERPRET'); if (Interpret.length == 0) { Interpret = Album[i].getElementsByTagName('GRUPPE'); } output = output + getNodeText(Interpret[0]); output = output + '</td>'; Hochschulversion DOM und SAX 15 © HERDT-Verlag 171 output = output + '<td>'; Titel = Album[i].getElementsByTagName('TITEL'); output = output + getNodeText(Titel[0]); output = output + '</td>'; output = output + '<td>'; Lieder = Album[i].getElementsByTagName('LIED'); output = output + 'Lieder: ' + Lieder.length; output = output + '</td>'; output = output + '</tr>'; }; output = output + '</table>'; document.getElementById('tabelle').innerHTML = output; </script> <!-- ... -->  Der Inhalt des Elements mit der ID musiksammlung wird der Variablen xmlSource übergeben.  Das Objekt parser vom Typ DOMParser wird erstellt.  Über dieses Objekt wird mithilfe der Methode parseFromString der Inhalt der Variablen xmlSource geparst. Der zu erwartende Inhalt ist vom Typ XML. Das Ergebnis und somit das Document Object Model wird in der Variablen XMLObjekt abgelegt.  Die Anzahl der gefundenen Elemente ALBUM aus der Variablen XMLObject wird am HTML-Tag mit der ID counter ausgegeben.  In Abhängigkeit von der Albenanzahl werden die entsprechenden XML-Daten in der Variablen output gespeichert.  Am Ende wird der Inhalt dieser Variablen als HTML-Text dem Tag mit der ID tabelle übergeben. Dieses Beispiel lässt sich beliebig erweitern. So könnte auch in dieser HTML-Seite eine Informationsabfrage des jeweiligen Albums nach dem Betätigen des entsprechenden Hyperlinks realisiert werden. Externen Datenblock einbinden Das Einbinden externer Datenblöcke wird derzeit nur vom Internet Explorer und dem Mozilla Firefox unter- stützt. Die anderen Browser werten den Inhalt des object-Tags falsch aus. Sind die Daten der XML-Datei sehr umfangreich, können Sie die Daten wie bisher auch in einer separaten XML-Datei definieren und dann im HTML-Quelltext einbinden. Hierfür können Sie das HTML-Tag object verwenden. <object id=\"ID\" data=\"XML-Datei\" type=\"text/xml\" style=\"display:none;\"></object> Über den Parameter id definieren Sie die eindeutige Kennzeichnung und über data legen Sie die einzulesen- de XML-Datei fest. Mit type=\"text/xml\" stellen Sie sicher, dass der Inhalt auch als XML angesehen wird. Die Stylesheet-Angabe style=\"display:none bewirkt, dass das Objekt nicht im Browser angezeigt wird. Den Inhalt der XML-Datei laden Sie über die Angabe der ID und der Methode contentDocument. XMLObjekt = document.getElementById(\"id\").contentDocument; Beispiel: kap15\\datenblock3.html <!DOCTYPE html> <html> <head> <title>XML Datenblock</title> <script type=\"text/javascript\" src=\"loadxmldoc.js\"></script> <link type=\"text/css\" rel=\"stylesheet\" href=\"musik_link.css\"></link> Hochschulversion 15 XML 1.1 - Grundlagen 172 © HERDT-Verlag <script type=\"text/javascript\"> function loadData() { var XMLObjekt = document.getElementById(\"musiksammlung\").contentDocument; var Album = XMLObjekt.getElementsByTagName('ALBUM'); /* ... */ } </script> </head> <body onLoad=\"loadData();\"> <h2>Musiksammlung</h2> <p>Datenumfang: <span id=\"counter\"></span> Einträge</p> <div id =\"tabelle\"></div> <object id=\"musiksammlung\" data=\"musiksammlung.xml\" type=\"text/xml\" style=\"display: none;\"></object> </body> </html> 15.6 Übungen Übung 1: Interner Datenblock Übungsdatei: kap15\\ms.xml, kap15\\loadxmldoc.js Ergebnisdateien: kap15\\uebung1.html, kap15\\uebung2.html  Erweitern Sie das Beispiel des eingebundenen internen Datenblocks. Erstellen Sie einen Hyperlink zum Namen des Interpreten. Beim Auslösen des Verweises sollen alle Alben des Interpreten in einem neuen Fenster aufgelistet werden. Dazu muss der Interpret mit mehreren Alben im XML-Dokument vorhanden sein.  Realisieren Sie das Beispiel mithilfe eines externen Datenblocks für die Browser Firefox und Internet Explorer. Übung 2: Daten separieren Übungsdatei: kap15\\kfz.xml Ergebnisdatei: kap15\\uebung3.html Erstellen Sie eine Übersicht einer Fahrzeugverwaltung mit der Ausgabe der Hersteller und des Fahrzeugmodells. Über einen entsprechenden Link sollen die technischen Daten in einem neuen Fenster eingeblendet werden. Hochschulversion DOM und SAX 15 © HERDT-Verlag 173 Hochschulversion 16 XML 1.1 - Grundlagen 174 © HERDT-Verlag 16 XHTML 1.1 In diesem Kapitel erfahren Sie wie sich XHTML vom bisherigen Standard HTML unterscheidet wie Sie Ihre bisherigen HTML-Dokumente unter Beachtung des XHTML-Standard anpassen Voraussetzungen HTML-Kenntnisse 16.1 Überblick zu XHTML Ansatz Ausgehend von der Meta-Auszeichnungssprache SGML entstand HTML als SGML-Applikation. Mit der fortschreitenden Verbreitung von HTML erwies es sich als problematisch, dass von den Herstellern eine Reihe unterschiedlicher browserinterner HTML-Tags unterstützt wurde. Ein Beispiel ist das für den Internet Explorer typische Tag marquee. Dieser ermöglicht einen Lauftext, ähnlich einem Nachrichtenticker. Dieses Element entspricht nicht dem HTML-Standard des W3-Konsortiums, wird aber aus Gründen der Kompatibilität auch von anderen Browsern interpretiert. Die Browser Firefox und Opera interpretieren beispielsweise wiederum das Element blink, andere Browser nicht. Ein weiteres Problem von HTML ist der notwendige großzügige Umgang der Browser mit fehlerhaften Seiten. Um diese verarbeiten und darstellen zu können, müssen Browser entsprechende Routinen enthalten. Dies führt zu sinkenden Ausführungszeiten und zu einer unnötigen Vergrößerung der Programme. XHTML ist eine auf XML basierende Empfehlung zur Weiterentwicklung von HTML zur Behebung dieser Probleme. Die wichtigste Änderung gegenüber HTML ist, dass die XHTML-Quelldateien entsprechend den XML-Regeln wohlgeformt sein müssen, nach den XHTML-Regeln geschriebene HTML-Dokumente also keine Fehler in der Struktur der HTML-Tags enthalten dürfen. Dies ermöglicht es den Entwicklern, die Ausführungsgeschwindigkeit von Browsern zu erhöhen, da in den Programmen keine Routinen mehr zur Verarbeitung von fehlerhaftem Code enthalten sein müssen. Des Weiteren kann XHTML-Code über eine standardisierte Dokumenttyp-Definition geprüft werden. Damit verringert sich die Größe der Programme. Nicht regelkonforme Webseiten zeigen deshalb fehlerhafte Dokumente nicht mehr an. Stattdessen erscheint eine Fehlermeldung, ähnlich den Fehlermeldungen beim Ausführen von fehlerhaftem JavaScript. Entwicklung Das W3-Konsortium hatte mit der HTML-Version 4.01 vom 24. Dezember 1999 die weitere Standardisierung der Sprache HTML bis ins Jahr 2008 eingestellt. Die Sprache XHTML wurde als neuer Standard für Webseiten entwickelt. Ziel dieser Entwicklung war es, den Inhalt, die Struktur und die Formatierung eines Dokuments voneinander zu trennen und die Vorteile von HTML 4.0 und XML 1.0 zu vereinen. In der Empfehlung XHTML 1.0 (Extensible Hypertext Markup Language) aus dem Jahr 2000 (siehe http://www.w3.org/TR/xhtml1/) wurde auf eine Einhaltung der Rückwärtskompatibilität zu den verbreiteten HTML-Browsern geachtet, wobei neuere Browser die Dokumente entsprechend der strengeren Regeln von XHTML verarbeiten konnten. XHTML 1.0 ist im Prinzip eine Neuformulierung von HTML 4.01 unter Berücksichtigung der Einhaltung der XML-Regeln. Die vorhandenen Dokumenttypen Strict, Transitional und Frameset werden unterstützt. Hochschulversion XHTML 1.1 16 © HERDT-Verlag 175 Der zweite Entwicklungsschritt XHTML 1.1 aus dem Jahr 2010 (siehe http://www.w3.org/TR/xhtml11/) schränkte die ursprünglich erlaubten Möglichkeiten von HTML stärker ein. Der Umfang der Sprache wurde im Wesentlichen auf die Unterstützung des Dokumenttyps Strict reduziert. Elemente und Attribute der Dokumenttypen Transitional und Frameset, welche die Darstellung der Seite direkt steuern, wurden entfernt. Die fehlende Kompatibilität zu bestehenden Browserprogrammen wurde dabei bewusst akzeptiert. Veraltete Elemente und Attribute, die bisher als „deprecated“ geduldet wurden, dürfen nicht mehr verwendet werden. XHTML wurde modularisiert, indem die HTML-Tags in Modulen zusammengefasst werden (z. B. Text-, Formular-, Tabellen-, Grafik-, Objektmodul, siehe http://www.w3.org/TR/xhtml-modularization. Weitere wichtige Änderungen sind: Die Attribut-Angabe lang entfällt an einzelnen Elementen und wird zentral als Attribut xml:lang festgelegt. Die Attributangabe von name bei den Elementen a und map entfällt und ist durch das Attribut id zu ersetzen. Ankerpunkte sind z. B. als <a id=\"ankername\" /> zu setzen. Hinzugekommen ist das Modul ruby mit verschiedenen neuen Elementen (rbc, rtc, rb, rt, rp). Damit können kurze Anmerkungen oder die Aussprache von Texten hinzugefügt werden. Diese Art der Darstellung ist vor allen Dingen aus dem ostasiatischen Raum bekannt. Somit kann z. B. neben einer Abkürzung der vollständige Begriff angegeben werden (siehe nebenstehende Abbildung). HTML5 und XHTML5 Lange Zeit wurde seitens des W3-Konsortiums an einer Spezifikation für XHTML 2.0 gearbeitet. Im Dezember 2010 wurde die entsprechende Arbeitsgruppe geschlossen und die Entwicklung von XHTML 2.0 zugunsten des neuen HTML5-Standards eingestellt. Eine Ursache für diese Entwicklung war die zum Teil fehlende Akzeptanz der neuen strengeren Regeln der Webseitengestalter und -programmierer. Der für XHTML 2.0 geplante Bruch mit dem Erbe von HTML und die damit einhergehenden grundlegenden Änderungen der Webseitengestaltung waren nicht mehrheitsfähig. Stattdessen wurde eine schrittweise Verbesserung von HTML unter Beibehaltung der bisherigen Grundprinzipien und Regeln als neues Ziel bestimmt, welches mit der Entwicklung von HTML5 konsequent verfolgt wird. HTML5 ist jedoch keine komplette Abkehr von den mit XHTML angestrebten Zielen. Die bei der Entwicklung von HTML5 federführende WHATWG (Web Hypertext Application Technology Working Group), ein Zusam- menschluss führender Browserhersteller (siehe https://whatwg.org/), sieht in ihrer Einordnung HTML5 als abstrakte Sprache, welche unterschiedliche Syntaxvarianten enthalten kann – sowohl HTML als auch XHTML. Je nach verwendetem Typ wird es vom Browser als HTML-Dokument verarbeitet oder als XML Dokument geparst. Wird ein HTML5-Dokument mittels XML-Syntax und nach den Regeln von XHTML dargestellt, wird dafür die Bezeichnung XHTML5 verwendet, ohne dass es sich dabei um eine definierte Empfehlung wie bei den Versionen XHTML 1.0 oder 1.1 handelt. XHTML hatte bisher und wird damit auch weiterhin eine gewisse Bedeutung bei der Gestaltung von Webseiten besitzen. Es obliegt letztendlich dem Entwickler, welche Ausprägung der Syntax er nutzt. Die folgenden Abschnitte fassen die Unterschiede von HTML und XHTML zusammen und zeigen XHTML als eine mögliche Anwendung von XML. 16.2 XHTML-Dokument deklarieren Dokumenttyp und Zeichensätze Die Anzahl möglicher Sprachversionen, die ein Browser beim Lesen einer HTML-Datei beherrschen muss, wird immer größer. Deshalb ist es sinnvoll, wenn Sie die HTML-Version, die Sie in Ihren Dateien verwenden, an den Anfang einer jeden HTML-Datei schreiben. Die Versionsangabe ist ein Hinweis auf eine bestimmte HTML- Sprachversion. Hochschulversion 16 XML 1.1 - Grundlagen 176 © HERDT-Verlag Die Angabe von <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\"> besagt zum Beispiel, dass sich die nachfolgenden Zeilen des HTML-Dokuments genau an die HTML-4.01- Definition des W3-Konsortiums halten. Diese Angabe hatte keine Konsequenzen für die Darstellung der HTML-Datei und wurde deshalb von den Autoren einer Webseite vernachlässigt. Das ändert sich jedoch mit der Verwendung von XHTML. Um festzulegen, dass es sich im Nachfolgenden um eine Datei nach dem Standard XHTML 1.1 handelt, ist die folgende Dokumenttyp-Definition anzugeben: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"> Mit der Angabe dieses Dokumenttyps weisen Sie darauf hin, dass Ihr Dokument den strengen XHTML-Regeln der Version 1.1 genügt. Die in der Version 1.0 noch geduldeten veralteten Angaben werden entweder durch entsprechende Stylesheet-Angaben ersetzt oder alternativ über die Standardeinstellungen des Clients forma- tiert. Aus HTML bekannte, aber nicht mehr empfohlene Elemente werden nicht verwendet. Weiterhin müssen Sie in einer HTML-Datei den im Dokument verwendeten Zeichensatz spezifizieren. Diese Spezifikation muss ebenfalls in XHTML erfolgen. <meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\" /> In diesem Fall wird darauf hingewiesen, dass innerhalb des Dokuments Zeichen des westeuropäischen Zei- chensatzes ISO-8859-1 verwendet werden. Grundstruktur eines XHTML-Dokuments Folgende Angaben sind innerhalb eines Dokuments vorzunehmen, um es eindeutig als XHTML-Dokument zu deklarieren. Der Dokumenttyp ist anzugeben. Das Hauptelement ist wie bisher das Element html. Das Hauptelement muss eine xmlns-Deklaration für XHTML-Namensräume enthalten. Der Namens- raum für XHTML ist definiert als http://www.w3.org/1999/xhtml. Das Grundgerüst eines XHTML-Dokuments sieht z. B. folgendermaßen aus: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"> <html xmlns=\"http://www.w3.org/1999/xhtml\"> <head> <title> </title> </head> <body> </body> </html> Hochschulversion XHTML 1.1 16 © HERDT-Verlag 177 16.3 Elemente in XHTML Groß- und Kleinschreibung Entsprechend der Regelungen von XML ist die einheitliche Groß- bzw. Kleinschreibung der Tags zu beachten. In XHTML werden alle HTML-Tags kleingeschrieben. Das folgende Beispiel ist in HTML korrekt, in XHTML jedoch falsch: <H1 Align=\"center\">nachfolgender Text</h1> In XHTML müsste dieses Beispiel so geschrieben werden: <h1 align=\"center\">nachfolgender Text</h1> Öffnende und schließende Tags Alle geöffneten Tags müssen in XML auch ein schließendes Tag besitzen. Diese Regel wurde ebenfalls in XHTML übernommen. In HTML können Sie an vielen Stellen das schließende Tag weglassen, ohne dass der Browser eine Fehlermeldung einblendet. <ol> <li>Dies ist ein Listenelement <li>Dies ist ein weiteres Listenelement </ol> In XHTML müssen Sie das schließende Tag </li> hinzufügen. <ol> <li>Dies ist ein Listenelement</li> <li>Dies ist ein weiteres Listenelement</li> </ol> Jedes Start-Tag müssen Sie auch wieder mit dem entsprechenden Ende-Tag schließen. Ein Spezialfall sind die allein stehenden Elemente: area, base, br, col, frame, hr, img, input, isindex, link, meta, option und param. Um mit älteren Browsern kompatibel zu bleiben, müssen Sie vor dem Zeichen ein Leerzeichen und einen Schrägstrich schreiben. <br /> <hr /> <img src=\"bild.jpg\" alt=\"alternativer Text\" /> Sie können diese Elemente jedoch auch als öffnendes und schließendes Tag schreiben. Es ist daher nicht falsch, wenn Sie statt der möglichen Kurzform <br /> die ausführliche Schreibweise <br></br> benutzen. Verschachtelung von HTML-Tags Die Reihenfolge der Elemente muss logisch gegliedert sein. Einzelne Elemente dürfen sich in XML nicht überlappen. Das folgende Beispiel ist daher in XHTML falsch: <b><i>fetter kursiver Text</b></i> <p>Ein Text mit <em>einer logischen Textauszeichnung.</p></em> Die korrekte Schreibweise in XHTML lautet: <b><i>fetter kursiver Text</i></b> <p>Ein Text mit <em>einer logischen Textauszeichnung.</em></p> > / Hochschulversion 16 XML 1.1 - Grundlagen 178 © HERDT-Verlag Blockelemente, wie h1 … h6, p oder auch hr, erzeugen im Dokument stets einen Zeilenvorschub. Inline- Elemente tun dies nicht, sie enthalten die Textdaten und weitere Inline-Elemente. Sie erzwingen keinen Zeilenvorschub und werden verwendet, um Textelemente besonders zu kennzeichnen. Da die Inline-Elemente innerhalb von Blockelementen verwendet werden, sind sie den Blockelementen unter- geordnet. Es ist daher nicht erlaubt, dass ein Inline-Element ein Blockelement umschließt. <span><p>lange Textpassagen oder einzelne Worte</p></span> Das Element p ist dem Element span übergeordnet, da p ein Blockelement und span ein Inline-Element ist. Somit darf span nicht das Element p umschließen, sondern p muss span umschließen. <p><span>lange Textpassagen oder einzelne Worte</span></p> Kombinationen Einige Kombinationen von HTML-Tags sind verboten. So darf beispielsweise innerhalb der physischen Aus- zeichnung pre in XHTML kein Bild img angegeben werden. Folgende Elemente dürfen die anderen angegebenen Elemente nicht enthalten: Das Element darf das Element … nicht enthalten a a pre img, object, big, small, sub, sup button input, select, textarea, label, button, form, fieldset, iframe, isindex label label form form 16.4 Attribute und Werte in XHTML Anführungszeichen In XHTML müssen alle Attribute auch einen Wert besitzen. Die Werte sind immer in Anführungszeichen zu setzen, auch wenn sie nur aus einer Zahl oder einer Prozentangabe bestehen. Beispielsweise ist <td valign=top> <img alt=\"alternativer Text\" width=300% height=25 /> </td> keine gültige XHTML-Angabe. Die Anführungszeichen müssen in diesem Fall angegeben werden. <td valign=\"top\"> <img alt=\"alternativer Text\" width=\"300%\" height=\"25\" /> </td> Kurzschreibweise Die Kurzschreibweise von Attributen ist in XHTML erlaubt. Folgende Attribute sind von dieser Regelung betroffen: compact, nowrap, ismap, declare, noshade, checked, disabled, readonly, multiple, selected, noresize, defer. Hochschulversion XHTML 1.1 16 © HERDT-Verlag 179 <input name=\"text\" rows=\"20\" cols=\"50\" readonly /> <select name=\"auswahl\" size=\"5\" multiple> <option>Auswahl 1</option> <option>Auswahl 2</option> <option>Auswahl 3</option> </select> Stattdessen ist der Name des Attributs noch einmal als Wert in Anführungszeichen anzugeben. <input name=\"text\" rows=\"20\" cols=\"50\" readonly=\"readonly\" /> <select name=\"auswahl\" size=\"5\" multiple=\"multiple\"> <option>Auswahl 1</option> <option>Auswahl 2</option> <option>Auswahl 3</option> </select> Eine weitere Änderung betrifft die Tags a, applet, form, frame, iframe, img und map. In HTML werden sie über die Attribute name oder id eindeutig gekennzeichnet, in XHTML werden sie nur noch über das Attribut id referenziert. Es ist aus Gründen der Kompatibilität zu älteren Browsern noch möglich, zusätzlich das Attribut name zu belassen. Aus der Schreibweise <a name=\"marke\">Stelle, die angesprungen werden soll.</a> wird <a name=\"marke\" id=\"marke\">Stelle, die angesprungen werden soll.</a> 16.5 JavaScript und Stylesheets in XHTML In HTML können JavaScript- und Stylesheet-Anweisungen im Dokument angegeben werden. Diese sind vom Typ PCDATA und können somit eine beliebige Zeichenfolge enthalten. Damit müssen die Daten vor der Ver- wendung überprüft werden. So wird sichergestellt, dass die Angaben beim Seitenaufbau korrekt verwendet werden können. In XHTML müssen die internen Stylesheet-Angaben abgewandelt werden, da sie nicht vom Programm überprüft werden sollen. Aus der internen Stylesheet-Angabe <style> .Klasse { <!-- Angabe der Stylesheets --> } </style> wird in der XHTML-1.1-Spezifikation: <style type=\"text/css\"> <![CDATA[ .Klasse { <!—Angabe der Stylesheets --> } ]]> </style> Die einzelnen Stylesheet-Klassen werden durch einen CDATA-Block <![CDATA[ ... ]]> umschlossen. Damit werden die Angaben nicht vor der Verwendung überprüft. Dies ist wichtig, da die Stylesheet-Angabe keine XML-Elemente enthält, sondern die Formatierungsdefinitionen für das Dokument. Hochschulversion 16 XML 1.1 - Grundlagen 180 © HERDT-Verlag Ähnlich verhält es sich mit der internen Angabe von JavaScript-Anweisungen. Auch hier muss der bisherige JavaScript-Programmabschnitt <script type=\"text/javascript\"> // JavaScript-Anweisungen </script> abgewandelt werden, damit diese nicht als XML-Anweisungen ausgewertet werden. <script type=\"text/javascript\"> <![CDATA[ // JavaScript-Anweisungen ]]> </script> Eine Alternative ist es, externe JavaScript- und Stylesheet-Dokumente zu verwenden. An der Einbindung dieser Daten ändert sich gegenüber HTML 4.0 nichts. 16.6 W3C MarkUp Validation Service Ob eine HTML-Datei den Anforderungen des XHTML-Formats entspricht, können Sie mit dem MarkUp Vali- dation Service des W3-Konsortiums testen. Öffnen Sie in Ihrem Browser die Internetadresse http://validator.w3.org. Webseite zum Testen eines XHTML-Dokuments Erfolgreich getestetes XHTML-Dokument Wechseln Sie in das Register Validate By File Upload, um die XHTML-Datei auf den Server zu übertragen. Klicken Sie neben dem Eingabefeld File auf die Schaltfläche Durchsuchen. Wählen Sie Ihre XHTML-Datei aus. Betätigen Sie die Schaltfläche Check. Ihr Dokument wird auf den Server des W3-Konsortiums übertragen. Dort wird es mithilfe eines Skripts auf die korrekte Verwendung von XHTML-Elementen und Attributen getestet. Verstößt Ihr Dokument gegen keine XHTML-Regel, erscheint die Ausgabe: This document was successfully checked as XHTML1.1! In diesem Fall können Sie das offizielle Zeichen des W3-Konsortiums auf Ihrer Webseite integrieren. Damit zeigen Sie Ihren Besuchern, dass Ihre Webseite XHTML-1.1-kompatibel ist. Hochschulversion XHTML 1.1 16 © HERDT-Verlag 181 16.7 Übung HTML-Datei in XHTML-Datei umwandeln Übungsdatei: kap16\\vorgabe.html Ergebnisdatei: kap16\\uebung.html  Konvertieren Sie die nachfolgende HTML-Datei in das XHTML-Format. Welche HTML-Tags sind nach den XHTML-Richtlinien falsch? <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <html> <head> <title>HTML nach XHTML</title> <style type=\"text/css> h2 { font-family: Verdana, Arial, sans-serif; font-size: 14pt; color: #CC0133; font-weight: bold } p, li { font-family: Georgia, 'Times New Roman', Times, serif; font-size: 10pt; color: #000080 } </style> </head> <body> <H2>HTML nach XHTML</h2> <p>Dieses HTML-Dokument soll in das XHTML-Format konvertiert werden. <ul> <Li>Listeneintrag 1 <Li>Listeneintrag 2 <Li>Listeneintrag 3 </ul> <form method=\"POST\" action=\"mailto:\"> <p><input type=\"text\" name=\"Eingabe\" size=20 readonly> <p><textarea rows=2 name=\"Memo\" cols=20 readonly></textarea> <p><input type=\"submit\" value=\"Abschicken\"> <input type=\"reset\" value=\"Zurücksetzen\"> </form> </body> </html>  Kontrollieren Sie mithilfe des HTML Validation Service des W3-Konsortiums die Korrektheit Ihres XHTML-Dokuments. Nehmen Sie Änderungen an dem XHTML-Code vor, bis Sie das offizielle XHTML-Zeichen des W3-Konsortiums erhalten. Hochschulversion 17 XML 1.1 - Grundlagen 182 © HERDT-Verlag 17 SVG In diesem Kapitel erfahren Sie was SVG ist wie Sie eine SVG-Grafik erzeugen können wie Sie eine SVG-Grafik in eine HTML5-Webseite integrieren können Voraussetzungen Aufbau von XML-Dokumenten HTML-Kenntnisse 17.1 SVG-Grundlagen SVG (Scalable Vector Graphics) ist eine XML-Anwendung zur Darstellung von Vektorgrafiken. Sie ist eine der wichtigsten Formen zur Darstellung von grafischen Inhalten im Web und auf Mobilgeräten. Der Vorteil der Verwendung von einer SVG-Grafik im Vergleich zu einer Datei im Bildformat besteht darin, dass SVG lediglich aus textlichen Informationen – den XML-Daten – besteht, was sich positiv auf die Datenmenge und damit auf die Übertragungsgeschwindigkeit auswirkt. Viele der gängigen Webbrowser sind in der Lage, ohne die zusätzliche Installation einer Erweiterung (eines Plug-In) SVG-Grafiken in nahezu vollem Sprachumfang darstellen. Bei älteren Browsern, beispielsweise dem Internet Explorer 8 und früher, ist die Installation eines Plug-in zur Darstellung von SVG-Grafiken erforderlich. SVG basiert auf einer DTD (http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd. Das zeigt, dass diese Technik trotz der Einführung von XML-Schema sehr leistungsfähig ist. Die Elemente der DTD ermöglichen alle typischen Elemente einer Grafik – von einzelnen zweidimensionalen geometrischen Objekten wie Kreisen und Rechtecken, über Texte bis hin zu Spezialeffekten wie Farbverläufen und Animationen. SVG entspricht dem Objektmodell und ermöglicht so die dynamische Manipulation der vorhandenen Objekte über Skripte. Die erste SVG-Spezifikation des W3C stammt bereits aus dem Jahr 2001. Die aktuelle Empfehlung 1.2 wurde 2011 veröffentlicht. Mit der Aktualisierung wurde eine Modularisierung eingeführt. Damit existieren nun spezielle Teile für mobile (SVG mobile) und für plattformübergreifende (SVG tiny) Anwendungen. Die Informationen des W3C finden Sie unter dem Link http://www.w3.org/Graphics/SVG/ über die Einstiegsseite zum Thema SVG. 17.2 Erzeugung von SVG-Grafiken SVG-Editoren Zur Erstellung von SVG-Grafiken existieren viele Programme. Ein oft genutztes Werkzeug ist beispielsweise das Open Source Programm Inkspace (https://inkscape.org/de/). Webeditoren, wie SVG-Edit (http://svg- edit.googlecode.com/svn/branches/stable/editor/svg-editor.html), bieten ebenfalls umfangreiche Möglich- keiten zur Grafikerstellung. Des Weiteren unterstützen viele Programme, zum Beispiel Microsoft Visio, den Export von Zeichnungen im SVG-Format. Hochschulversion SVG 17 © HERDT-Verlag 183 Der Editor SVG-Edit SVG-Tags SVG-Dateien bestehen analog zu HTML aus einer Reihe definierter Tags. Einige wichtige sind: Element Beschreibung <a> erstellt einen Link um ein SVG-Element <animate> definiert die Änderung eines Attributs innerhalb einer bestimmten Zeit <animateColor> definiert eine Farbänderung <animateMotion> bewirkt die Bewegung eines referenzierten Elements entlang eines Pfades <animateTransform> transformiert ein Attribut eines Elementes (z.B. hinsichtlich Größe und Rotation) <circle> definiert einen Kreis <ellipse> definiert eine Ellipse font definiert einen Zeichensatz font-face beschreibt einen Zeichensatz <g> gruppiert Elemente <image> definiert ein Bild <line> definiert eine Linie metadata beschreibt die Metadaten der Abbildung <rect> definiert ein Rechteck script dient als Container für Skripte (z.B. ECMAScript) set setzt den Wert eines Attributes für eine bestimmte Zeitdauer style ermöglicht die direkte Einbettung von Stylesheets in SVG <svg> umschließt das SVG-Dokument <text> definiert einen Text <title> beschreibt eine SVG-Grafik oder ein -Element, wird nicht angezeigt, kann jedoch als Tooltip (Mouse-Over-Effekt) angezeigt werden Die SVG-Referenz finden Sie auf der Webseite http://www.w3schools.com/svg/svg_reference.asp. Hochschulversion 17 XML 1.1 - Grundlagen 184 © HERDT-Verlag Beispiel kap17/svg_demo.xml Das Beispiel stellt in einer einfachen Grafik drei Elemente dar – ein Rechteck, einen Kreis und einen Text. Der Quellcode wurde automatisch durch das Zeichnen der Abbildung im Webeditor SVG-Edit und der anschlie- ßenden Speicherung erzeugt. Einige Attribute der Elemente mit dem Wert null wurden hier aus Gründen der Übersichtlichkeit entfernt.         <?xml version=\"1.0\"?> <svg width=\"640\" height=\"480\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:svg=\"http://www.w3.org/2000/svg\"> <!-- Created with SVG-edit - http://svg-edit.googlecode.com/ --> <g> <title>Layer 1</title> <rect id=\"svg_1\" height=\"47.25\" width=\"53.250005\" y=\"150.750008\" x=\"122.750038\" stroke-width=\"2\" stroke=\"#000000\" fill=\"#ffff00\"/> <circle id=\"svg_2\" r=\"31.878906\" cy=\"197.625011\" cx=\"170.750022\" stroke-width=\"2\" stroke=\"#000000\" fill=\"#ff0000\"/> <text xml:space=\"preserve\" text-anchor=\"middle\" font-family=\"serif\" font-size=\"24\" id=\"svg_3\" y=\"204.000015\" x=\"169.250053\" stroke-width=\"0\" stroke=\"#000000\" fill=\"#0000ff\">SVG</text> </g> </svg>  Die Größe der SVG-Grafik wird über die Attribute width und hight im die Grafik umschließenden <svg> Tag festgelegt.  Der SVG-Namensraum wird angegeben.  Die Elemente werden in einer Gruppe zusammengefasst.  Der Titel Layer 1 wird der Gruppe zugewiesen.  Das Rechteck wird definiert. Um es referenzieren zu können, erhält es eine eindeutige ID. Als Attribute werden die Höhe und Breite, die Position, die Linienstärke und -farbe sowie die Füllfarbe angegeben.  Die Definition des Kreises mit den Eigenschaften Radius, Position, Linienstärke bzw. -farbe und Füllfarbe erfolgt.  Das Textelement wird erstellt. Die Attribute für die Darstellung der Zeichen werden definiert und der auszugebende Text als Inhalt des Tags angegeben. Die Beispielsgrafik in der Browserdarstellung Beispiel kap17/svg_demo2.xml Durch das Hinzufügen des Sub-Tags <animateTransform> lässt sich der Text in der Grafik animieren.   … <text xml:space=\"preserve\" text-anchor=\"middle\" font-family=\"serif\" font-size=\"24\" id=\"svg_3\" y=\"204.000015\" x=\"169.250053\" stroke-width=\"0\" stroke=\"#000000\" fill=\"#0000ff\" >SVG <animateTransform attributeName=\"transform\" type=\"scale\" begin=\"0\" dur=\"3\" from=\"0\" to=\"1\" /> </text> … Hochschulversion SVG 17 © HERDT-Verlag 185  Die Definition des Textes.  Der SVG-Namensraum wird angegeben. Der Typ der Transformation ist scale. Über die Attribute begin und dur werden der Startzeitpunkt und die Dauer der Animation angegeben. Die Spanne der Attribute from … to bestimmt die Vergrößerung des Textes. 17.3 Einbindung von SVG in HTML5 Ursprünglich war SVG als Ergänzung zu XHTML angedacht. Da sich dieses nicht in dem Umfang wie erwartet unter den Webentwicklern durchgesetzt hat, war die Zukunft von SVG unsicher. Dies änderte sich mit der Einführung von HTML5. Eine SVG-Grafik kann direkt in eine HTML5-Datei eingebunden werden – sowohl in integrierter Form als auch als externe Ressource (als Embedded Content). Die Tags der Grafik werden vom Browser wie normale HTML- Tags verarbeitet. Eine Verwendung eines speziellen XML-Parsers ist somit nicht notwendig. Da der Code der SVG-Insel im HTML5-Code vom Browser als reiner HTML-Code betrachtet wird, muss er nicht zwingend wohlgeformt sei. In XHTML5 kann der SVG-Code als wohlgeformtes XML-Fragment unter Verwendung des zugehörigen Namensraums ebenfalls integriert werden. Zur Einbindung einer externen SVG-Datei stehen in HTML5 mehrere Varianten zur Verfügung: Einbindung über Prinzip den <object>-Tag <object type=\"image/svg+xml\" data=\"datei.svg\"> Alternativtext </object> ein <iframe>-Element <iframe src=\"bild.svg\"> Alternativtext </iframe> den <img>-Tag <img src=\"bild.svg\" /> CSS als Hintergrund #back {background-image: url(image.svg);} Bei der Verwendung des Tags <img> und beim Einbinden der SVG-Grafik als Hintergrundbild mittels CSS sind Einschränkungen bei den enthaltenen Elementen in der Grafik zu beachten. Beispielsweise dürfen diese keine Animationen enthalten. Beispiel kap17/svg_demo3.html Die Datei svg_demo3.html wird über das <object>-Tag in eine HTML5-Webseite eingebunden.  <!DOCTYPE html> <head> <meta charset=\"utf-8\" /> <title>Eingebettete SVG Grafik</title> </head> <body> <object type=\"image/svg+xml\" data=\"svg_demo.xml\"> Ihr Browser unterstützt keine SVG-Grafik </object> </body> </html>  Aufruf der SVG-Grafikdatei unter Angabe des Typs image/svg+xml. Für Browser, welche die Daten nicht darstellen können, wird ein Alternativtext festgelegt. Hochschulversion I XML 1.1 - Grundlagen 186 © HERDT-Verlag # #FIXED ............................................ 42 #IMPLIED ........................................ 42 #PCDATA .......................................... 31 #REQUIRED ..................................... 42 & &gt; ............................................... 132 &lt; ................................................ 132 < <!ATTLIST ..................................... 40 <!DOCTYPE ............................... 29, 34 <!ELEMENT ..................................... 30 <!ENTITY .................................. 47, 50 <!NOTATION ................................... 51 <?xml?> .......................................... 16 <?xml-stylesheet ............... 99, 116 A Achse ............................................. 104 achse::knotenprüfung [prädikat] ........................... 104 Ajax ............................................... 156 all .................................................. 86 Altova XMLSpy .................................. 5 Anfangs-Tag .................................... 15 any .................................................. 90 ANY .................................................. 33 anyAttribute ............................... 91 anyURI ............................................ 80 Anzahl, Elemente ............................ 87 Apple Safari ...................................... 4 arc ................................................ 142 ASCII-Zeichensatz ............................ 17 Attribut ........................................... 21 Attribut, Schema ............................. 71 Attributaufzählung ........................ 45 Attribute node .............................. 159 Attribute, Kurzschreibweise ......... 178 Attribute, XHTML ......................... 178 Attribute, XLink ............................ 137 attributeGroup ........................... 89 Attributes ................................. 159 Attributliste..................................... 40 Attributname .................................. 22 Attributtyp ...................................... 45 Attributvorgabe .............................. 41 Aufzählung, Attribut- ..................... 45 Auswahl, Elemente ......................... 86 Auszeichnung ................................. 15 Auszeichnungssprachen ................... 8 Axis Specifier ................................. 104 B Baumstruktur .................................. 18 Baumstrukturen ............................ 102 Baumtransformation .................... 115 Bedingte Datentypen ..................... 94 Befehlskombination ...................... 178 Bogen ............................................ 142 boolean .......................................... 80 Browserweiche .............................. 157 C Cascading Style Sheets .................... 98 Case-sensitive................................... 15 CDATA ........................................ 16, 45 Child node ..................................... 158 childNodes .................................. 159 choice ............................................ 86 Chrome .......................................... 4, 5 CML .................................................. 10 complexType .................................. 82 Conditional Type Alternatives ........ 94 CSS ............................................... 9, 98 CTA .................................................. 94 D date................................................. 78 Datenaustausch ............................... 11 Datenblock, extern ........................ 171 Datenblock, intern ........................ 169 Datenformatierung ......................... 96 Dateninsel (Data Island) ................ 169 Datenselektion .............................. 116 Datentyp .......................................... 76 Datentyp, Schema ........................... 70 Datentypen, XPath 2.0 .................. 110 Datum .............................................. 78 decimal .......................................... 77 Dezimalzahl ..................................... 77 display: ........................................ 99 Document Object Model, DOM .... 156 Dokument strukturieren ................. 23 Dokument, gültiges ......................... 37 Dokumenttyp ................................ 175 Dokumenttyp-Definition ............... 176 Dokumenttyp-Definition (DTD) ...... 28 DOMParser .................................... 170 DSSSL ............................................... 96 DTD ............................................ 10, 28 DTD (Document Type Definition) ..... 9 DTD, Aufbau .................................... 32 DTD, externe .................................... 34 DTD, interne .................................... 29 duration ........................................ 79 Durchlaufregel .............................. 140 E Editor ............................................... 25 Einschränkung, Schema................... 72 Element ..................................... 14, 18 Element, Attribut ............................ 21 Element, Inhalt ................................ 32 Element, komplex ........................... 82 Element, leer ................................... 83 Element, mit einem Inhalt .............. 18 Element, ohne Inhalt ....................... 20 Elementbezeichnung ...................... 15 Elementgruppe ............................... 30 Elementhierarchie ........................... 20 Elementinhalt.......................... 32, 120 Elementtyp ...................................... 30 Elementverknüpfung ...................... 30 Eltern-Element .............................. 105 Eltern-Knoten................................ 159 EMPTY .............................................. 33 encoding ........................................ 17 End-Tag ........................................... 15 Entität ............................................. 15 Entity ............................................... 47 ENTITY ............................................ 47 Entity, externe................................. 50 Ereignisse ...................................... 168 erweitern, Schema .......................... 90 EventHandler ................................ 169 Extensible HTML ........................... 174 extension ...................................... 85 F Fallunterscheidung ............... 130, 132 Fassetten ................................... 72, 91 Feinstruktur ..................................... 24 Filter für XML-Daten ....................... 97 Filter, XPath .................................. 119 Firefox ............................................... 4 firstChild ................................. 159 FLWOR-Ausdrücke ........................ 150 for, XPath 2.0 ................................ 110 Formal Public Identifier .................. 35 Formatierung .................................. 96 FPI .................................................. 35 Free XML Editor Editix ...................... 5 Funktionen, XPath ........................ 112 G Ganzzahl ......................................... 77 Geschwister ................................... 105 getAttribut ............................... 159 getElementById ......................... 160 getElementsByTagName ............ 160 Google Chrome ............................. 4, 5 Grobstruktur ................................... 23 Groß- und Kleinschreibung ............ 15 group .............................................. 88 Gruppe, Attribute ........................... 89 Gruppe, Elemente ........................... 88 Gültiges Dokument ......................... 37 H hasChildNodes ........................... 159 Hauptelement ......................... 19, 105 Hierarchie, Element- ....................... 20 HTML ................................................. 8 HTML in XSL .................................. 128 HTML Validation Service ............... 180 HTML4 ........................................... 174 HTML5 ........................................... 175 Hyperlink ....................................... 136 Hochschulversion Index I © HERDT-Verlag 187 I ID 45, 46 IDREF ...............................................45 Indikator ..........................................86 Inhaltsmodell ...................................33 integer ..........................................77 Internet Explorer .............................. 4 Intervall, Datentyp...........................79 ISO ...................................................17 ISO 639 .............................................22 J JavaScript ....................................... 179 JSON ............................................... 156 K Kalender ..........................................78 Kind-Element ................................. 104 Kind-Knoten .................................. 159 Knoten ........................................... 105 Knotenanzahl ................................ 162 Knotenprüfung .............................. 107 Kombination, Befehls- ................... 178 Kommentare ....................................22 Kommentare, XPath ...................... 107 Kurzschreibweise ..................... 21, 178 L last ............................................... 108 lastChild .................................... 159 Latin-Zeichensatz .............................17 length.............................................74 Location Paths ............................... 105 locator ........................................ 141 Lokalisierung ................................. 104 M MathML ...........................................10 maxOccurs ......................................87 minOccurs ......................................87 mixed ...............................................85 Mozilla Firefox .................................. 4 Mustervergleich ............................. 119 N Nachfahre ...................................... 104 Nachkomme ................................... 105 Namensraum....................................57 Namensraum, XLink ...................... 137 nextSibling ................................ 159 NMTOKEN ..........................................46 node ............................................... 107 Node Test ............................... 104, 107 nodeName ...................................... 159 nodeType ...................................... 159 nodeValue .................................... 159 normalizedString .......................76 Notation...........................................51 NOTATION ........................................47 O Obergrenze ..................................... 87 ODER-Funktion ................................ 31 Offene Modelle ............................... 93 Opera ............................................. 4, 5 Operatoren, XPath ........................ 111 P Parent node ................................... 158 parent::node ............................. 108 parentNode .................................. 159 Parser ............................................... 37 Parser, XML- ...................................... 9 pattern ............................................ 73 PCDATA ............................................ 31 position ...................................... 108 Prädikat ......................................... 108 previousSibling ....................... 159 Prolog ........................................ 14, 16 PUBLIC ............................................ 35 R RegExpressions ................................ 73 Reihenfolge, Elemente ................... 86 Reservierte Zeichen ......................... 15 responseText ................................. 157 responseXML ................................. 157 restriction .................................. 72 S Safari ................................................. 4 SAX ................................................ 168 SAX-Parser ..................................... 168 Schema ...................................... 10, 64 Schema, Attribut ............................. 71 Schema, Datentyp ........................... 70 Schema, einfaches Element ............ 70 Schema, Einschränkungen .............. 72 Schema, extern ................................ 67 Schemaweite Attribute ................... 93 Schleifen ........................................ 126 Selektierungspfad ......................... 105 Selektor ......................................... 115 self::node .................................. 108 Semantik.......................................... 97 sequence ........................................ 86 SGML ................................................. 8 Simple API for XML, SAX ............... 168 simpleContent ............................. 84 simpleType .................................... 72 SMIL ................................................. 10 Sortieren ........................................ 129 Sprungmarke ................................. 136 SQL ................................................ 146 standalone .................................... 34 string ............................................ 76 Strukturieren eines Dokuments ...... 23 Stylesheet ...................................... 179 SVG .................................................. 96 T tagName........................................ 159 Template ................................ 116, 118 Template-Aufrufe ......................... 122 textNode ..................................... 159 time ................................................ 79 title ............................................ 143 token .............................................. 76 Token .............................................. 45 Transformation ............................... 97 Transformationsphase .................. 115 U Übungsdateien ................................. 6 Uhrzeit ............................................ 79 Unterelement ................................. 19 URI ............................................. 34, 57 URL .................................................. 34 UTF-8 ............................................... 16 UTF-8/16 .......................................... 17 V Valid Document .............................. 37 Validierung ................................ 28, 38 Verknüpfung, Element- .................. 30 Verschachtelung von HTML-Tags ... 177 Versionsangabe .............................. 16 Verweis, erweiterter .............. 141, 142 Verweis, lokaler ............................ 138 Verweis, multidirektionaler .......... 140 Vorfahre ................................. 104, 105 Vorlage .................................. 116, 118 W W3C ................................................... 8 Wahrheitswert, Datentyp ............... 80 Webcode ........................................... 6 Well Formed Document ................. 23 Wert prüfen, Fallunterscheidung ................. 132 Wertebereich, Schema .................... 72 Wertvorgabe, Attribut- .................. 41 WHATWG ...................................... 175 whitespace ................................... 74 Wildcard .......................................... 90 Wohlgeformtheit ....................... 23, 37 X XAMPP .......................................... 157 XBase............................................. 144 XHTML ..................................... 10, 174 XLink ........................................ 10, 136 XLink, einfacher Link .................... 138 XLink, erweiterte Links ................. 140 XLink, multidirektionale Links...... 140 xlink:extended .............................. 140 xlink:simple ............................. 137 XML (Extensible Markup Language) ..............................9, 14 XML Namespaces ............................ 57 Hochschulversion I XML 1.1 - Grundlagen 188 © HERDT-Verlag XML Schema .................................... 64 XML Schema 1.1 .............................. 91 XML verwenden .............................. 11 XML, Entstehung .............................. 8 XML-Element .................................. 18 XML-Fragment .............................. 152 XMLHttpRequest........................... 157 XML-Knoten .................................. 102 xmlns ........................................ 57, 59 xmlns:Namensraum ....................... 58 XML-Prüfung ................................... 38 XMLSpy ......................................... 152 XML-Syntax ..................................... 14 XML-Tools ......................................... 5 XPath .......... 10, 97, 102, 114, 119, 148 XPath 2.0 ....................................... 109 XPath-Datentypen ........................ 103 XPath-Dokumentreihenfolge ....... 103 XPath-Funktionen ......................... 108 XPath-Ausdrücke ........................... 149 XPointer ................................... 10, 136 XQJ................................................. 148 XQuery ............................................. 10 XQuery 1.0 ..................................... 146 XQuery, Abfrageausdrücke ........... 147 XQuery, Datenmodell ................... 146 XQuery, Implementierungen ........ 148 XQuery, Syntax .............................. 146 XQuery-Abfrage ............................ 152 XSL ........................................... 10, 114 XSL (Extensible Stylesheet Language) ................................. 96 XSL, Namensraum.......................... 115 xsl:apply-templates ............... 116 xsl:call-templates ................. 118 xsl:choose .................................. 132 xsl:for-each .............................. 126 xsl:if .......................................... 130 xsl:otherwise ........................... 132 xsl:sort ...................................... 129 xsl:value-of ............................. 120 xsl:when ...................................... 132 XSL-FO ..............................97, 114, 115 XSL-FO (XSL Formatting Objects) ... 98 XSLT ......................................... 10, 114 XSLT (XSL-Transformation) ............. 97 Z Zeichen, reservierte......................... 15 Zeichenkette, Datentyp .................. 76 Zeichenlänge, Schema .................... 74 Zeichensatz ............................. 17, 176 Zeitraum .......................................... 79 Zusicherungen................................. 92 Hochschulversion Impressum Matchcode: XML11 Autor: Elmar Fuchs, Heiko Schröder Redaktion: Andrea Weikert Produziert im HERDT-Digitaldruck 5. Ausgabe, Januar 2015 HERDT-Verlag für Bildungsmedien GmbH Am Kümmerling 21-25 55294 Bodenheim Internet: www.herdt.com E-Mail: info@herdt.com © HERDT-Verlag für Bildungsmedien GmbH, Bodenheim Alle Rechte vorbehalten. Kein Teil des Werkes darf in irgendeiner Form (Druck, Fotokopie, Mikrofilm oder einem anderen Verfahren) ohne schriftliche Genehmigung des Verlags reproduziert oder unter Verwendung elektroni- scher Systeme verarbeitet, vervielfältigt oder verbreitet werden. Dieses Buch wurde mit großer Sorgfalt erstellt und geprüft. Trotzdem können Fehler nicht vollkommen aus- geschlossen werden. Verlag, Herausgeber und Autoren können für fehlerhafte Angaben und deren Folgen weder eine juristische Verantwortung noch irgendeine Haftung übernehmen. Wenn nicht explizit an anderer Stelle des Werkes aufgeführt, liegen die Copyrights an allen Screenshots beim HERDT-Verlag. Sollte es trotz intensiver Recherche nicht gelungen sein, alle weiteren Rechteinhaber der verwen- deten Quellen und Abbildungen zu finden, bitten wir um kurze Nachricht an die Redaktion. Die in diesem Buch und in den abgebildeten bzw. zum Download angebotenen Dateien genannten Personen und Organisationen, Adress- und Telekommunikationsangaben, Bankverbindungen etc. sind frei erfunden. Eventuelle Übereinstimmungen oder Ähnlichkeiten sind unbeabsichtigt und rein zufällig. Die Bildungsmedien des HERDT-Verlags enthalten Verweise auf Webseiten Dritter. Diese Webseiten unterliegen der Haftung der jeweiligen Betreiber, wir haben keinerlei Einfluss auf die Gestaltung und die Inhalte dieser Web- seiten. Bei der Bucherstellung haben wir die fremden Inhalte daraufhin überprüft, ob etwaige Rechtsverstöße bestehen. Zu diesem Zeitpunkt waren keine Rechtsverstöße ersichtlich. Wir werden bei Kenntnis von Rechts- verstößen jedoch umgehend die entsprechenden Internetadressen aus dem Buch entfernen. Die in den Bildungsmedien des HERDT-Verlags vorhandenen Internetadressen, Screenshots, Bezeichnungen bzw. Beschreibungen und Funktionen waren zum Zeitpunkt der Erstellung der jeweiligen Produkte aktuell und gültig. Sollten Sie die Webseiten nicht mehr unter den angegebenen Adressen finden, sind diese eventuell inzwischen komplett aus dem Internet genommen worden oder unter einer neuen Adresse zu finden. Sollten im vorliegen- den Produkt vorhandene Screenshots, Bezeichnungen bzw. Beschreibungen und Funktionen nicht mehr der beschriebenen Software entsprechen, hat der Hersteller der jeweiligen Software nach Drucklegung Änderungen vorgenommen oder vorhandene Funktionen geändert oder entfernt. Hochschulversion","libVersion":"0.3.1","langs":""}